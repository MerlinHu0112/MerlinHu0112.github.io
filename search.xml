<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java的反射机机制：原理与使用</title>
    <url>/2020/03/25/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>面试过程中被问及Java反射，回答得不是很好，特别是关于反射的底层原理。现复习、总结成文。</p>
<a id="more"></a>

<p>反射的主要类</p>
<p>java.lang.Class</p>
<p>Field</p>
<p>Method</p>
<p>Constructor</p>
<p>Modifier</p>
<hr>
<p>1、反射的底层原理</p>
<p>以使用 Class.forName()为例</p>
<p>首先调用Class类的forName方法，传入类或接口的全限定名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>2、Spring IoC是如何利用反射的</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题集（一）：链表问题集合</title>
    <url>/2020/03/24/%E5%89%91%E6%8C%87Offer%E9%A2%98%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>《剑指Offer》中涉及的链表问题集合。</p>
<p>总结：</p>
<ul>
<li>对单链表的操作，善用两个指针！</li>
<li>对单链表的逆序操作，优先考虑递归或栈辅助。</li>
<li>对单链表的删除操作，常常要考虑设置dummyNode，以便操作头节点。</li>
<li>对单链表倒数第K个元素的操作，可用双指针，其中first指针要先行K步。</li>
<li>对循环单链表的操作，可用快慢指针。</li>
</ul>
<hr>
<a id="more"></a>

<blockquote>
<p>题目来源于《剑指Offer》第二版。同样的题目，在牛客网和LeetCode《剑指Offer》专区的表示和要求或许稍有差异，但算法实现是相同的。</p>
</blockquote>
<hr>
<h4 id="面试题06-从尾到头打印链表【递归-or-栈】"><a href="#面试题06-从尾到头打印链表【递归-or-栈】" class="headerlink" title="面试题06. 从尾到头打印链表【递归 or 栈】"></a>面试题06. 从尾到头打印链表【递归 or 栈】</h4><p>题目：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>思路：</p>
<ul>
<li>递归实现</li>
<li>栈辅助</li>
</ul>
<p>实现：</p>
<p><em>递归实现</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        recursion(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recursion(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>栈辅助</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 借助栈先进后出的特点，实现单链表逆序打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode current = head; <span class="comment">// 当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 统计节点个数</span></span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(current); <span class="comment">// 压入节点指针</span></span><br><span class="line">            current = current.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            res[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>递归和栈辅助算法，时间复杂度均为：O(N)；</li>
<li>递归和栈辅助算法，空间复杂度均为：O(N)。</li>
</ul>
<hr>
<h4 id="面试题18-1-删除链表的节点"><a href="#面试题18-1-删除链表的节点" class="headerlink" title="面试题18(1). 删除链表的节点"></a>面试题18(1). 删除链表的节点</h4><p>题目：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。</p>
<p>思路：与<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">LeetCode上的改进版</a>和<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">LeetCode第237题-删除链表中的节点</a>不同，此题给定头指针和目标节点指针，且要求时间复杂度为O(1)。</p>
<p>此题分为三种情形：</p>
<ul>
<li>链表仅有一个节点，且目标节点和头节点为该节点：直接置null。</li>
<li>目标节点是中间节点：类似LeetCode第237题的实现，用目标节点的下一节点元素值覆盖目标节点，并移除目标节点的下一节点即可。</li>
<li>目标节点是尾节点：遍历链表（<strong>遍历操作时间复杂度不就是O(N)?</strong>）</li>
</ul>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode deleteNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="keyword">null</span> || deleteNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表仅有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head==deleteNode)&#123;</span><br><span class="line">        head = <span class="keyword">null</span>; <span class="comment">// 他人在此处写的是"head.next==null"。既然只有一个节点，其next比如为null，认为将head置null即可实现删除。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标节点是中间节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(deleteNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode nextNode = deleteNode.next;</span><br><span class="line">        deleteNode.val = nextNode.val;</span><br><span class="line">        deleteNode.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标节点是尾节点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=deleteNode)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：平均为O(1)，坏情况下为O(N)；</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h5 id="另：LeetCode第237题-删除链表中的节点"><a href="#另：LeetCode第237题-删除链表中的节点" class="headerlink" title="另：LeetCode第237题-删除链表中的节点"></a>另：LeetCode第237题-删除链表中的节点</h5><p>题目限定：链表至少有两个节点，目标节点一定有效且不为尾节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode deleteNode)</span> </span>&#123;</span><br><span class="line">    ListNode pNext = deleteNode.next;</span><br><span class="line">    deleteNode.val = pNext.val; </span><br><span class="line">    deleteNode.next = pNext.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面试题18-2-删除链表中的重复节点【双指针】"><a href="#面试题18-2-删除链表中的重复节点【双指针】" class="headerlink" title="面试题18(2). 删除链表中的重复节点【双指针】"></a>面试题18(2). 删除链表中的重复节点【双指针】</h4><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p>
<p>思路：注意需要删除全部重复节点。可采用双指针分别标识重复节点的起始节点的上一节点和重复节点的结束节点。注意，被标识的重复节点仅仅是当前最靠近链表头部的重复节点区域，其后可能还要其它值的重复节点，需要依次删除每一个重复的节点区域。</p>
<p>如 <code>1-2-2-2-3-3-4-5</code>，先标识出<code>2-2-2</code>并删除，再标识出<code>3-3</code>并删除，最终结果为<code>1-4-5</code>。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = pHead; <span class="comment">// 便于删除头结点</span></span><br><span class="line">    ListNode p = dummyNode; <span class="comment">// p标识重复节点的起始节点的上一节点</span></span><br><span class="line">    ListNode q; <span class="comment">// q标识重复节点的结束节点</span></span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q = p.next;</span><br><span class="line">        <span class="keyword">while</span>(q.next!=<span class="keyword">null</span> &amp;&amp; q.next.val==q.val)&#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=q)&#123;</span><br><span class="line">            <span class="comment">// 有重复结点</span></span><br><span class="line">            p.next = q.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)；</li>
<li>空间复杂度：O(1)。</li>
</ul>
<hr>
<h4 id="面试题22-链表中倒数第k个节点【双指针】"><a href="#面试题22-链表中倒数第k个节点【双指针】" class="headerlink" title="面试题22. 链表中倒数第k个节点【双指针】"></a>面试题22. 链表中倒数第k个节点【双指针】</h4><p>题目：输入一个链表，输出该链表中倒数第k个节点。</p>
<p>思路：双指针，first指针比second指针先走k步；随后一起走，直至first指针为null，返回second指针指向的结点即可。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = head;</span><br><span class="line">        <span class="comment">// first指针先行k步</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=k &amp;&amp; first!=<span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// k已超过链表长度，不合法</span></span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span> &amp;&amp; (i&lt;=k))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// first指针往后直至为null，second指针指向目标结点</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度为：O(N)；</li>
<li>空间复杂度为：O(1)。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>（转）算法复习（一）：常用排序算法与单链表排序</title>
    <url>/2020/03/23/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>复习常用的排序算法，如冒泡排序、选择排序、插入排序、希尔排序、归并排序、堆排序、快速排序等。结合《剑指Offer》、LeetCode和面试题中涉及的单链表排序问题，使用多种排序算法分别实现单链表排序。</p>
<a id="more"></a>

<p>本文主题结构转载自<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a>，代码部分为自行实现。</p>
<blockquote>
<p>原文标题：十大经典排序算法（动图演示）</p>
<p>作者：一像素</p>
<p>原文链接：<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
</blockquote>
<hr>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><h5 id="1-1-常用排序算法分类"><a href="#1-1-常用排序算法分类" class="headerlink" title="1.1 常用排序算法分类"></a>1.1 常用排序算法分类</h5><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<strong>O(N logN)</strong>，因此也称为<strong>非线性时间</strong>比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt></p>
<h5 id="1-2-算法性能总结"><a href="#1-2-算法性能总结" class="headerlink" title="1.2 算法性能总结"></a>1.2 算法性能总结</h5><p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" alt></p>
<blockquote>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p>
<p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p>
</blockquote>
<h5 id="1-3-单链表排序总结"><a href="#1-3-单链表排序总结" class="headerlink" title="1.3 单链表排序总结"></a>1.3 单链表排序总结</h5><ul>
<li>对于冒泡、选择和插入排序，设置<code>tail</code>或<code>start</code>指针，标识<strong>内循环</strong>的终点或起点。</li>
</ul>
<hr>
<h4 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2 算法实现"></a>2 算法实现</h4><h5 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h5><p>重复地遍历数组，每次循环结束，当前最大值会“浮动”至数组尾部（或当前最小值“浮动”至数组头部），称之为冒泡。</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.exch(arr, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h5><p>核心：寻找剩余元素的最小者，并将其放置在数组前端对应位置。</p>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i; <span class="comment">// 当前内循环最小值索引</span></span><br><span class="line">        <span class="comment">// 内循环从i开始，即[0,i-1]区间已有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h5><p><em>算法思想</em></p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，<strong>在已经排序的元素序列中从后向前扫描</strong>。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个元素开始，该元素可以认为已经被排序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; (arr[j] &lt; arr[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：在内循环中，较大的元素向右移动，而不是频繁交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个元素开始，该元素可以认为已经被排序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描。</span></span><br><span class="line">        <span class="comment">// 通过内循环找到temp插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(j=i; j&gt;<span class="number">0</span> &amp;&amp; (temp &lt; arr[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h5><blockquote>
<p>基于插入排序，分为间隔为h的小序列，通过使小序列依次有序从而实现排序。</p>
</blockquote>
<ul>
<li><p>选择一个增量序列h，如1, 4, 13, 40, … 。</p>
</li>
<li><p>按增量序列个数k，对序列进行k趟排序。</p>
</li>
<li><p>每趟排序，根据对应的增量值h，将待排序列分割成若干长度为m的子序列，分别对各子表进行<strong>直接插入排序</strong>。当h=1时，完成排序。</p>
</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; len/<span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 设置间隔h的递增序列为1, 4, 13, 40, ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; (arr[j] &lt; arr[j-h]); j-=h) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-h];</span><br><span class="line">                arr[j-h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-单链表排序"><a href="#3-单链表排序" class="headerlink" title="3. 单链表排序"></a>3. 单链表排序</h4><p><em>单链表的节点结构为</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	ListNode next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-单链表冒泡排序"><a href="#3-1-单链表冒泡排序" class="headerlink" title="3.1 单链表冒泡排序"></a>3.1 单链表冒泡排序</h5><p>使用辅助的<code>tail</code>指针标定每一次内循环的结束位置，且在内循环结束后将其置为前驱节点的索引，直至<code>tail==head</code>时完成排序。</p>
<p>考虑到在最后一定次数的内循环中，数组已经有序。通过<code>count</code>交换次数计数器来判断是否数组是否已有序，以提高算法性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p;</span><br><span class="line">    ListNode tail = <span class="keyword">null</span>; <span class="comment">// 标记内循环的结束位置</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 记录每次内循环时交换元素的次数</span></span><br><span class="line">    <span class="keyword">while</span>(tail!=head) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        p = head; <span class="comment">// 内循环总是从头节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(p.next!=tail) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; p.next.val) &#123;</span><br><span class="line">                temp = p.val;</span><br><span class="line">                p.val = p.next.val;</span><br><span class="line">                p.next.val = temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内循环结束时，p指针位置是</span></span><br><span class="line">        <span class="comment">// 下一轮内循环tail指针的位置</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">// 经过一次内循环，count仍为0，</span></span><br><span class="line">        <span class="comment">// 说明未发生交换，即链表已有序。</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-2-单链表选择排序"><a href="#3-2-单链表选择排序" class="headerlink" title="3.2 单链表选择排序"></a>3.2 单链表选择排序</h5><p>同样使用辅助指针<code>start</code>，只是这次辅助指针标识内循环的起始节点，即<code>head</code>节点和<code>start</code>前驱节点是局部有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p;</span><br><span class="line">    ListNode start = head; <span class="comment">// 内循环起始节点</span></span><br><span class="line">    ListNode minNode; <span class="comment">// 当前内循环最小值节点</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(start.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        minNode = start;</span><br><span class="line">        p = start.next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; minNode.val) &#123;</span><br><span class="line">                minNode = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束内循环，交换元素</span></span><br><span class="line">        temp = start.val;</span><br><span class="line">        start.val = minNode.val;</span><br><span class="line">        minNode.val = temp;</span><br><span class="line">        Utils.printList(head);</span><br><span class="line">        start = start.next; <span class="comment">// 每结束一次内循环，起始节点变为后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-3-单链表插入排序"><a href="#3-3-单链表插入排序" class="headerlink" title="3.3 单链表插入排序"></a>3.3 单链表插入排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head.next; <span class="comment">// 内循环结束节点</span></span><br><span class="line">    ListNode p;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(tail!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        p = head; <span class="comment">// 内循环每次从头节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(p!=tail) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; tail.val) &#123;</span><br><span class="line">                temp = p.val;</span><br><span class="line">                p.val = tail.val;</span><br><span class="line">                tail.val = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-4-单链表希尔排序"><a href="#3-4-单链表希尔排序" class="headerlink" title="3.4 单链表希尔排序"></a>3.4 单链表希尔排序</h5><hr>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41190227/article/details/86600821</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之贪心法</title>
    <url>/2020/03/17/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法，求解问题时总是做出当前最优的选择，即求出局部最优解。通过每一步贪心选择，最终可得到问题的一个整体最优解。</p>
<p><strong>贪心算法不是对所有问题都能得到整体最优解</strong></p>
<p>贪心策略：无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<p><em>基本要素</em></p>
<p><strong>贪心选择</strong>：整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p>
<p>每一次的贪心选择就是将所求问题简化为规模更小的子问题，从顶向下、迭代地做出选择。</p>
<p><strong>最优子结构</strong>：问题的最优解包含子问题的最优解。</p>
<p>与DP不同的是，贪心算法对每个子问题都要作出最优选择，不能回退；动态规划则会依据之前的子问题的结果进行选择，可以回退。</p>
<p>如何实现？</p>
<p>从原问题的某一个初始解出发，逐步逼近给定的目标，直至算法终止。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题集（二）：动态规划问题</title>
    <url>/2020/03/15/LeetCode%E9%A2%98%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>总结在LeetCode刷题过程中遇见的动态规划求解的问题。</p>
<p>有关 DP 的详细介绍见<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五大常用算法之动态规划</a></p>
<a id="more"></a>

<h4 id="最大子序和问题"><a href="#最大子序和问题" class="headerlink" title="最大子序和问题"></a>最大子序和问题</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题-最大子序和</a>。</p>
<p><code>Kadane</code>算法求解最大子序和问题的分析见<a href="https://merlinhu0112.github.io/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/">动态规划和分治法求解最大子序和问题</a>。</p>
<h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：<code>[-2, 1, -3, 4, -1, 2, 1, -5, 4]</code></p>
<p>正确输出结果：<code>6</code></p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        currSum = Math.max((currSum+nums[i]), nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h5><ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">第300题-最长上升子序列</a></p>
<h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>用例：<code>[10, 9, 2, 5, 3, 7, 101, 18]</code></p>
<p>输出：<code>4</code></p>
<h5 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h5><p>用数组 <code>dp</code> 保存以数组 <code>nums</code> 下标 <code>0</code> 为起点、下标 <code>i</code> 为终点的局部区间最长上升子序列的长度，将其称为 <em>局部最长上升子序列长度</em>。</p>
<p>逐个更新 <code>dp</code> 数组。易知，计算 <code>dp[i]</code> 的值，若满足：</p>
<blockquote>
<p>0 &lt;= j &lt; i，且 nums[j] &lt; nums[i]</p>
</blockquote>
<p>即对于局部区间 <code>[0, j]</code>，元素 <code>nums[i]</code> 是满足上升条件的。</p>
<p> 状态转移方程为：</p>
<blockquote>
<p>dp[i] = max{ dp[j] } + 1， 0 &lt;= j &lt; i，且 nums[j] &lt; nums[i]</p>
</blockquote>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// 保存不同索引位置处对应的局部最大上升子序列长度</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>); <span class="comment">// 局部最长上升子序列长默认为1，即假设完全不存在上升序列</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>; <span class="comment">// 全局最长上升子序列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双循环，逐个计算索引i位置处的最大上升子序列长度，最后求出全局最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="comment">// 只有当nums[i]大于nums[j]时，严格满足上升条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对内循环中的赋值语句的理解</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>若写成下式是<strong>错误的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为，索引 <code>j</code> 对应的局部最长上升子序列长度值，不一定是区间 <code>[0, i-1]</code> 中的最大值！</p>
<h5 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul>
<li>时间复杂度：O(N^2) </li>
<li>空间复杂度：O(N)</li>
</ul>
<hr>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">第343题-整数拆分</a>，<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14-I.剪绳子</a>。</p>
<h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：给定一个正整数 <code>n</code>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回可以获得的最大乘积。</p>
<p>条件：2 &lt;= n &lt;= 58 ，且 2 &lt;= m &lt;= n，其中 <code>m</code> 是划分的个数。</p>
<h5 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2. 分析"></a>2. 分析</h5><p>设数组 <code>dp</code> 中的任意元素 dp[i] 保存整数 <code>i</code> 对应的最大乘积，其中 i &gt;= 2。</p>
<p>边界条件为：</p>
<blockquote>
<p>dp[2] = 1</p>
</blockquote>
<p>其中 dp[0] 和 dp[1] 为无效参数，仅起到填充作用，以使 <code>dp</code> 数组的索引 <code>i</code> 与正整数 <code>n</code> 对应。</p>
<p>对于整数 <code>i</code> ，可将其划分为 <code>j</code> 和 <code>i-j</code> ，其中 1&lt;= j &lt; i。</p>
<p><code>j * (i-j)</code> 正是整数 <code>i</code> 拆分、求积的一种形式，但这不一定是最大值。因为对于由 <code>i</code> 划分得到的 <code>j</code> ，它对应的 <code>dp[j]</code> 不一定等于 <code>j</code>，即对整数 <code>j</code> 进一步划分，或许还能得到更大的乘积。</p>
<p>综上，应在 j * ( i - j ) 和 dp[j] * ( i - j ) 中选择较大者。</p>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            dp[i] = Math.max(Math.max((j*(i-j)), (dp[j]*(i-j))), dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-性能-1"><a href="#4-性能-1" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul>
<li>时间复杂度：O(N^2) </li>
<li>空间复杂度：O(N)</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>（转）TCP为什么三次握手而不是两次握手？</title>
    <url>/2020/03/10/%EF%BC%88%E8%BD%AC%EF%BC%89TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<p>TCP连接时需要三次握手，那为什么是三次呢？两次可不可以呢？</p>
<p>在复习TCP连接与断开的知识时，查找资料发现此篇文章写得甚是详细，特意转载而来。</p>
<a id="more"></a>

<blockquote>
<p>原文标题：TCP 为什么三次握手而不是两次握手（正解版）</p>
<p>作者：萧萧冷</p>
<p>版权声明：本文为CSDN博主「萧萧冷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/lengxiao1993/article/details/82771768" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>
</blockquote>
<h4 id="一、大部分网络博客的错误解读"><a href="#一、大部分网络博客的错误解读" class="headerlink" title="一、大部分网络博客的错误解读"></a>一、大部分网络博客的错误解读</h4><p>首先需要声明的是，百度搜索到的大部分网络博客关于这个问题的解答都是不清晰或者不准确的。讨论这个问题的大部分博客都会引用《计算机网络》的内容：</p>
<blockquote>
<p>防止已失效的连接请求又传送到服务器端，因而产生错误。</p>
</blockquote>
<p>不幸的是，这种解释是不准确的。TCP 采用三次握手的原因其实非常简单，远没有大部分博客所描述的那样云山雾绕。</p>
<p><strong>这里先给出结论：</strong></p>
<ul>
<li><p>为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中， 哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。</p>
</li>
<li><p>如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。</p>
</li>
</ul>
<h4 id="二、先修知识"><a href="#二、先修知识" class="headerlink" title="二、先修知识"></a>二、先修知识</h4><p>TCP通信流程</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/1.jpg" alt></p>
<p>上图中的每一个箭头都代表着一次 TCP 数据包的发送。</p>
<p>需要注意的是，上图中出现的 <code>ACK = x +1</code> 的写法很容易让人误以为数据包中的 ACK 域的数据值被填成了 <code>y+1</code>。 <code>ACK = x+1</code> 的实际含义是：</p>
<ul>
<li>TCP 包的 ACK 标志位（1 bit）被置成了 <code>1</code>；</li>
<li>TCP 包的确认号（acknowledgement number ）的值为 <code>x+1</code> 。</li>
</ul>
<p>类似的，TCP 数据包中的 SYN 标志位，也容易与序号（sequence number）混淆，这点需要读者注意。</p>
<p>TCP 数据包结构图</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/2.jpg" alt></p>
<h4 id="三、为什么-TCP-需要握手这个操作"><a href="#三、为什么-TCP-需要握手这个操作" class="headerlink" title="三、为什么 TCP 需要握手这个操作"></a>三、为什么 TCP 需要握手这个操作</h4><p>在解答为什么 TCP 需要三次握手， 而不是两次之前，首先需要回答的问题是:</p>
<blockquote>
<p>为什么需要握手这个操作，能不能不握手？</p>
</blockquote>
<p>如果读者对比一下 UDP 的通信流程和 TCP 的通信流程，可以发现，在 UDP 协议中，是没有握手这个操作的。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/3.jpg" alt></p>
<p>这里就引出了 TCP 与 UDP 的一个基本区别，TCP 是可靠通信协议，而 UDP 是不可靠通信协议。</p>
<ul>
<li>TCP 的可靠性含义：接收方收到的数据是完整、有序、无差错的。</li>
<li>UDP 不可靠性含义：接收方接收到的数据可能存在部分丢失，顺序也不一定能保证。</li>
</ul>
<p>UDP 和 TCP 协议都是基于同样的互联网基础设施，且都基于 IP 协议实现，互联网基础设施中对于数据包的发送过程是会发生丢包现象的，为什么 TCP 就可以实现可靠传输，而 UDP 不行？</p>
<p>TCP 协议为了实现可靠传输，通信双方需要判断自己已经发送的数据包是否都被接收方收到，如果没收到，就需要重发。为了实现这个需求，很自然地就会<strong>引出序号（sequence number）</strong>和 <strong>确认号（acknowledgement number）</strong>的使用。</p>
<p>发送方在发送数据包（假设大小为 10 byte）时，同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后，就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包，序号从 510 开始” 。</p>
<p>这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到，需要重发。</p>
<h4 id="四、为什么需要三次握手，而非两次"><a href="#四、为什么需要三次握手，而非两次" class="headerlink" title="四、为什么需要三次握手，而非两次"></a>四、为什么需要三次握手，而非两次</h4><p>正如上文所描述的，为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始。由于 TCP 是一个双向通信协议，通信双方都有能力发送信息，并接收响应。因此，通信双方都需要随机产生一个初始的序列号，并且把这个起始值告诉对方。</p>
<p>于是，这个过程就变成了下面这样。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/4.jpg" alt></p>
<p>下面这个流程图描述的和上面一样，但是更加清楚的展示了 TCP 数据包标志位，以及数据域的命名来源。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/5.jpg" alt></p>
<p>补充知识：有一位读者关注到了三次握手中，序列号变化的问题，让笔者临时想起了曾经困扰自己的一个问题：</p>
<ul>
<li>为什么三次握手最后一次握手中，在上面的示意图中回复的 <code>seq = x+1</code> 而不是 <code>x+2</code></li>
</ul>
<p>答案：</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/6.jpg" alt></p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/7.jpg" alt></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>Three-way handshake</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题集（一）：O(1)时间复杂度的操作</title>
    <url>/2020/03/09/LeetCode%E9%A2%98%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AO(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>LeetCode刷题过程中遇见“O(1)时间复杂度的操作”系列问题，总结一下。</p>
<a id="more"></a>

<h4 id="一、最大队列"><a href="#一、最大队列" class="headerlink" title="一、最大队列"></a>一、最大队列</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></p>
<h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请定义一个队列并实现函数 max_value 得到队列里的最大值。</p>
<ul>
<li>要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 <code>O(1)</code>。</li>
<li>若队列为空，pop_front 和 max_value 需要返回 -1。</li>
</ul>
<h5 id="2-图解"><a href="#2-图解" class="headerlink" title="2. 图解"></a>2. 图解</h5><p>队列 <code>queue</code> 实现 <code>MaxQueue</code> 的基本结构，双端队列 <code>deque</code> 保存<strong>最大值序列</strong>（降序）。</p>
<p>当元素 <code>ele</code> 入队时，分别进入 <code>queue</code> 和 <code>deque</code>。</p>
<ul>
<li>入 <code>queue</code> 时，元素 <code>ele</code> 直接入队。</li>
<li>入 <code>deque</code> 时，先从队尾开始寻找所有比<code>ele</code> 小的元素，直至遇见首个大于 <code>ele</code> 的元素或已经到了队头。随后从队尾开始，移除所有小于 <code>ele</code> 的元素并将 <code>ele</code> 入队。</li>
</ul>
<p>（图源：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">如何解决 O(1) 复杂度的 API 设计题</a>）</p>
<p><img src="/2020/03/09/LeetCode题集（一）：O(1)时间复杂度的操作/1.gif" alt></p>
<h5 id="3-代码实现："><a href="#3-代码实现：" class="headerlink" title="3. 代码实现："></a>3. 代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 队列queue，实现MaxQueue的基本结构</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">	<span class="comment">// 双端队列（可两端出、入队），用于记录最大值递减序列</span></span><br><span class="line">	<span class="keyword">private</span> Deque&lt;Integer&gt; deque;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">         deque = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> deque.size() &gt; <span class="number">0</span> ? deque.peek() : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	queue.add(value);</span><br><span class="line">    	<span class="keyword">while</span>(deque.size() &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &lt; value ) &#123;</span><br><span class="line">    		<span class="comment">// 移除双端队列后部小于value的元素，直至遇见一个</span></span><br><span class="line">    		<span class="comment">// 大于value的元素或双端队列为空时</span></span><br><span class="line">    		deque.pollLast();</span><br><span class="line">    	&#125;</span><br><span class="line">    	deque.add(value); <span class="comment">// 双端队列队尾入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取队首元素，若队列为空则为-1</span></span><br><span class="line">    	<span class="keyword">int</span> headEle = queue.size() &gt; <span class="number">0</span> ? queue.poll() : -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(deque.size() &gt; <span class="number">0</span> &amp;&amp; deque.peek() == headEle) &#123;</span><br><span class="line">    		deque.poll();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> headEle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二、最小栈"><a href="#二、最小栈" class="headerlink" title="二、最小栈"></a>二、最小栈</h4><p><a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a></p>
<h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为 <code>O(1)</code> 。</p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>类似最大队列的实现。</p>
<p>利用辅助栈保存最小值集合，当前待压栈元素若不小于辅助栈栈顶元素，将该元素压入辅助栈中；否则，辅助栈不变。</p>
<h5 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack; <span class="comment">// 存放元素</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; auxStack; <span class="comment">// 辅助栈，存放最小值序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        auxStack  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="comment">// 辅助栈不为空且栈顶元素小于x时，x不进入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span>(!auxStack.empty() &amp;&amp; auxStack.peek() &lt; x )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，x被压入辅助栈</span></span><br><span class="line">        auxStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小栈栈顶元素等于辅助栈栈顶元素时，说明当前最小值将被弹栈，</span></span><br><span class="line">        <span class="comment">// 因此辅助栈栈顶元素同时弹栈</span></span><br><span class="line">        <span class="keyword">int</span> temp = stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(auxStack.peek()==temp)&#123;</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小栈栈顶元素弹栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!auxStack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> auxStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="三、LRU缓存"><a href="#三、LRU缓存" class="headerlink" title="三、LRU缓存"></a>三、LRU缓存</h4><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">面试题 16.25. LRU缓存</a></p>
<p><strong>LRU缓存</strong>：Least Recently Used，即最近最久未使用的，是一种常见的缓存淘汰算法。当存储的数据总量达到缓存限制时，删除最久未使用过的数据。</p>
<h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值（允许你插入和检索特定键对应的值），并在初始化时指定最大容量。</p>
<p>当缓存被填满时，它应该删除最近最少使用的项目。</p>
<p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>为实现常数时间内 get 和 put 键值对，采用<strong>哈希表</strong>存储，如 HashMap。</p>
<p>在操作键值对的同时，需要额外维护使用键值对的先后顺序，且维护也应在常数时间内完成。<strong>双向链表</strong>是一个不错的选择。</p>
<p>双向链表维护访问先后顺序。其头结点（或尾结点）表示最近最久未使用过的数据。（以尾结点表示最近最久未使用为例）</p>
<ul>
<li>插入新的键值对时，将 <code>key</code> 存入双向链表的头结点，表示最近被使用的数据。</li>
<li>当更新键值对时，将 <code>key</code> 从双向链表相应位置移向头结点。</li>
<li>当缓存已满时，移除双向链表的尾结点并移除散列表中对应的键值对即可。</li>
</ul>
<p>上述三种操作，第一种和第三种均很容易在常数时间内实现，而第二种需要额外的辅助才能实现O(1)的时间复杂度，因为双向链表查找的时间复杂度为O(N)。</p>
<p>Java提供的 <code>java.util.LinkedHashMap</code> 基于 <code>HashMap</code> 和双链表很容易实现LRU缓存。</p>
<h5 id="3-基于LinkedHashMap（有序字典）的实现"><a href="#3-基于LinkedHashMap（有序字典）的实现" class="headerlink" title="3. 基于LinkedHashMap（有序字典）的实现"></a>3. 基于LinkedHashMap（有序字典）的实现</h5><p>Java提供的 LinkedHashMap 类默认按照键值对插入顺序维护双向链表，同时也提供一个特殊的构造函数，以实现按访问顺序维护双向链表。</p>
<ul>
<li>initialCapacity：初始化容量</li>
<li>loadFactor：加载因子</li>
<li>accessOrder：true 表示按访问顺序，false 表示按插入顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 LinkedHashMap 类提供的 removeEldestEntry 方法默认返回 false，因此需要重写该方法，并指定删除最久未使用数据的规则（如当数据量超过缓存容量时）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码实现</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> MAX_CACHE_SIZE; <span class="comment">// 缓存容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    	MAX_CACHE_SIZE = capacity;</span><br><span class="line">        <span class="comment">// 初始容量根据缓存容量和加载因子计算得到，不应设置为等于缓存容量。</span></span><br><span class="line">        <span class="comment">// 若初始容量被设置为缓存容量，易导致rehash操作发生，降低算法性能。</span></span><br><span class="line">    	map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;((<span class="keyword">int</span>) Math.ceil(capacity / <span class="number">0.75f</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line">    		<span class="meta">@Override</span></span><br><span class="line">    		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">    			<span class="keyword">return</span> size() &gt; MAX_CACHE_SIZE;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	Integer value = map.get(key);</span><br><span class="line">    	<span class="keyword">return</span> value == <span class="keyword">null</span> ? -<span class="number">1</span> : value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、基于哈希表和双向链表的实现"><a href="#4、基于哈希表和双向链表的实现" class="headerlink" title="4、基于哈希表和双向链表的实现"></a>4、基于哈希表和双向链表的实现</h5><p>如思路部分所述，可使用双向链表保存访问键值对的顺序信息。</p>
<p>双向链表插入操作的时间复杂度为O(1)，但查询操作的时间复杂度为O(N)。若被访问的键值对对应的链表结点位于链表中部，那么查找操作将时总时间复杂度提升为O(N)。那如何解决这一问题呢？</p>
<p>参照 LinkedHashMap 的源码实现。将键值对保存在链表结点中，哈希表保存 <strong>key 和 结点内存地址</strong>，这样，定位至相应结点的时间复杂度就被优化为O(1)。</p>
<p><em>结点结构如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>哈希表结构如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br></pre></td></tr></table></figure>

<p>（图源：<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">LRU 缓存机制</a>）</p>
<p><img src="/2020/03/09/LeetCode题集（一）：O(1)时间复杂度的操作/2.jpg" alt></p>
<p>头尾指针为辅助指针。</p>
<p><em>算法实现</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 双向链表的结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> key;</span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node prev;</span><br><span class="line">		Node next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Node head; <span class="comment">// 辅助的头指针</span></span><br><span class="line">	<span class="keyword">private</span> Node tail; <span class="comment">// 辅助的尾指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在头部插入结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeadNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		node.prev = head;</span><br><span class="line">		node.next = head.next;</span><br><span class="line">		head.next.prev = node;</span><br><span class="line">		head.next = node;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移除尾结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">removeTailNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node target = tail.prev;</span><br><span class="line">		removeNode(target);</span><br><span class="line">		<span class="comment">// 返回被移除的结点指针，是为了再移除尾结点后，</span></span><br><span class="line">		<span class="comment">// 从哈希表中删除对应的记录。</span></span><br><span class="line">		<span class="keyword">return</span> target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node pNode = node.prev;</span><br><span class="line">		Node qNode = node.next;</span><br><span class="line">		pNode.next = qNode;</span><br><span class="line">		qNode.prev = pNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移动结点至头结点位置</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先移除，再插入</span></span><br><span class="line">		removeNode(node);</span><br><span class="line">		insertHeadNode(node);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 加载因子</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> MAX_CACHE_SIZE; <span class="comment">// 缓存容量;</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.ceil(capacity / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>; <span class="comment">// 哈希表初始容量</span></span><br><span class="line">    	cache = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    	MAX_CACHE_SIZE = capacity;</span><br><span class="line">    	<span class="comment">// 初始化头尾指针</span></span><br><span class="line">    	head = <span class="keyword">new</span> Node();</span><br><span class="line">    	tail = <span class="keyword">new</span> Node();</span><br><span class="line">    	head.next = tail;</span><br><span class="line">    	tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	Node node = cache.get(key);</span><br><span class="line">    	<span class="keyword">if</span>(node==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	moveToHead(node); <span class="comment">// 更新访问记录</span></span><br><span class="line">    	<span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	Node node = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">// 键已存在</span></span><br><span class="line">    	<span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">    		node = cache.get(key);</span><br><span class="line">    		node.value = value;</span><br><span class="line">    		moveToHead(node);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 键不存在</span></span><br><span class="line">    	node = <span class="keyword">new</span> Node();</span><br><span class="line">    	node.key = key;</span><br><span class="line">    	node.value = value;</span><br><span class="line">    	insertHeadNode(node); <span class="comment">// 插入头结点</span></span><br><span class="line">    	cache.put(key, node);</span><br><span class="line">    	<span class="comment">// 还需判断哈希表容量是否已超过缓存容量</span></span><br><span class="line">    	<span class="keyword">if</span>(cache.size() &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">    		Node target = removeTailNode(); <span class="comment">// 移除尾结点</span></span><br><span class="line">    		cache.remove(target.key);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Max Queue</tag>
        <tag>Min Stack</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配之BM、KMP算法</title>
    <url>/2020/03/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBM%E3%80%81KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配算法，给定主串（string）和模式串（pattern），要求返回模式串在主串中首次出现的位置，若无则返回 <code>-1</code> 。比如主串为 <code>abjdefoahs</code> ，模式串为 <code>def</code> ，算法返回结果为 <code>3</code> 。又比如主串为 <code>abjdfeoahs</code>，模式串为 <code>wyz</code> ，算法返回结果为 <code>-1</code> 。</p>
<p>常见的字符串匹配算法有：BF（Brute Force）、RK（Robin-Karp）、<strong>KMP</strong>、BM（Boyer Moore）、Sunday等。</p>
<a id="more"></a>

<h3 id="一、BM算法"><a href="#一、BM算法" class="headerlink" title="一、BM算法"></a>一、BM算法</h3><p>在<a href>字符串匹配之BF、RK算法</a>部分已学习了BF、RK两种算法。</p>
<p>BF算法过于暴力，时间复杂度较高。</p>
<p>RK算法针对BF算法进行了优化，在较好的示例中时间复杂度较好。但RK算法不稳定，当样本哈希冲突严重时，RK算法一路退化至BF算法。</p>
<p>本小节学习的BM算法时间复杂度仅为 <code>O( )</code>，且稳定，常用于文本编辑器中的查找功能。</p>
<p>在BM算法中，有两个非常重要的概念：<strong>坏字符规则</strong> 和 <strong>好后缀规则</strong>。</p>
<h4 id="1-坏字符规则"><a href="#1-坏字符规则" class="headerlink" title="1. 坏字符规则"></a>1. 坏字符规则</h4><p>坏字符规则是指，对于模式串和等长的主串子串，子串从右向左出现的第一个不与模式串对应位置字符匹配的子串字符，称之为坏字符。<strong>根据坏字符在模式串中是否出现，将模式串移动不等距离</strong>。</p>
<p>在第一轮中，从右向左第一个字符 <code>d</code> 就是坏字符。随后在模式串中同样地<strong>从左向右</strong>找到首个字符d。移动模式串不再像BF/RK算法那样单次移动一位，而是直接<strong>将坏字符对齐</strong>。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_1.jpg" alt></p>
<p>第二轮与第一轮相似。对比前两轮可发现，<strong>每轮移动模式串的距离不一定是相等的！</strong>这与坏字符的位置有关。</p>
<p>正是这一特性，有效降低了算法的比较次数，提高了性能。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_2.jpg" alt></p>
<p>第三轮类似。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_3.jpg" alt></p>
<p>第四轮中遇见<strong>模式串中不存在坏字符</strong>的情况，这时直接<strong>将模式串移动至主串子串的坏字符下一位</strong>。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_4.jpg" alt></p>
<p>第五轮类似。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_5.jpg" alt></p>
<p>第六轮，顺利完成匹配。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_6.jpg" alt></p>
<p>坏字符规则代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">boyerMoore</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时，主串和模式串从0至pattern.length-1位一一对应</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 模式串对应主串的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= (m-n)) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找坏字符，其中坏字符位于主串</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(string.charAt(start+i) != pattern.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未找到坏字符，即一一匹配，返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到坏字符，确定模式串移动距离</span></span><br><span class="line">        <span class="keyword">int</span> badCharIndex = findBadCharacter(string.charAt(start+i), pattern, i); <span class="comment">// 模式串中寻找坏字符从i-1开始</span></span><br><span class="line">        <span class="comment">// 计算坏字符产生的位移</span></span><br><span class="line">        <span class="keyword">int</span> offset = badCharIndex &gt;= <span class="number">0</span> ? i-badCharIndex : i+<span class="number">1</span>;</span><br><span class="line">        start += offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> badChar 坏字符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 坏字符索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串中坏字符的位置，不存在则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBadCharacter</span><span class="params">(<span class="keyword">char</span> badChar, String pattern, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>( badChar == (pattern.charAt(i)) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://blog.csdn.net/bjweimengshu/article/details/104368394" target="_blank" rel="noopener">漫画：如何优化 “字符串匹配算法”？</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String Matching</tag>
        <tag>BM</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是深拷贝，什么是浅拷贝？</title>
    <url>/2020/03/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F/</url>
    <content><![CDATA[<p>浅拷贝（shallow copy）与深拷贝（deep copy）有何区别？浅克隆与深克隆又有何区别？Object基类中受保护的（protected）clone( )方法与Cloneable接口又有何联系？</p>
<a id="more"></a>

<h3 id="一、克隆对象"><a href="#一、克隆对象" class="headerlink" title="一、克隆对象"></a>一、克隆对象</h3><h4 id="1-建立副本"><a href="#1-建立副本" class="headerlink" title="1. 建立副本"></a>1. 建立副本</h4><p>在Java中，对于<strong>基本数据类型</strong>的变量，为其建立副本的过程较为简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 基本数据类型之一的int变量</span></span><br><span class="line">b = a; <span class="comment">// 变量b为变量a的副本，值与a相同，b = 1</span></span><br></pre></td></tr></table></figure>

<p>如果为<strong>引用类型</strong>的变量建立副本，会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// get/set方法省略</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"name = "</span> + name + <span class="string">", age = "</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为 People 类实例化一个新对象 <code>aPeople</code>，并将其初始化。为 <code>aPeople</code> 建立副本，为 <code>bPeople</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCloneDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">		aPeople.print();</span><br><span class="line">		People bPeople = aPeople; <span class="comment">// 副本</span></span><br><span class="line">		bPeople.print();</span><br><span class="line">		bPeople.setAge(<span class="number">18</span>); <span class="comment">// 修改</span></span><br><span class="line">		aPeople.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试修改 <code>bPeople</code> ，发现 <code>aPeople</code> 的成员变量也随之发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">aPeople: name = Merlin, age = <span class="number">18</span>; <span class="comment">// age发生变化</span></span><br></pre></td></tr></table></figure>

<p>对象 <code>aPeople</code> 的 <code>age</code> 属性发生变化的原因在于， <code>People bPeople = aPeople</code> 语句是将 <code>aPeople</code> 的<strong>内存地址</strong>赋予 <code>bPeople</code> 。</p>
<p><code>aPeople</code> 和 <code>bPeople</code> <strong>同时指向堆内存中的同一地址</strong>。修改变量 <code>bPeople</code> 引用的对象的属性，会立即被 <code>aPeople</code> 看见。（注：字符串 <code>Merlin</code> 保存在常量池中，在此简化之。）</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/1.jpg" alt></p>
<h4 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="2. Object类的clone方法"></a>2. Object类的clone方法</h4><p>如上所述，为引用类型变量 <code>aPeople</code> 进行复制对象引用并赋值给 <code>bPeople</code> 的操作后，无法单独操作两个对象。</p>
<p>那么，如何在保留一个对象原有状态数据的前提下对新对象进行操作呢？</p>
<p><strong>克隆对象</strong>：用新对象保存当前对象的状态，在克隆的副本上对对象进行操作。这与 <code>new</code> 操作得到一个初始化的新对象是不同的。 </p>
<p>在Java的Object基类中，提供一种受保护的（protected）的<strong>clone()</strong>方法，实现克隆对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>基于JDK 1.8的源码，对clone()方法有如下规定：</p>
<p>一般地，对任意对象，以下三种语句均应返回 <code>true</code>，但都无强制性规定。</p>
<blockquote>
<ul>
<li>x .clone( ) != x ;</li>
<li>x .clone( ) .getClass( ) == x .getClass ;</li>
<li>x .clone( ) .equals(x) ; </li>
</ul>
</blockquote>
<h4 id="3-克隆对象演示"><a href="#3-克隆对象演示" class="headerlink" title="3. 克隆对象演示"></a>3. 克隆对象演示</h4><p>数组已实现 Cloneable 接口，可直接使用 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] cloneArray = array.clone(); <span class="comment">// 数组均实现了Cloneable接口</span></span><br><span class="line">    System.out.println(array); <span class="comment">// 打印原始数组的内存地址</span></span><br><span class="line">    System.out.println(cloneArray); <span class="comment">// 打印克隆数组的内存地址</span></span><br><span class="line">    System.out.println(array==cloneArray);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] bArray = array;</span><br><span class="line">    System.out.println(bArray); <span class="comment">// 打印复制对象引用并赋值给新对象的内存地址</span></span><br><span class="line">    System.out.println(array==bArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为对象 <code>array</code> 复制对象引用并赋值给 <code>bArray</code> ，及克隆对象 <code>array</code> 得到 <code>cloneArray</code> 。</p>
<p>输出结果显示，克隆对象指向<strong>新的内存地址</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>db9742 <span class="comment">// 原始对象内存地址</span></span><br><span class="line"><span class="number">6</span>d06d69c <span class="comment">// 克隆对象内存地址</span></span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">@<span class="number">15</span>db9742 <span class="comment">// 复制对象引用并赋值给新对象</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/2.jpg" alt></p>
<h3 id="二、浅克隆和深克隆"><a href="#二、浅克隆和深克隆" class="headerlink" title="二、浅克隆和深克隆"></a>二、浅克隆和深克隆</h3><blockquote>
<p>浅克隆（浅拷贝）与深克隆（深拷贝）</p>
</blockquote>
<h4 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1. 浅克隆"></a>1. 浅克隆</h4><p>仅支持拷贝<strong>基本数据类型的成员变量</strong>：对基本数据类型的成员变量，复制<strong>值副本</strong>给克隆对象；对引用类型的成员变量，<strong>仅复制内存地址</strong>给克隆对象。</p>
<p><em>浅克隆代码示例</em></p>
<p>基于前述 People 类，必须实现 Cloneable 接口，重写 clone() 方法。注意：</p>
<ul>
<li>提高方法的访问权限，以便包外访问。</li>
<li>调用父类（Object类）的clone方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码同前</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">// 实现标记接口Cloneable，重写Object类的</span></span><br><span class="line">	<span class="comment">// clone方法，提高访问权限，调用父类的clone方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		People people = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改克隆对象 <code>bPeople</code> 的属性，不影响原始对象 <code>aPeople</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    System.out.println(aPeople);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    <span class="comment">// 尝试修改bPeople对象</span></span><br><span class="line">    bPeople.setAge(<span class="number">18</span>); </span><br><span class="line">    bPeople.print();</span><br><span class="line">    System.out.println(bPeople);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">aPeople地址：<span class="number">15</span>db9742</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">18</span>;</span><br><span class="line">bPeople地址：<span class="number">6</span>d06d69c <span class="comment">// 克隆后，地址发生了改变</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，拷贝对象 <code>aPeople</code>（浅克隆）时，在堆内存中新开辟了一块内存空间以存放新的对象，并将克隆对象 <code>bPeople</code> 指向该引用。基本数据类型的属性 <code>age</code> 的值被复制到新的对象中，而引用类型的属性<strong>仅复制内存地址</strong>。</p>
<p>修改 <code>bPeople</code> 对象的属性 <code>age</code> 时，仅修改内存地址为 <code>6d06d69c</code> 的对象，不影响原始对象 <code>aPeople</code>。</p>
<p>在浅克隆时，修改克隆对象引用类型的属性时可能会影响到原始对象。在此例中，String 是不可变对象，属特殊情况。 </p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/3.jpg" alt></p>
<h4 id="2-浅克隆在面对引用变量时面临的问题"><a href="#2-浅克隆在面对引用变量时面临的问题" class="headerlink" title="2. 浅克隆在面对引用变量时面临的问题"></a>2. 浅克隆在面对引用变量时面临的问题</h4><p>如前所示，在浅克隆时，修改克隆对象引用类型的属性（不可变的类型除外）时可能会影响到原始对象。</p>
<p>在 People 类中添加引用类型属性 <code>city</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// get/set，构造方法均略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新 clone() 方法，实现浅克隆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> City city; <span class="comment">// 引用类型的成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		People people = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			people = (People) <span class="keyword">super</span>.clone(); <span class="comment">// 浅克隆</span></span><br><span class="line">		&#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">    <span class="comment">// 修改city变量</span></span><br><span class="line">    city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing; <span class="comment">// 修改bPeople影响了aPeople</span></span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br></pre></td></tr></table></figure>

<p>可见，修改克隆对象 <code>bPeople</code> 的<strong>可变引用类型的成员变量</strong>，影响了原始对象 <code>aPeople</code> 。内存示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/4.jpg" alt></p>
<h4 id="3-深克隆"><a href="#3-深克隆" class="headerlink" title="3. 深克隆"></a>3. 深克隆</h4><p>支持拷贝<strong>基本类型和引用类型的成员变量</strong>：对基本数据类型和引用类型的成员变量，都是复制值副本给克隆对象。</p>
<p>深克隆示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/5.jpg" alt></p>
<p>深克隆与浅克隆的区别在于，对<strong>可变的引用类型的成员变量，深克隆时为其开辟新的内存空间，浅克隆时仅复制内存地址</strong>。</p>
<blockquote>
<p>这里需要注意 name 属性！该属性为 String 类型，是不可变类型。因而克隆对象和原始对象的 name 变量保存的是同一内存地址。</p>
</blockquote>
<p><em>深克隆代码实现</em></p>
<p>对可变的引用类型，也要实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 其余同前</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		City city = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			city = (City) <span class="keyword">super</span>.clone(); <span class="comment">// 浅克隆</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写 People 类的 Clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People people = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">        people.city = (City) city.clone(); <span class="comment">// 深克隆</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心在于：</p>
<blockquote>
<p>people.city = (City) city.clone();</p>
</blockquote>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">    <span class="comment">// 修改city变量</span></span><br><span class="line">    city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai; <span class="comment">// 独立修改</span></span><br></pre></td></tr></table></figure>

<p>修改过程的内存示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/6.jpg" alt></p>
<h4 id="4-浅克隆时String类型的特殊性"><a href="#4-浅克隆时String类型的特殊性" class="headerlink" title="4. 浅克隆时String类型的特殊性"></a>4. 浅克隆时String类型的特殊性</h4><p>String 属于不可变类型，从源码可看出其未实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure>

<p>对于第二章第一小节提及的 People 类，其拥有 <code>name</code> 和 <code>age</code> 两个属性。 <code>name</code> 属性为 String 类型。克隆对象 <code>aPeople</code> 得到 <code>bPeople</code>，在内存中的示意图如下。</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/7.jpg" alt></p>
<p>字符串 <code>Merlin</code> 保存在常量池中，变量 <code>name</code> 保存的是字符串的内存地址。</p>
<p>现在来看看修改 <code>bPeople</code> 的 <code>name</code> 属性会发生什么！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    System.out.println(aPeople);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    bPeople.setName(<span class="string">"hujun"</span>); <span class="comment">// 修改bPeople的name属性</span></span><br><span class="line">    bPeople.print();</span><br><span class="line">    System.out.println(bPeople);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">aPeople地址：<span class="number">15</span>db9742</span><br><span class="line">bPeople: name = hujun, age = <span class="number">25</span>; <span class="comment">// 独立修改了bPeople</span></span><br><span class="line">bPeople地址：<span class="number">6</span>d06d69c</span><br></pre></td></tr></table></figure>

<p><strong>修改克隆对象的 String 类型引用不影响原始对象！！！</strong></p>
<p>前述关于浅/深克隆的差异，核心在于<strong>是否仅复制引用类型变量的内存地址</strong>。String 属于不可变的引用类型，且未实现 Cloneable 接口，因此 String 类型的变量<strong>只允许被复制内存地址</strong>。</p>
<p>当修改克隆对象 <code>bPeople</code> 的 <code>name</code> 属性时，虚拟机会在常量池中另辟地址，保存字符串 <code>hujun</code> ，并将新的内存地址赋予克隆对象 <code>bPeople</code> 的 <code>name</code>  属性。</p>
<p>内存示意图如下。</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/8.jpg" alt></p>
<h3 id="三、两种实现深克隆方式的差异"><a href="#三、两种实现深克隆方式的差异" class="headerlink" title="三、两种实现深克隆方式的差异"></a>三、两种实现深克隆方式的差异</h3><h4 id="1-clone方法"><a href="#1-clone方法" class="headerlink" title="1. clone方法"></a>1. clone方法</h4><p>实现Cloneable接口，重写Object类的clone()方法，并适当提高重写的clone()方法的访问权限</p>
<p><strong>问题：</strong>如上代码所示，在 People 类中存在引用类型 <code>City</code>，因此在实现深克隆时，首先需要对City类实现浅克隆，随后再实现深克隆。<strong>克隆过程是嵌套的</strong>。</p>
<p>对于多层嵌套的引用类型，这一方法显然很麻烦。</p>
<p>采用序列化可简化深度克隆过程。</p>
<h4 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h4><p>City 类实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 删除clone()方法，其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>People 类实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 删除clone()方法，其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        People bPeople = MyCloneUtil.deepClone(aPeople);</span><br><span class="line">        aPeople.print();</span><br><span class="line">        bPeople.print();</span><br><span class="line">        <span class="comment">// 修改city变量</span></span><br><span class="line">        city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">        aPeople.print();</span><br><span class="line">        bPeople.print();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br></pre></td></tr></table></figure>

<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>1、为什么要实现克隆？</p>
<p>想对一个对象进行处理，又想保留原有的状态数据进行接下来的操作，这就需要克隆。</p>
<p>Java语言中克隆针对的是类的实例。</p>
<p>2、浅克隆与深克隆的区别？</p>
<p>浅克隆：对基本数据类型的成员变量，复制值副本给克隆对象；对引用类型的成员变量，仅复制内存地址给克隆对象。</p>
<p>深克隆：对基本数据类型和引用类型的成员变量，都是复制值副本给克隆对象。</p>
<p>3、浅克隆时，若引用类型为不可变类型，浅克隆过程也是安全的！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Clone</tag>
        <tag>Shallow Copy</tag>
        <tag>Deep Copy</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配之BF、RK算法</title>
    <url>/2020/03/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E3%80%81RK%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配算法，给定主串（string）和模式串（pattern），要求返回模式串在主串中首次出现的位置，若无则返回 <code>-1</code> 。比如主串为 <code>abjdefoahs</code> ，模式串为 <code>def</code> ，算法返回结果为 <code>3</code> 。又比如主串为 <code>abjdfeoahs</code>，模式串为 <code>wyz</code> ，算法返回结果为 <code>-1</code> 。</p>
<p>常见的字符串匹配算法有：BF（Brute Force）、RK（Robin-Karp）、<strong>KMP</strong>、BM（Boyer Moore）、Sunday等。</p>
<a id="more"></a>

<h3 id="一、BF算法"><a href="#一、BF算法" class="headerlink" title="一、BF算法"></a>一、BF算法</h3><p>遇到任何困难，都不要怕，先试试暴力法！</p>
<h4 id="1-BF算法流程："><a href="#1-BF算法流程：" class="headerlink" title="1. BF算法流程："></a>1. BF算法流程：</h4><p>在前三轮中，模式串首位字符与主串对应位置字符不匹配，将模式串“向右移动一位”。在第四轮匹配中，模式串的首位字符与主串对应位置的字符匹配，则继续比较第二位，直到完成全部匹配。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/BF_Algorithm.jpg" alt></p>
<h4 id="2-BF算法实现："><a href="#2-BF算法实现：" class="headerlink" title="2. BF算法实现："></a>2. BF算法实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bruteForce</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=((string.length())-(pattern.length())); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(string.charAt(i+j) != pattern.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-BF算法的性能"><a href="#3-BF算法的性能" class="headerlink" title="3. BF算法的性能"></a>3. BF算法的性能</h4><p>BF算法不需要前期预处理，它的时间复杂度取决于内外循环，为 <code>O ( ( m - n + 1 ) * n ) = O ( m * n )</code> 。其中， <code>m</code> 为主串长度， <code>n</code> 为 模式串长度。</p>
<hr>
<h3 id="二、RK算法"><a href="#二、RK算法" class="headerlink" title="二、RK算法"></a>二、RK算法</h3><p>BF算法在最坏情况下，外层循环执行 <code>m - n + 1</code> 次，内层循环执行 <code>n</code> 次。RK（Robin-Karp）算法利用字符串本身，通过<strong>比较字符串哈希值</strong> 和 <strong>逐位字符匹配</strong> 相结合的方式，提高算法性能。</p>
<h4 id="1-RK算法流程"><a href="#1-RK算法流程" class="headerlink" title="1. RK算法流程"></a>1. RK算法流程</h4><h5 id="1-1-计算模式串哈希值以及首次计算部分主串哈希值"><a href="#1-1-计算模式串哈希值以及首次计算部分主串哈希值" class="headerlink" title="1.1 计算模式串哈希值以及首次计算部分主串哈希值"></a>1.1 计算模式串哈希值以及首次计算部分主串哈希值</h5><p>计算长度为 <code>n</code> 的模式串的哈希值。</p>
<p>截取主串 <code>[0, n-1]</code> 段，<strong>首次</strong>计算部分主串哈希值</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_1.jpg" alt></p>
<p>那么如何计算哈希值呢？</p>
<p>（1）按位相加</p>
<p>按位相加意指将字符串 <code>a - z</code> 视为 <code>0 - 25</code> ，取每一位字符的”和”。</p>
<p>示例如图：</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_2.jpg" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashcode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里采用最简单的哈希值计算方式：</span></span><br><span class="line">    <span class="comment">// 把a当做0，把b当中1，把c当中2.....然后按位相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        hashcode += str.charAt(i)-<span class="string">'a'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）转换成二十六进制</p>
<p>转换成二十六进制是指将字符串 <code>a - z</code> 视为 <code>0 - 25</code> ，且将每一位字符当成二十六进制数来计算。</p>
<p>示例如图：</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_3.jpg" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = <span class="number">26</span>;</span><br><span class="line"><span class="comment">// 用计算得到的哈希值对q取模，防止哈希值溢出</span></span><br><span class="line"><span class="comment">// q为满足(q*d &lt; MAX_INT)的随机素数</span></span><br><span class="line"><span class="keyword">int</span> q = <span class="number">144451</span>;</span><br><span class="line"><span class="comment">// h标记字符串高位字符的基数</span></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 主串的初始哈希值</span></span><br><span class="line"><span class="keyword">int</span> strCode = string.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 模式串的初始哈希值</span></span><br><span class="line"><span class="keyword">int</span> patternCode = pattern.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    strCode = (strCode * d + string.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">    patternCode = (patternCode * d + pattern.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">    h = (h * d) % q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，为防止哈希值溢出，需要对其取模。</p>
<h5 id="1-2-比较哈希值"><a href="#1-2-比较哈希值" class="headerlink" title="1.2 比较哈希值"></a>1.2 比较哈希值</h5><p>对每一轮计算得到的哈希值进行比较。</p>
<ul>
<li><p>哈希值不等，模式串“向右移动一位“，重新计算主串部分的哈希值，模式串不变。</p>
</li>
<li><p>哈希值相等，进入逐位匹配。</p>
</li>
</ul>
<h5 id="1-3-移动主串，重新计算主串部分哈希值"><a href="#1-3-移动主串，重新计算主串部分哈希值" class="headerlink" title="1.3 移动主串，重新计算主串部分哈希值"></a>1.3 移动主串，重新计算主串部分哈希值</h5><p>显然，第一轮两种哈希值计算方法得到的结果均不等，需要重新计算主串部分的哈希值。</p>
<p>在首次计算哈希值过程中，循环语句执行 <code>n</code> 次，即计算哈希值的算法时间复杂度为 <code>O (n)</code>。如果在<strong>重新计算主串部分的哈希值</strong>过程中<strong>完全重新</strong>计算，时间复杂度仍为 <code>O(n)</code>。</p>
<p>将模式串移动一位，<strong>主串部分</strong>去除首位元素并添加末位元素，中间部分并未改变。中间部分的哈希值保存在上一次计算结果当中。故，若是能利用上一次的哈希值计算本次哈希值，则<strong>将时间复杂度优化为</strong> <code>O(1)</code>。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_4.jpg" alt></p>
<p>（1）按位相加</p>
<p>按位相加计算哈希值的算法，其重新计算哈希值的过程较为简单：减去当前主串部分首位字符的值，再加上下一位待添加字符的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextHash</span><span class="params">(String string, <span class="keyword">int</span> hashCode, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    hashCode -= string.charAt(index)-<span class="string">'a'</span>; <span class="comment">// 减去当前主串部分首位字符的值</span></span><br><span class="line">    hashCode += string.charAt(index+n)-<span class="string">'a'</span>; <span class="comment">// 加上下一位待添加字符的值</span></span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）二十六进制算法</p>
<p>按位相加计算哈希值的算法，其重新计算哈希值的过程稍复杂。变量 <code>h</code> 记录了字符串首位字符的基数，重新计算时，将其乘以首位字符的值，得到的是首位字符的哈希值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新主串从i到i+n的哈希值</span></span><br><span class="line">strCode = ((strCode - h*(string.charAt(i)-<span class="string">'a'</span>))*d + (string.charAt(i+n)-<span class="string">'a'</span>)) % q;</span><br><span class="line"><span class="keyword">if</span>(strCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    strCode += q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-逐位匹配"><a href="#1-4-逐位匹配" class="headerlink" title="1.4 逐位匹配"></a>1.4 逐位匹配</h5><p>两个字符串的哈希值相同，并不意味着字符串一定相同，这是<strong>哈希冲突</strong>。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_5.jpg" alt></p>
<p>当字符串的哈希值相同时，仍需要进一步逐位匹配字符。</p>
<ul>
<li>哈希值相同的两个字符串，逐位匹配成功，则返回结果。</li>
<li>否则，重新计算哈希值（步骤1.3）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因存在哈希冲突，当哈希值相同时，仍需要额外逐位比对字符串</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_6.jpg" alt></p>
<h4 id="2-RK算法的完整实现"><a href="#2-RK算法的完整实现" class="headerlink" title="2. RK算法的完整实现"></a>2. RK算法的完整实现</h4><h5 id="2-1-按位相加"><a href="#2-1-按位相加" class="headerlink" title="2.1 按位相加"></a>2.1 按位相加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robinKarp</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="comment">// 模式串的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">    <span class="comment">// 计算模式串的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> patternCode = firstHash(pattern);</span><br><span class="line">    <span class="comment">// 计算主串当中第一个和模式串等长的子串哈希值</span></span><br><span class="line">    <span class="keyword">int</span> strCode = firstHash(string.substring(<span class="number">0</span>, n));</span><br><span class="line">    <span class="comment">// 用模式串的哈希值和主串的局部哈希值比较。</span></span><br><span class="line">    <span class="comment">// 如果匹配，则进行精确比较；如果不匹配，计算主串中相邻子串的哈希值。</span></span><br><span class="line">    <span class="comment">// 外层循环的最大循环次数为 m-n+1。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m-n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strCode == patternCode &amp;&amp; compareString(i, string, pattern))&#123;</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是最后一轮，更新主串从i到i+n的哈希值</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;m-n)&#123;</span><br><span class="line">            strCode = nextHash(string, strCode, i, n); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashcode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里采用最简单的哈希值计算方式：</span></span><br><span class="line">    <span class="comment">// 把a当做0，把b当中1，把c当中2.....然后按位相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        hashcode += str.charAt(i)-<span class="string">'a'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHash</span><span class="params">(String string, <span class="keyword">int</span> hashCode, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    hashCode -= string.charAt(index)-<span class="string">'a'</span>; </span><br><span class="line">    hashCode += string.charAt(index+n)-<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因存在哈希冲突，当哈希值相同时，仍需要额外逐位比对字符串</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-二十六进制法"><a href="#2-2-二十六进制法" class="headerlink" title="2.2 二十六进制法"></a>2.2 二十六进制法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">improvedRobinKarp</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="comment">// 模式串的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">    <span class="comment">// 26个字母，二十六进制</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">26</span>;</span><br><span class="line">    <span class="comment">// 用计算得到的哈希值对q取模，防止哈希值溢出</span></span><br><span class="line">    <span class="comment">// q为满足(q*d &lt; MAX_INT)的随机素数</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">144451</span>;</span><br><span class="line">    <span class="comment">// h标记字符串高位字符的基数</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主串的初始哈希值</span></span><br><span class="line">    <span class="keyword">int</span> strCode = string.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">// 模式串的初始哈希值</span></span><br><span class="line">    <span class="keyword">int</span> patternCode = pattern.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        strCode = (strCode * d + string.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">        patternCode = (patternCode * d + pattern.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">        h = (h * d) % q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用模式串的哈希值和主串的局部哈希值比较。</span></span><br><span class="line">    <span class="comment">// 如果匹配，则进行精确比较；如果不匹配，计算主串中相邻子串的哈希值。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m-n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strCode == patternCode &amp;&amp; compareString(i, string, pattern))&#123;</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m-n) &#123;</span><br><span class="line">            <span class="comment">// 更新主串从i到i+n的哈希值</span></span><br><span class="line">            strCode = ((strCode - h*(string.charAt(i)-<span class="string">'a'</span>))*d + (string.charAt(i+n)-<span class="string">'a'</span>)) % q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            strCode += q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-RK算法的性能"><a href="#3-RK算法的性能" class="headerlink" title="3. RK算法的性能"></a>3. RK算法的性能</h4><p>RK算法首次计算哈希值过程可视为预处理，其时间复杂度为 <code>O(n)</code>。优化后的重新计算哈希值的算法，其时间复杂度为 <code>O(1)</code>。</p>
<p>模式串的哈希值和主串的局部哈希值比较过程，在较好的情况下（即哈希冲突少），最大循环次数为 <code>m - n + 1</code>，故其时间复杂度为 <code>O( m - n + 1 )</code>。</p>
<p>综上，RK算法在<strong>较好的情况下</strong>，时间复杂度为 <code>O(m)</code>。</p>
<p>当然，RK算法也有不足。<strong>当哈希冲突频繁时</strong>，算法性能会下降（即RK算法性能不稳定），<strong>严重时RK算法会退化成BF算法。</strong></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://blog.csdn.net/bjweimengshu/article/details/103966767" target="_blank" rel="noopener">漫画：什么是字符串匹配算法？</a></p>
<p>[2] <a href="https://blog.csdn.net/tyler_download/article/details/52457108?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">面试算法之字符串匹配算法，Rabin-Karp算法详解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String Matching</tag>
        <tag>BM</tag>
        <tag>KMP</tag>
        <tag>BF</tag>
        <tag>RK</tag>
      </tags>
  </entry>
  <entry>
    <title>xmall项目源码学习</title>
    <url>/2020/03/01/xmall%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>通过阅读GitHub上开源的<a href="https://github.com/Exrick/xmall" target="_blank" rel="noopener">xmall项目</a>深入学习分布式项目，初步了解Spring Boot框架及多种中间件的使用、原理。</p>
<a id="more"></a>

<h3 id="一、前期配置学习"><a href="#一、前期配置学习" class="headerlink" title="一、前期配置学习"></a>一、前期配置学习</h3><h4 id="1-ZooKeeper"><a href="#1-ZooKeeper" class="headerlink" title="1. ZooKeeper"></a>1. ZooKeeper</h4><h5 id="1-1-ZooKeeper概述"><a href="#1-1-ZooKeeper概述" class="headerlink" title="1.1 ZooKeeper概述"></a>1.1 ZooKeeper概述</h5><p>ZooKpeeper用于分布式应用程序的高性能协调服务。（“ZooKeeper is a high-performance coordination service for distributed applications.”）</p>
<p>ZooKeeper可提供用于命名，配置管理，同步和组服务等高级别的服务，目的在于减轻分布式应用程序从头开始实施协调服务的责任。</p>
<p><em>ZooKeeper服务如下图</em></p>
<p><img src="/2020/03/01/xmall项目源码学习/zookeeper_service.jpg" alt></p>
<p>ZooKeeper允许分布式进程通过共享的<strong>层次命名空间</strong>相互协调。ZooKeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。将ZooKeeper数据节点称为<strong>znode</strong>。</p>
<p><em>ZooKeeper的层次命名空间</em></p>
<p><img src="/2020/03/01/xmall项目源码学习/zookeeper_namespace.jpg" alt></p>
<h5 id="1-2-ZooKeeper的特点"><a href="#1-2-ZooKeeper的特点" class="headerlink" title="1.2 ZooKeeper的特点"></a>1.2 ZooKeeper的特点</h5><ol>
<li>ZooKeeper数据保存在内存中，因此具备高吞吐量和低延迟。</li>
<li>ZooKeeper的所有服务器维护内存中的状态图像，以及持久存储事务日志和数据库快照。</li>
<li>只要大多数服务器可用，ZooKeeper服务将正常服务。</li>
<li>标记每一次更新，可用于实现同步。</li>
<li>在“读取为主”的工作负载中，ZooKeeper非常快。</li>
</ol>
<h5 id="1-3-ZooKeeper的配置及运行"><a href="#1-3-ZooKeeper的配置及运行" class="headerlink" title="1.3 ZooKeeper的配置及运行"></a>1.3 ZooKeeper的配置及运行</h5><p>（1）从<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">ZooKeeper官网</a>下载压缩包 <code>apache-zookeeper-3.5.7-bin.tar.gz</code> ，解压至本地文件夹。</p>
<p>（2）解压后有两个文件夹：<code>apache-zookeeper-3.5.7-bin</code> 和 <code>PaxHeaders.X</code> ，前者的 <code>conf</code> 和 <code>bin</code> 文件夹较为重要。</p>
<p>（3）将 apache-zookeeper-3.5.7-bin\conf\ 目录下的 <code>zoo_sample.cfg</code> 文件重命名为 <code>zoo.cfg</code> ，并修改配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># 用作&quot;心跳&quot;，且最小会话超时为tickTime的两倍</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 内存数据库快照</span><br><span class="line">dataDir=D:\\...(模糊化处理)\\Zookeeper\\dataDir</span><br><span class="line"># 日志文件目录</span><br><span class="line">dataLogDir=D:\\...(模糊化处理)\\Zookeeper\\dataLogDir</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 用于侦听客户端连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure>

<p>注意：<code>dataDir</code> 和 <code>dataLogDir</code> 两项，地址中分隔符应为 <code>\\</code> 而不是 <code>\</code> ，后者在ZooKeeper运行时将在 apache-zookeeper-3.5.7-bin\bin\ 目录下生成文件夹存放日志文件和快照，而不是在指定位置。</p>
<h4 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a>2. Redis</h4><h5 id="2-1-Redis概述"><a href="#2-1-Redis概述" class="headerlink" title="2.1 Redis概述"></a>2.1 Redis概述</h5><p>Redis是用C语言编写的、基于<strong>内存数据集（in-memory dataset）</strong>的内存数据存储结构，可用来实现<strong>数据库</strong>、<strong>缓存</strong>（cache）和<strong>消息代理</strong>（message broker）。</p>
<p>Redis是<strong>键值存储</strong>的形式，支持常见的字符串，哈希，列表（list），集合（set）、有序集合、位图和超日志等。</p>
<p>Redis具备：</p>
<ul>
<li>事务。</li>
<li>不同级别的磁盘持久化（on-disk persistence），可一次全部持久化，也可以通过将每个命令附加到log来持久化它，还可以选择禁用持久化（用于网络内存缓存）。</li>
<li>通过<strong>哨兵</strong>（Redis Sentinel）和 Redis Cluster自动分区提供高可用性。</li>
<li>对数据进行原子操作（如 <em>INCR</em> 命令），如追加到字符串，在哈希中增加值，将元素推送到列表等。</li>
</ul>
<h5 id="2-2-在Windows环境下安装、测试Redis"><a href="#2-2-在Windows环境下安装、测试Redis" class="headerlink" title="2.2 在Windows环境下安装、测试Redis"></a>2.2 在Windows环境下安装、测试Redis</h5><p>（1）<a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">下载Redis</a>，解压到本地目录。</p>
<ul>
<li>redis-server.exe：Redis服务器</li>
<li>redis-cli.exe：Redis客户端</li>
<li>redis-check-aof.exe：更新日志检查</li>
<li>redis-benchmark.exe：性能测试，模拟N个客户端同时发送M个set/get查询</li>
</ul>
<p>（2）命令行窗口，输入 <code>redis-server.exe redis.windows.conf</code> 以启动Redis服务器。此窗口保持常开。</p>
<p>（3）另开命令行窗口，输入 <code>redis-cli.exe -h 127.0.0.1 -p 6379</code>，客户端连接服务器，其中 Redis服务器监听 <strong>6379 端口</strong>。</p>
<p>（4）测试</p>
<ul>
<li><p>设置键值对： <code>set testKey 1</code></p>
</li>
<li><p>取出键值对： <code>get testKey</code></p>
</li>
<li><p>删除键值对： <code>del testKey</code></p>
</li>
</ul>
<p><img src="/2020/03/01/xmall项目源码学习/redis_cli_test.jpg" alt></p>
<p>删除键值对后，返回 <code>1</code> 说明删除成功，返回 <code>0</code> 说明删除失败。</p>
<h4 id="3-ActiveMQ"><a href="#3-ActiveMQ" class="headerlink" title="3. ActiveMQ"></a>3. ActiveMQ</h4><h5 id="3-1-ActiveMQ概述"><a href="#3-1-ActiveMQ概述" class="headerlink" title="3.1 ActiveMQ概述"></a>3.1 ActiveMQ概述</h5><p>ActiveMQ 是一种基于 Java 消息服务（Java Message Service）的消息中间件。</p>
<p>在<strong>高并发</strong>的条件下，由于来不及同步处理，请求往往会发生阻塞。例如大量的 update 请求同时到达 MySQL 服务器，造成请求大量堆积。通过使用 ActiveMQ，<strong>异步处理已到达的请求</strong>，缓解服务器压力。</p>
<p>（图源：<a href="https://www.cnblogs.com/xiguadadage/p/11217604.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xiguadadage/p/11217604.html）</a></p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_1.png" alt></p>
<p>如上图所示，通过 ActiveMQ 保存开锁指令，随后异步执行耗时的开锁操作，以减轻服务器的压力。</p>
<h5 id="3-2-ActiveMQ消息类型"><a href="#3-2-ActiveMQ消息类型" class="headerlink" title="3.2 ActiveMQ消息类型"></a>3.2 ActiveMQ消息类型</h5><p>JMS 消息通常有两种类型，ActiveMQ 是基于 JMS 的，所以介绍 ActiveMQ 的两种消息类型：<strong>点对点</strong>（Point-to-Point）和<strong>发布/订阅</strong>（Publish/Subscribe）。</p>
<p>（1）点对点</p>
<p>生产者与消费者点对点发送消息，借助队列（javax.jms.Queue）存储消息。</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_2.png" alt></p>
<p>点对点类型的要点：</p>
<ul>
<li>每个消息只有一个消费者 <code>Consumer</code> ，一旦被消费，消息就不再在队列中。</li>
<li>生产者 <code>Producer</code> 发送消息不受消费者状态的影响。（无依赖性）</li>
<li>消费者在成功接收消息后，需要向队列应答成功。</li>
</ul>
<p>（2）发布/订阅</p>
<p>生产者发布事件，不同的消费者订阅并使用感兴趣的事件。此类型一般与特定的主题（javax.jms.Topic）关联。</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_3.png" alt></p>
<p>发布/订阅类型的要点：</p>
<ul>
<li>每个消息可以有<strong>多个消费者</strong>。</li>
<li>针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。（有依赖性）</li>
<li>为了消费消息，订阅者必须<strong>保持运行</strong>的状态。</li>
</ul>
<h5 id="3-3-ActiveMQ的使用"><a href="#3-3-ActiveMQ的使用" class="headerlink" title="3.3 ActiveMQ的使用"></a>3.3 ActiveMQ的使用</h5><p>下载并解压至本地，免安装。在bin目录下执行 activemq.bat start。</p>
<p>在浏览器中输入<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a> 可访问控制台，账户/密码为 admin/admin。</p>
<p>接下来测试 ActiveMQ 应用于简单的 Java 程序中。</p>
<p>（1）Maven中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageProducer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerURL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建连接工厂</span></span><br><span class="line">		ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(brokerURL);</span><br><span class="line">		<span class="comment">// 建立连接</span></span><br><span class="line">		Connection conn = factory.createConnection();</span><br><span class="line">		conn.start();</span><br><span class="line">		<span class="comment">// 创建会话</span></span><br><span class="line">		Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">		<span class="comment">// 创建队列目标，并标识队列名称，消费者将依据队列名称接收数据</span></span><br><span class="line">		Destination dest = session.createQueue(<span class="string">"TestQueue"</span>);</span><br><span class="line">		<span class="comment">// 创建生产者</span></span><br><span class="line">		MessageProducer producer = session.createProducer(dest);</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">			TextMessage message = session.createTextMessage(<span class="string">"第"</span>+i+<span class="string">"条消息"</span>);</span><br><span class="line">			producer.send(message);</span><br><span class="line">			System.out.println(message.getText());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭连接</span></span><br><span class="line">		conn.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生产者之前，控制台如下：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_4.jpg" alt></p>
<p>运行生产者，发送5条消息，控制台发生了变化：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_5.jpg" alt></p>
<p>如图，队列中等待的消息 <code>Pending Message</code> 有5条，当前无消费者。</p>
<p>（3）消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageConsumer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerURL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建连接工厂</span></span><br><span class="line">		ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(brokerURL);</span><br><span class="line">		<span class="comment">// 建立连接</span></span><br><span class="line">		Connection conn = factory.createConnection();</span><br><span class="line">		conn.start();</span><br><span class="line">		<span class="comment">// 创建会话</span></span><br><span class="line">		Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">		<span class="comment">// 创建队列目标，并标识队列名称，消费者将依据队列名称接收数据</span></span><br><span class="line">		Destination dest = session.createQueue(<span class="string">"TestQueue"</span>);</span><br><span class="line">		<span class="comment">// 创建消费者</span></span><br><span class="line">		MessageConsumer consumer = session.createConsumer(dest);</span><br><span class="line">		<span class="comment">// 消费者监听</span></span><br><span class="line">		consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">				TextMessage textMessage = (TextMessage) message;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(textMessage.getText());</span><br><span class="line">				&#125;<span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者启动后，控制台又发生了变化：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_6.jpg" alt></p>
<p>显示此时有1个消费者，刚入队的5条消息均已出队，当前队列中无消息。</p>
<p>注意创建会话的方法，其中有两个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建会话</span></span><br><span class="line">Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>

<ol>
<li>false: 表示 <em>不使用事务</em> 。事务：生产者在发送消息后等待消息代理的确认，没有回应则抛出异常，并由生产者负责处理。</li>
<li><em>确认模式</em> ：<ul>
<li><code>AUTO_ACKNOWLEDGE</code>：指定消息接收者在每次收到消息时自动发送确认。消息只向目标发送一次，但传输过程中可能因为错误而丢失消息。</li>
<li><code>CLIENT_ACKNOWLEDGE</code>：由消息接收者确认收到消息，通过调用消息的 <code>acknowledge()</code> 方法（会通知消息提供者收到了消息）。</li>
<li><code>DUPS_OK_ACKNOWLEDGE</code>：指定消息提供者在消息接收者没有确认发送时重新发送消息（这种确认模式不在乎接收者收到重复的消息）。</li>
</ul>
</li>
</ol>
<h5 id="3-4-ActiveMQ进阶之多种MQ简要比较"><a href="#3-4-ActiveMQ进阶之多种MQ简要比较" class="headerlink" title="3.4 ActiveMQ进阶之多种MQ简要比较"></a>3.4 ActiveMQ进阶之多种MQ简要比较</h5><ul>
<li>ActiveMQ 适用于解耦和异步操作，简单易用，对队列数较多的情况支持不好。</li>
<li>RabbitMQ，erlang开发，性能较稳定，社区活跃度高，但是不利于做二次开发和维护。</li>
<li>RocketMQ 支持海量消息，但未实现 JMS 规范。</li>
<li>Kafka 适用于大数据领域、日志采集等场景。</li>
</ul>
<h5 id="3-5-ActiveMQ进阶之持久化"><a href="#3-5-ActiveMQ进阶之持久化" class="headerlink" title="3.5 ActiveMQ进阶之持久化"></a>3.5 ActiveMQ进阶之持久化</h5><p>为避免意外丢失数据，也为重启时可恢复至重启前的正常状态，ActiveMQ 需要实现持久化。</p>
<p>ActiveMQ的消息持久化机制有 <strong>JDBC，AMQ，KahaDB</strong> 和 <strong>LevelDB</strong>。</p>
<p><strong>持久化原理</strong>：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，然后试图将消息发送给接收者，发送成功则将消息从存储中删除，失败则继续尝试。</p>
<p>消息中心启动以后首先要检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>
<p>（1）JDBC</p>
<p>数据库会创建3个表：<code>activemq_msgs</code>，<code>activemq_acks</code> 和 <code>activemq_lock</code>。</p>
<p><code>activemq_msgs</code>用于存储消息，<code>Queue</code> 和 <code>Topic</code> 都存储在这个表中。</p>
<p>（2）AMQ</p>
<ul>
<li>以顺序追加的方式将消息写入日志文件。</li>
<li>创建消息主键索引，且提供缓存。综上，AMQ 性能优于 JDBC。</li>
</ul>
<p>AMQ 的缺点：</p>
<ul>
<li>重建索引时间长，且索引文件占用磁盘空间较大。</li>
</ul>
<p>（3）KahaDB（默认）</p>
<p>从 ActiveMQ 5.4 开始成为默认的持久化插件。</p>
<ul>
<li>基于日志文件，支持索引和缓存。</li>
<li>使用更少的数据文件，恢复时间远小于 AMQ。</li>
</ul>
<p>（4）LevelDB</p>
<p>5.6 版本推出的持久化引擎，性能高于 KahaDB。可见这几种持久化方式中，LevelDB 性能最好。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.jianshu.com/p/cd8e037e11ff" target="_blank" rel="noopener">消息中间件之ActiveMQ</a></p>
<p>[2] <a href="https://www.cnblogs.com/xiguadadage/p/11217604.html" target="_blank" rel="noopener">浅谈ActiveMQ与使用</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>xmall</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之分治法</title>
    <url>/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>是一种十分重要的算法思想，其精髓是”分而治之”，即把复杂的问题分解成数个小规模的、形式相同的子问题，再逐个”击破”子问题，最后合并所有子问题的解以解决原问题。诸如快速排序、归并排序、快速傅里叶变换等算法均是分治法思想的重要体现。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>分治法（Divide and Conquer）与<strong>动态规划</strong>类似，二者最大的区别在于：适用于分治法求解的问题，经分解后得到的<strong>子问题往往是相互独立的</strong>。</p>
<p>分治法可解决的问题，应具备如下特征：</p>
<p>（1）问题的规模缩小后，更容易解决。</p>
<p>（2）该问题可分解为若干个小规模的、形式相同的问题，即该问题具有最优子结构性质。这体现了<strong>递归思想</strong>在分治法中的应用。</p>
<p><strong>（3）利用该问题分解出的子问题的解能够合并为该问题的解。</strong>这决定了某一问题是否适用于分治法。不符时应考虑贪心法或<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>。</p>
<p>（4）子问题是相互独立的。子问题若不独立，应考虑<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>。</p>
<h4 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h4><p>二分查找是分治思想的重要且常用的实现算法之一。</p>
<p>二分查找的基本思路是：将目标对象（一般为数组）一分为二，递归地进入子对象继续进行二分查找，直至子问题可以很容易被解决。其核心代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">    mid = (hi+lo)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 最小规模的子问题，直接返回子问题的结果</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">        hi = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、最大子序和问题"><a href="#三、最大子序和问题" class="headerlink" title="三、最大子序和问题"></a>三、最大子序和问题</h4><p>最大子序和问题是一道经典的算法题，可参见LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>。</p>
<p>问题描述：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<p>在<a href="https://merlinhu0112.github.io/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/">动态规划和分治法求解最大子序和问题</a>一文中，采用动态规划法解决了此问题。如何用分治法解决此问题呢？</p>
<p>分治法的核心在于如何将目标数组划分为若干个子数组并分别求出子数组的最大子序和。容易想到，将数组沿 <code>(left+right)/2</code> 划分为两段，分别递归求解两段的最大子序和，随后合并结果（即从两个值中选择较大者）。</p>
<p>那么，取上述两段最大子序和中的较大者就是数组 <code>nums</code> 的最大子序和了吗？</p>
<p>显然，上述结论是不成立的。因为将数组一分为二，没有考虑到<strong>数组跨越中间元素组成的序列</strong>的情况。那么，考虑它就是咯！</p>
<p>就测试用例而言，我们可沿索引为 <code>4</code> 的元素将 <code>nums</code> 划分为：</p>
<ul>
<li>[-2, 1, -3, 4, -1]，左半段，leftSum；</li>
<li>[2, 1, -5, 4]，右半段，rightSum；</li>
<li>[ … , 4, <strong>-1</strong>, 2, … ]，跨越中间元素的数组，crossSum。</li>
<li>取上述三者的最大值。</li>
</ul>
<p>对于左右半段，递归调用函数即可求解。如何求解跨越中间元素数组的最大子序和（crossSum）呢？</p>
<p>如图，以已经划分至最小规模的 <code>[-2, 1, -3]</code> 为例。我们从 <code>-1</code> 出发，扫描至左端边界，求得跨越中间元素数组的<strong>含边界</strong> <code>-1</code> 的最大子序和 <code>leftCrossSum</code> ；再从 <code>-3</code> 出发，扫描至右端边界，求得跨越中间元素数组的含边界 <code>-3</code> 的最大子序 <code>rightCrossSum</code> ；二者之和即为 <code>crossSum</code> 。</p>
<p><img src="/2020/02/26/五大常用算法之分治法/fig1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursion(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = recursion(nums, left, mid); <span class="comment">// 继续划分，递归求解，左段</span></span><br><span class="line">    <span class="keyword">int</span> rightSum = recursion(nums, mid+<span class="number">1</span>, right); <span class="comment">// 继续划分，递归求解，右段</span></span><br><span class="line">    <span class="keyword">int</span> crossSum = crossSum(nums, left, right); <span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> leftCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid; i&gt;=left; i--) &#123;</span><br><span class="line">        <span class="comment">// 扫描左边</span></span><br><span class="line">        leftCurrSum += nums[i];</span><br><span class="line">        leftCrossSum = Math.max(leftCrossSum, leftCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> rightCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>; i&lt;=right; i++) &#123;</span><br><span class="line">        <span class="comment">// 扫描右边</span></span><br><span class="line">        rightCurrSum += nums[i];</span><br><span class="line">        rightCrossSum = Math.max(rightCrossSum, rightCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCrossSum+rightCrossSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n log n)；</li>
<li>空间复杂度：O(log n)。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划和分治法求解最大子序和问题</title>
    <url>/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>基于LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>，总结<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">动态规划</a>和<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>的解题思路，同时涉及经典的Kadane算法。</p>
<a id="more"></a>

<h4 id="一、题目介绍"><a href="#一、题目介绍" class="headerlink" title="一、题目介绍"></a>一、题目介绍</h4><p>题目：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<h4 id="二、动态规划法"><a href="#二、动态规划法" class="headerlink" title="二、动态规划法"></a>二、动态规划法</h4><p>在<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五大常用算法之动态规划</a>中学习了动态规划中首先需要确定的三个要素：</p>
<ul>
<li><p>最优子结构</p>
</li>
<li><p>边界</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>在本题中，对于数组 <code>nums</code> 中索引为 <code>i</code> 的元素，其<strong>当前最大子序和</strong>为下列二者中的较大者：</p>
<ul>
<li>索引 <code>i-1</code> 处的当前最大子序和，加上索引 <code>i</code> 处的 <code>nums</code> 数组元素值；</li>
<li>索引 <code>i</code> 处的 <code>nums</code> 数组元素值。</li>
</ul>
<p>设 <code>dp</code> 数组保存每个元素位置的<strong>当前最大子序和</strong>。</p>
<p>状态转移方程为：<code>dp[i] = max( (dp[i-1]+nums[i]), (nums[i]) )</code>；边界条件为：<code>dp[0] = nums[0]</code>。</p>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/dp_1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// dp数组存储nums数组每个元素位置的当前最大子序和</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max((dp[i-<span class="number">1</span>]+nums[i]), nums[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.length; ++i) &#123;</span><br><span class="line">        res = Math.max(dp[i], res); <span class="comment">// 遍历dp数组，找出最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="三、Kadane算法"><a href="#三、Kadane算法" class="headerlink" title="三、Kadane算法"></a>三、Kadane算法</h4><blockquote>
<p>Kadane算法是一种动态规划算法。</p>
</blockquote>
<p>在上述动态规划算法中，使用 <code>dp</code> 数组保存数组 <code>nums</code> 所有位置的最大子序和。在经典的 kadane算法中，对此进行了优化。</p>
<p>Kadane算法采用两个辅助变量：</p>
<ul>
<li>currSum：当前位置 <code>i</code> 的最大子序和，对应的是 <code>dp</code> 中 <code>i</code> 位置的元素值；</li>
<li>maxSum：保存全局最大子序和。</li>
</ul>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/kadane.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        currSum = Math.max((currSum+nums[i]), nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、分治法"><a href="#四、分治法" class="headerlink" title="四、分治法"></a>四、分治法</h4><p>关于分治法求解过程，详见<a href="https://merlinhu0112.github.io/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/">五大常用算法之分治法</a>。</p>
<h4 id="五、算法性能总结："><a href="#五、算法性能总结：" class="headerlink" title="五、算法性能总结："></a>五、算法性能总结：</h4><p>暴力法的时间复杂度较高，为 O(n^3) 或 O(n^2)。</p>
<p>分治法的思路较为复杂，从是否跨越中间元素出发，将数组分为三个不会重合的子序列，对其分别求出最大子序和，取三者中的较大者即可。该算法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。</p>
<p>动态规划法的思路更加直观、易理解。算法性能也是最优的，时间复杂度可达 O(n)，空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建线程的方式</title>
    <url>/2020/02/21/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>尽管提倡使用线程池高效地管理线程，但了解线程创建的基础方法还是非常有必要的。</p>
<a id="more"></a>

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>创建线程的四种方式：</p>
<ul>
<li>继承Thread类，无返回结果</li>
<li>实现Runnable接口，无返回结果</li>
<li>通过FutureTask类，有返回结果</li>
<li>通过线程池创建</li>
</ul>
<h3 id="二、继承Thread类创建线程类"><a href="#二、继承Thread类创建线程类" class="headerlink" title="二、继承Thread类创建线程类"></a>二、继承Thread类创建线程类</h3><blockquote>
<p>Java的单继承机制，使得类继承Thread类后，不能再继承其它类。</p>
</blockquote>
<h5 id="1-具体实现过程如下："><a href="#1-具体实现过程如下：" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>继承Thread类，重写<strong>run( )</strong>方法。run( )方法表示线程要执行的任务，被称为执行体。</li>
<li>创建Thread子类对象实例，即创建线程对象。</li>
<li>调用线程对象的<strong>start( )</strong>方法启动该线程。</li>
</ol>
<h5 id="2-实现代码"><a href="#2-实现代码" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之一：继承Thread类，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   MyThread myThread = <span class="keyword">new</span> MyThread(); <span class="comment">// 实例化线程对象</span></span><br><span class="line">   myThread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式"><a href="#3-匿名内部类形式" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><p><em>上述还可以写成匿名内部类的形式</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、通过Runnable接口创建线程类"><a href="#二、通过Runnable接口创建线程类" class="headerlink" title="二、通过Runnable接口创建线程类"></a>二、通过Runnable接口创建线程类</h3><blockquote>
<p>在多数情况下，如果仅覆盖run( )方法而不涉及Thread类的其它方法，不建议使用第一种途径新建线程。</p>
</blockquote>
<h5 id="1-具体实现过程如下：-1"><a href="#1-具体实现过程如下：-1" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>定义Runnable接口的实现类，重写run( )方法。该实现类的实例作为<strong>任务对象</strong>，run( )方法为执行体。</li>
<li>传入任务对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
</ol>
<h5 id="2-实现代码-1"><a href="#2-实现代码-1" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RunnableTask类——任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之二：实现Runnable接口，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunnableTask runTask = <span class="keyword">new</span> RunnableTask(); <span class="comment">// 实例化任务类</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runTask); <span class="comment">// 传入任务对象，创建线程对象</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式-1"><a href="#3-匿名内部类形式-1" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、通过FutureTask类创建有返回结果的线程"><a href="#三、通过FutureTask类创建有返回结果的线程" class="headerlink" title="三、通过FutureTask类创建有返回结果的线程"></a>三、通过FutureTask类创建有返回结果的线程</h3><blockquote>
<p>FutureTask实现 <code>Future</code> 和 <code>Runnable</code> 接口，是一个可取消的<strong>异步计算任务</strong>，通过其可跟踪任务的执行情况，获取任务的执行结果。</p>
</blockquote>
<p>FutureTask类的两个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable); <span class="comment">// 执行给定的Callable对象</span></span><br><span class="line">FutureTask(Runnable runnable, V result); <span class="comment">// 执行给定的Runnable对象，成功后返回给定的result</span></span><br></pre></td></tr></table></figure>

<h5 id="1-具体实现过程如下：-2"><a href="#1-具体实现过程如下：-2" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>创建Callable接口的实现类，重写call( )方法。call( )方法为执行体，<strong>有返回值</strong>。或者，创建Runnable接口的实现类，重写run( )方法。run( )方法为执行体，无返回值。</li>
<li>调用FutureTask类的构造方法创建FutureTask对象，其中对Runnable对象需要指定result。</li>
<li>传入FutureTask对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
<li>调用FutureTask对象的<strong>get( )</strong>方法获取线程执行结束的返回值。</li>
</ol>
<h5 id="2-实现代码-2"><a href="#2-实现代码-2" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><ol>
<li><em>对于 Callable对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Callable接口的实现类，重写call( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">// call( )方法有返回值</span></span><br><span class="line">		<span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"异步计算任务开始"</span>);</span><br><span class="line">			number = Math.random()*<span class="number">10</span>;</span><br><span class="line">			number += <span class="number">500</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTask()); <span class="comment">// 传入Callable对象，创建FutureTask对象</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask); <span class="comment">// 传入FutureTask对象，创建线程对象</span></span><br><span class="line">    thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    Double result = futureTask.get(); <span class="comment">// 通过FutureTask类的get()方法获取异步计算结果</span></span><br><span class="line">    System.out.println(<span class="string">"计算结果为："</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><em>对于 Runnable 对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Runnable接口的实现类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开启线程"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Double&gt;(<span class="keyword">new</span> RunnableTask(), <span class="number">520.0</span>);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    Double result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、通过线程池管理线程"><a href="#四、通过线程池管理线程" class="headerlink" title="四、通过线程池管理线程"></a>四、通过线程池管理线程</h3><blockquote>
<p>通过工厂类 Executors 或 ThreadPoolExecutor 类可创建线程池，通过线程池可管理线程。</p>
</blockquote>
<p><em>以 Executors 为例</em></p>
<p>（1）Executors 可生成四种不同的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>; <span class="comment">// 固定长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>; <span class="comment">// 可缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>; <span class="comment">// 单线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>; <span class="comment">// 延时/定时执行任务，固定长度</span></span><br></pre></td></tr></table></figure>

<p>（2）演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">    es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.cnblogs.com/jinggod/p/8485106.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinggod/p/8485106.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类中代码加载顺序</title>
    <url>/2020/02/04/Java%E7%B1%BB%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>Java中静态变量、静态代码块、构造代码块、成员变量和构造方法的加载顺序，以及父类、子类中的加载顺序。</p>
<a id="more"></a>

<h3 id="一、单一类中代码的首次加载顺序"><a href="#一、单一类中代码的首次加载顺序" class="headerlink" title="一、单一类中代码的首次加载顺序"></a>一、单一类中代码的首次加载顺序</h3><blockquote>
<p>静态变量/静态代码块 &gt;&gt;&gt; 成员变量/构造代码块 &gt;&gt;&gt; 构造方法</p>
</blockquote>
<p><em>代码示例：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 静态变量、静态代码块和构造方法的加载次序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Test();</span><br><span class="line">		<span class="comment">//new Test().staticFunction();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	static &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(a); // 报错，因为静态变量a的加载顺序在此静态代码块之后</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 静态变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态变量比构造代码块先加载，a = "</span>+a);</span><br><span class="line">		a = <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="string">"构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载"</span>);</span><br><span class="line">		System.out.println(<span class="string">"构造代码块加载时，修改了静态变量a的值：a = "</span>+a);</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载前，完成成员变量初始化：b = "</span>+b); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// 成员变量初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态代码块</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法只有在被调用时才会加载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法被调用"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块被加载</span><br><span class="line">静态变量比构造代码块先加载，a = <span class="number">1</span></span><br><span class="line">构造代码块被加载</span><br><span class="line">构造方法被加载</span><br><span class="line">构造代码块加载时，修改了静态变量a的值：a = <span class="number">3</span></span><br><span class="line">构造方法被加载前，完成成员变量初始化：b = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>结合示例代码和其运行结果，可知在<strong>（首次）加载类</strong>的时候，</p>
<ul>
<li>首先，加载<strong>静态变量</strong>和<strong>静态代码块</strong>，其中二者的加载顺序<strong>与代码顺序相同</strong>；</li>
<li>其次，<em>在调用构造方法后</em>，按代码顺序<strong>先加载成员变量</strong>和<strong>构造代码块</strong>；</li>
<li>最后，加载<strong>构造函数</strong>。</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li>静态变量和静态代码块仅在首次加载类时被加载；</li>
<li>每调用一次构造方法，都要按序加载成员变量、构造代码块、构造函数；</li>
<li>静态方法仅在被调用时才会加载。</li>
</ul>
<h3 id="二、首次加载时父类与子类的情况"><a href="#二、首次加载时父类与子类的情况" class="headerlink" title="二、首次加载时父类与子类的情况"></a>二、首次加载时父类与子类的情况</h3><p><em>加载顺序规则如下</em>：</p>
<ol>
<li><p>按代码位置加载<strong>父类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>父类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>父类的构造方法</strong>；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>子类的构造方法</strong>。</p>
</li>
</ol>
<p><em>代码示例如下：</em></p>
<p>（父类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的成员变量：fatherEle = "</span>+fatherEle);</span><br><span class="line">		System.out.println(<span class="string">"父类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> fatherEle = <span class="number">520</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（子类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的成员变量：sonEle = "</span>+sonEle);</span><br><span class="line">		System.out.println(<span class="string">"子类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sonEle = <span class="number">1314</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（测试方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 父类、子类代码加载顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态代码块被加载</span><br><span class="line">子类的静态代码块被加载</span><br><span class="line">父类的构造代码块被加载</span><br><span class="line">父类的成员变量：fatherEle = <span class="number">520</span></span><br><span class="line">父类的构造方法被加载</span><br><span class="line">子类的构造代码块被加载</span><br><span class="line">子类的成员变量：sonEle = <span class="number">1314</span></span><br><span class="line">子类的构造方法被加载</span><br></pre></td></tr></table></figure>

<h3 id="三、非首次加载时父类与子类的情况"><a href="#三、非首次加载时父类与子类的情况" class="headerlink" title="三、非首次加载时父类与子类的情况"></a>三、非首次加载时父类与子类的情况</h3><blockquote>
<p>静态变量和静态代码块不需要再加载，其余按上述（3~6）执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之回溯算法</title>
    <url>/2020/01/13/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基于八皇后问题给出回溯算法的解析过程。回溯算法是真的难，过于抽象，还需反反复复地看看看！</p>
<a id="more"></a>

<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>回溯法（探索与回溯法）是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“<strong>回溯点</strong>”。</p>
<p>其基本思想是，在包含问题的所有解的解空间树中，按照<strong>深度优先搜索</strong>的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</p>
<h4 id="二、典型应用之八皇后问题"><a href="#二、典型应用之八皇后问题" class="headerlink" title="二、典型应用之八皇后问题"></a>二、典型应用之八皇后问题</h4><p>题干：八皇后问题由马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。试问总共有多少种摆放的方法？==（92种）==</p>
<h5 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h5><ul>
<li><p>显然，棋盘上每一行（或每一列）上只能同时出现一个皇后。要解决此问题，可先摆放第1行的皇后，紧接着摆放第2行的皇后。</p>
</li>
<li><p>在摆放第i行的皇后时，需要判断其是否与前面所有行已存在的皇后产生冲突。</p>
</li>
<li><p>若无，直接放置，并继续下一行，直至摆放完最后一行。</p>
</li>
<li><p>若产生冲突，则调整此行的皇后位置。若此行所有位置均不符合要求，则需要<strong>回溯至第i-1行，调整改行皇后的位置</strong>，直至回溯至第1行。</p>
</li>
</ul>
<h5 id="2-图解"><a href="#2-图解" class="headerlink" title="2. 图解"></a>2. 图解</h5><p>（1）放置第1行的皇后：8格均可，先尝试放置在第1格。红色表示<strong>下一行</strong>对应位置已被锁定。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/1.jpg" alt></p>
<p>（2）放置第2行的皇后：前两格已被第1行的皇后锁定，故只能在后6格中任选，选第3格。相应的，前两行放置好的皇后也锁定了第3行部分位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/2.jpg" alt></p>
<p>（3）放置第3行的皇后：在未被锁定的后4格中任选，选第5格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/3.jpg" alt></p>
<p>（4）放置第4行的皇后：只有3格可选，选第2格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/4.jpg" alt></p>
<p>（5）放置第5行的皇后：只剩2格可选，选第1格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/5.jpg" alt></p>
<p>（6）放置第6行的皇后：只能选择第4格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/6.jpg" alt></p>
<p>（7）放置第7行的皇后：只能选择第6格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/7.jpg" alt></p>
<p>（8）放置完前7行后可发现，第8行所有位置均被锁定。故回溯至第7行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/8.jpg" alt></p>
<p>（9）第7行仅有一个位置，且已尝试过，故继续回溯至第6行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/9.jpg" alt></p>
<p>（10）同样地，继续回溯至第5行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/10.jpg" alt></p>
<p>（11）第5行有两个位置，前一个已被尝试过，故选择第4格作为第5行皇后的新位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/11.jpg" alt></p>
<blockquote>
<p>很不幸，第5行重新放置后，第6行所有位置被锁定，故仍需回溯至第4行。在此就不继续演示了。</p>
</blockquote>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题，基于递归的回溯思想，解决此问题</span></span><br><span class="line"><span class="comment"> * 2020-01-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] checkerboard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 棋盘的列投影，记录每一行的皇后存放的列索引值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> len = <span class="number">8</span>; <span class="comment">// 棋盘的行或列长度为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> queens = <span class="number">8</span>; <span class="comment">// 皇后数，为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// 记录总共的解法数，对八皇后问题，应为92</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EightQueens</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归地放置皇后到第i+1行合适的位置</span></span><br><span class="line"><span class="comment">	 * 放置第i+1行的皇后之后，需要判断其是否与之前的皇后冲突，若无，递归进入下一行；</span></span><br><span class="line"><span class="comment">	 * 若产生冲突，将其往后移动一列，避免冲突</span></span><br><span class="line"><span class="comment">	 * 注意for循环内部是递归嵌套的，若到最后某一行皇后已无法移动，则会逐步返回上一层，直至</span></span><br><span class="line"><span class="comment">	 * 调整首行以实现放入所有皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putQueen</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==queens) &#123;</span><br><span class="line">			total++; <span class="comment">// 此语句执行则说明当前结果是一种可行解法，故总解法数加1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;len; col++) &#123;</span><br><span class="line">				checkerboard[i] = col; <span class="comment">// 对于第i+1行，该行的皇后放在第col+1列；若if语句为false，则调整第i+1行的皇后位置</span></span><br><span class="line">				<span class="keyword">if</span>(check(i)) &#123;</span><br><span class="line">					putQueen(i+<span class="number">1</span>); <span class="comment">// 若检查发现，第i+1行及之前各行皇后位置均满足题意，则递归移动下一行</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断第i+1行放入的皇后是否与之前的皇后产生冲突</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">			<span class="comment">// j为第i+1行之前的所有行，需要逐一比较</span></span><br><span class="line">			<span class="keyword">if</span>(checkerboard[i]==checkerboard[j] || i-checkerboard[i]==j-checkerboard[j] ||</span><br><span class="line">					i+checkerboard[i]==j+checkerboard[j]) &#123;</span><br><span class="line">				<span class="comment">// checkerboard[i]==checkerboard[j] 判断不同行的皇后是否在同一列</span></span><br><span class="line">				<span class="comment">// i-checkerboard[i]==j-checkerboard[j] 判断不同行的皇后是否在左对角线上</span></span><br><span class="line">				<span class="comment">// i+checkerboard[i]==j+checkerboard[j] 判断不同行的皇后是否在右对角线上</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 辅助方法，启动putQueen</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		putQueen(<span class="number">0</span>); <span class="comment">// 从第1行开始，其行序号为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.php.cn/faq/415926.html" target="_blank" rel="noopener">https://www.php.cn/faq/415926.html</a></p>
<p>[2] <a href="https://www.jianshu.com/p/dd3c3f3e84c0" target="_blank" rel="noopener">https://www.jianshu.com/p/dd3c3f3e84c0</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程学习笔记</title>
    <url>/2020/01/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。</p>
<a id="more"></a>

<p>多线程</p>
<ul>
<li><p>优点：多线程程序提高了资源利用效率；</p>
</li>
<li><p>并发安全性问题：多个线程共享进程的部分资源，对于这些共享变量的访问操作可能出现并发异常；</p>
<blockquote>
<p>解决途径：Java提供的同步机制</p>
</blockquote>
</li>
<li><p>活跃性问题：线程陷入死循环，影响后序代码的执行；</p>
</li>
<li><p>性能消耗问题。</p>
</li>
</ul>
<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>重要概念：</p>
<ul>
<li>状态访问操作：任何可能影响对象外部可见行为的操作；</li>
<li>共享：多个线程可同时访问；</li>
<li>可变：变量值可变。</li>
</ul>
<h4 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h4><h5 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h5><p>（1）简单描述线程安全</p>
<blockquote>
<p>当多个线程访问某个类时，该类始终表现出正确的行为，则该类是线程安全的。</p>
</blockquote>
<p>（2）无状态对象是线程安全的</p>
<blockquote>
<p>无状态对象：不包含任何域和对其它类中域的引用，在操作过程中不保存数据，是不变的类，线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessClass</span></span>&#123;</span><br><span class="line">	<span class="comment">// 不含域，即无成员变量（实例变量和类变量）及局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a; <span class="comment">// Instance Variable(non-static variable)，实例变量，不含</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">// Class Variable(static variable)，类变量，不含</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">10</span>; <span class="comment">// Local Variable，局部变量，不含</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态的对象示例 -- Servlet</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行过程中，仅由线程独享的栈中保存临时数据，因而是线程安全的</span></span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(res, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-竞态条件（Race-Condition）"><a href="#1-2-竞态条件（Race-Condition）" class="headerlink" title="1.2 竞态条件（Race Condition）"></a>1.2 竞态条件（Race Condition）</h5><p>（1）什么是竞态条件？</p>
<p>并发编程中，由于不恰当的执行时序而出现不正确的结果。</p>
<blockquote>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</blockquote>
<p>（2）常见的竞态条件类型</p>
<ol>
<li>先检查后执行（Check-Then-Act）：通过一个可能失效的观测结果来决定下一步的动作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span></span>&#123;</span><br><span class="line">    Private ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyInitRace <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于示例 <strong>延迟初始化</strong> 类，两个线程交替执行过程中，可能均观测到 <code>instance==null</code>，于是分别实例化新的<code>ExpensiveObject</code> 对象，造成 <code>getInstance()</code> 方法返回不同的实例，这是异常情况。</p>
<ol start="2">
<li>读取 - 修改 - 写入：非原子性的操作造成并发异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 访问计数器，线程每访问一次，加1</span></span><br><span class="line">    ...</span><br><span class="line">    count++; <span class="comment">// count++是非原子性的操作，它包括：读取旧值、修改值、写入新值 这三个操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程交替执行时，<code>count++</code> 操作是 <strong>非原子性</strong> 的，最终两个线程分别执行完 <code>count++</code> 操作后得到的 <code>count</code> 是相同的，显然这出现了并发异常。</p>
<p>（3）对于竞态条件，如何保证并发安全性？</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png" alt></p>
<h4 id="2-多线程的安全性"><a href="#2-多线程的安全性" class="headerlink" title="2. 多线程的安全性"></a>2. 多线程的安全性</h4><blockquote>
<p>安全的多线程并发应保证原子性、可见性和有序性</p>
</blockquote>
<h5 id="2-1-原子性、可见性和有序性"><a href="#2-1-原子性、可见性和有序性" class="headerlink" title="2.1 原子性、可见性和有序性"></a>2.1 原子性、可见性和有序性</h5><p>（1）原子性：对于单个或者多个操作，要么全部执行且不会被中断，要么都不执行。</p>
<blockquote>
<p>Atomic包、synchronized关键字、Lock接口</p>
</blockquote>
<p>（2）可见性：对于共享的可变变量，当一个线程修改了它，其它线程能立即看到变化。</p>
<blockquote>
<p>关键字 synchronized、volatile 和 final，Lock接口</p>
</blockquote>
<p>（3）有序性: </p>
<blockquote>
<p>happens-before原则</p>
</blockquote>
<ul>
<li>程序的执行顺序与代码顺序相同；</li>
<li>JVM在实际执行时会发生 <em>指令重排序</em> ；</li>
<li>重排序对单线程程序无影响，对多线程程序可能会造成并发异常！</li>
</ul>
<h5 id="2-2-如何保证可见性？"><a href="#2-2-如何保证可见性？" class="headerlink" title="2.2 如何保证可见性？"></a>2.2 如何保证可见性？</h5><p><img src="/2020/01/12/Java并发编程笔记/%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt></p>
<h4 id="3-Java-的同步机制"><a href="#3-Java-的同步机制" class="headerlink" title="3. Java 的同步机制"></a>3. Java 的同步机制</h4><blockquote>
<p>同步以保证线程安全。Java提供关键字<strong>synchronized（内置锁）</strong> 和 <strong>Lock接口</strong> 这两种机制实现同步。关键字<strong>volatile</strong> 仅保证可见性，不保证原子性。</p>
</blockquote>
<h5 id="3-1-多线程并发异常演示"><a href="#3-1-多线程并发异常演示" class="headerlink" title="3.1 多线程并发异常演示"></a>3.1 多线程并发异常演示</h5><p>（1）Bank类模拟银行账户存取操作，其中未对相应的方法进行同步，使其面临并发异常的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟多线程并发操作银行账户，Bank类实现了取钱和存钱操作。</span></span><br><span class="line"><span class="comment"> * 注意：在实际应用中，涉及金融数字时不应采用任何基本数据类型，而应使用BigDecimal类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）两个线程分别对同一个Bank实例进行反复地存、取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestBank类，演示在无同步前提下，多个线程并发地对Bank类实例</span></span><br><span class="line"><span class="comment"> * 进行操作是否会出现并发异常。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 存钱线程</span></span><br><span class="line">		Thread addThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.addMoney(<span class="number">300</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 取钱线程</span></span><br><span class="line">		Thread subThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.subMoney(<span class="number">500</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		addThread.start();</span><br><span class="line">		subThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.RuntimeException: 当前账户余额不足</span><br><span class="line">	at javasynchronization.Bank.subMoney(Bank.java:20)</span><br><span class="line">	at javasynchronization.UnsafeThread$2.run(UnsafeThread.java:39)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1500 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结合第2行和第4行可知，并发出现异常：存入300元后余额应为1300元；在1300元的基础上支取500元恰好剩余800元。</p>
<p>第12行显示，支取线程因异常而中断，此后为单线程（存钱）操作，不存在并发风险。</p>
</blockquote>
<h5 id="3-2-synchronized-修饰的同步方法【内置锁】"><a href="#3-2-synchronized-修饰的同步方法【内置锁】" class="headerlink" title="3.2 synchronized 修饰的同步方法【内置锁】"></a>3.2 synchronized 修饰的同步方法【内置锁】</h5><blockquote>
<p>关键字 synchronized，Java 所有对象都有一个内置锁，重量级锁。</p>
</blockquote>
<p>（1）SynchronizedBank类，通过<strong>synchronized</strong>实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronizedBank类，模拟银行账户的存取操作，是线程安全的类。</span></span><br><span class="line"><span class="comment"> * 关键字synchronized对subMoney和addMoney方法进行修饰，即利用</span></span><br><span class="line"><span class="comment"> * Java内置锁对上述方法进行加锁，以实现复合操作的原子性，保证线程</span></span><br><span class="line"><span class="comment"> * 安全。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果（测试代码类似于3.1部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1100 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-3-synchronized-同步代码块"><a href="#3-3-synchronized-同步代码块" class="headerlink" title="3.3 synchronized 同步代码块"></a>3.3 synchronized 同步代码块</h5><blockquote>
<p>与 synchronized 修饰的<strong>同步方法</strong>相比，<strong>同步代码块</strong>可<strong>仅对涉及共享变量的操作语句进行加锁</strong>。</p>
</blockquote>
<p>（1）同步代码块示例（由于打印语句需要读取共享变量，故仍要纳入同步代码块中，造成误认为同步方法与同步代码块加锁区域是相同的！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynBloBank类，通过同步代码块避免并发风险。其与SynchronizedBank类中</span></span><br><span class="line"><span class="comment"> * synchronized关键字修饰的同步方法类似，只是同步代码块的同步范围更小（对</span></span><br><span class="line"><span class="comment"> * 影响并发安全性的语句进行同步）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynBloBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynBloBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 同步代码块，锁对象是"this"，即调用此方法者</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 900 元</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 700 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 500 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步代码块：对有并发风险的操作语句进行加锁；</p>
<p>同步方法：对含有并发风险操作的方法进行加锁。</p>
</blockquote>
<h5 id="3-4-ReentrantLock-【显示锁】"><a href="#3-4-ReentrantLock-【显示锁】" class="headerlink" title="3.4 ReentrantLock 【显示锁】"></a>3.4 ReentrantLock 【显示锁】</h5><blockquote>
<p>ReentrantLock类实现Lock接口</p>
</blockquote>
<p>（1）ReentrantLock加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank类，线程安全类。</span></span><br><span class="line"><span class="comment"> * Lock接口定义了锁的操作（包括lock和unlock）。ReentrantLock类实现Lock接口，</span></span><br><span class="line"><span class="comment"> * 默认采用非公平的锁策略。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 锁对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 8888 元</span><br><span class="line">Thread-1 支取 500 元，余额为 8388 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8688 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8188 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8488 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8788 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8288 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-5-关键字-volatile-【不行！】"><a href="#3-5-关键字-volatile-【不行！】" class="headerlink" title="3.5 关键字 volatile 【不行！】"></a>3.5 关键字 volatile 【不行！】</h5><blockquote>
<p>volatile 关键字可以<strong>实现可见性</strong>，但<strong>无法保证原子性</strong>。</p>
</blockquote>
<p>（1）volatile 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VolatileBank类，关键字volatile修饰成员变量count，保证</span></span><br><span class="line"><span class="comment"> * 可见性，但不能保证原子性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VolatileBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1500 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机测试结果表明：并发过程出现异常，即 <em>关键字 volatile 无法保证原子性！</em></p>
</blockquote>
<h4 id="4-Java-中的锁"><a href="#4-Java-中的锁" class="headerlink" title="4. Java 中的锁"></a>4. Java 中的锁</h4><p><img src="/2020/01/12/Java并发编程笔记/Java%E4%B8%AD%E7%9A%84%E9%94%81.png" alt></p>
<h5 id="4-1-synchronized及锁升级过程"><a href="#4-1-synchronized及锁升级过程" class="headerlink" title="4.1 synchronized及锁升级过程"></a>4.1 synchronized及锁升级过程</h5><blockquote>
<p>JDK 1.5之后，synchronized锁被划分为四种状态：无锁 - 偏向锁 - 轻量级锁 - 重量级锁。</p>
</blockquote>
<p>（1）Java普通对象的内存布局</p>
<p>（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> &amp; <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt></p>
<p>（2）锁升级过程</p>
<p>Java锁升级过程（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ol>
<li><p>无锁</p>
<ul>
<li>偏向锁标志位：0</li>
<li>锁标志位：01</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li>设定 -XX:BiasedLockingStartupDelay = 0，由默认轻量级锁改为偏向锁。</li>
<li>偏向锁标志位：1</li>
<li>锁标志位：01</li>
<li><strong>记录当前线程ID</strong></li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li><p>锁标志位：00</p>
</li>
<li><p>当<strong>第二个线程</strong>参与竞争偏向锁时，对象根据对象头markdown中记录的<strong>线程ID</strong>发现是新线程，<strong>立即撤销偏向锁，升级为轻量级锁</strong>。</p>
</li>
<li><p>线程生成<strong>LockRecord</strong>保存在线程栈中。每个线程通过<strong>CAS（自旋）</strong>操作，试图将对象头中的<strong>指向栈中锁记录的指针</strong>记录为自己的LockRecord。成功则获取锁。</p>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>锁标志位：10</li>
<li>锁竞争加剧（如线程自旋次数或自旋的线程数超过阈值），由轻量级锁升级为重量级锁。</li>
<li>重量级锁开始切换用户态/内核态，开销较大。</li>
</ul>
</li>
</ol>
<h5 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h5><p>（暂无）</p>
<h5 id="4-3-ReentrantReadWriteLock"><a href="#4-3-ReentrantReadWriteLock" class="headerlink" title="4.3 ReentrantReadWriteLock"></a>4.3 ReentrantReadWriteLock</h5><p>（暂无）</p>
<h3 id="二、Java类库中的并发基础构建模块"><a href="#二、Java类库中的并发基础构建模块" class="headerlink" title="二、Java类库中的并发基础构建模块"></a>二、Java类库中的并发基础构建模块</h3><h4 id="1-同步容器类"><a href="#1-同步容器类" class="headerlink" title="1. 同步容器类"></a>1. 同步容器类</h4><ul>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<p>同步容器类通过“封装状态，同步所有公有方法”使得每次只有一个线程可以访问容器的状态，以此实现线程安全。</p>
<h5 id="1-1-为什么要为同步容器类额外地进行客户端加锁？"><a href="#1-1-为什么要为同步容器类额外地进行客户端加锁？" class="headerlink" title="1.1 为什么要为同步容器类额外地进行客户端加锁？"></a>1.1 为什么要为同步容器类额外地进行客户端加锁？</h5><blockquote>
<p>客户端加锁：对于使用某个对象的客户端代码，通过对象本身用于保护其状态的锁来保护这段客户端代码。</p>
</blockquote>
<p><em>对于复合操作，同步容器类可能会出现并发异常，但这种异常并非是同步容器类被破坏导致的</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步容器类Vector，对其进行复合操作时可能会出现异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    vector.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程 <code>Thread_A</code> 和 <code>Thread_B</code> 并发地对 <code>Vector</code> 实例进行复合操作时，<strong>无法破坏 vector 对象</strong>，但从下图可以看出，对调用者 <code>Thread_A</code> 来说，出现异常。</p>
<p><img src="/2020/01/12/Java并发编程笔记/3.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行客户端加锁，以保证对同步容器类实例的复合操作是线程安全的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象vector的锁来进行客户端加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">   		<span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    	vector.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-对容器进行迭代操作是有并发风险的"><a href="#1-2-对容器进行迭代操作是有并发风险的" class="headerlink" title="1.2 对容器进行迭代操作是有并发风险的"></a>1.2 对容器进行迭代操作是有并发风险的</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在迭代操作中，其它线程可能并发地修改容器，导致当前线程迭代出现异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    	doSomething(vector.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-如何降低加锁带来的性能影响？"><a href="#1-3-如何降低加锁带来的性能影响？" class="headerlink" title="1.3 如何降低加锁带来的性能影响？"></a>1.3 如何降低加锁带来的性能影响？</h5><blockquote>
<p>克隆容器，在<strong>线程封闭</strong>的副本上进行加锁、复合操作。</p>
</blockquote>
<h4 id="2-并发容器类"><a href="#2-并发容器类" class="headerlink" title="2. 并发容器类"></a>2. 并发容器类</h4><h5 id="2-1-并发容器类与同步容器类的比较"><a href="#2-1-并发容器类与同步容器类的比较" class="headerlink" title="2.1 并发容器类与同步容器类的比较"></a>2.1 并发容器类与同步容器类的比较</h5><p>（1）同步容器类在执行每一个操作时均持有锁，虽保证了线程安全，但降低了并发性。</p>
<p>（2）多个线程竞争同步容器类的锁时，将严重降低系统吞吐量。</p>
<p>（3）并发容器类较同步容器类有更好地并发性能。</p>
<h5 id="2-2-以ConcurrentHashMap为例"><a href="#2-2-以ConcurrentHashMap为例" class="headerlink" title="2.2 以ConcurrentHashMap为例"></a>2.2 以ConcurrentHashMap为例</h5><p>（1）加锁策略 —— <strong>分段锁（Lock Striping）</strong>，细粒度的锁</p>
<ul>
<li>Hashtable（同步容器类）：执行每个操作时均持有锁，提供独占式访问；</li>
<li>SynchronizedMap（同步且基于散列的Map，Collections类中定义的内部类）：独占式访问</li>
<li>ConcurrentHashMap：不是将每个方法在同一个锁上同步，因此<strong>不提供独占式访问</strong>；多个线程可并发访问容器。</li>
</ul>
<p>（2）分段锁策略的特性</p>
<ul>
<li>多个读取线程可并发地访问容器；</li>
<li>多个写入线程可并发地修改容器；</li>
<li>读取线程和并发线程可并发地操作容器。</li>
</ul>
<p>（3）ConcurrentHashMap的优势</p>
<ul>
<li>并发环境下提高系统吞吐量；</li>
<li>迭代器不会抛出ConcurrentModificationException。</li>
</ul>
<h5 id="2-3-ConcurrentHashMap结构及分段锁"><a href="#2-3-ConcurrentHashMap结构及分段锁" class="headerlink" title="2.3 ConcurrentHashMap结构及分段锁"></a>2.3 ConcurrentHashMap结构及分段锁</h5><p><img src="/2020/01/12/Java并发编程笔记/4.jpg" alt></p>
<p>如图所示，ConcurrentHashMap被分为多个片段（Segment），同时一个片段被分为多个HashEntry。</p>
<ul>
<li>Segment继承 <code>ReentrantLock</code> ，扮演锁的角色；</li>
<li>HashEntry用于存储键值对数据（注意：ConcurrentHashMap中key和value均不得为null）；</li>
<li>修改HashEntry数组的数据时，线程必须<strong>先获得对应的Segment锁</strong>。</li>
</ul>
<h4 id="3-同步工具类"><a href="#3-同步工具类" class="headerlink" title="3. 同步工具类"></a>3. 同步工具类</h4><blockquote>
<p>同步工具类是指能根据其自身的状态来<strong>协调线程的控制流</strong>的对象。</p>
</blockquote>
<p>示例：阻塞队列（BlockingQueue）、信号量（Semaphore）、栅栏（Barrier）、闭锁（Latch）</p>
<h5 id="3-1-信号量"><a href="#3-1-信号量" class="headerlink" title="3.1 信号量"></a>3.1 信号量</h5><p>信号量通过管理一组虚拟的许可来控制操作，其具体实现如下：</p>
<ul>
<li>控制同时访问数</li>
<li>实现资源池</li>
<li>对容器施加边界</li>
</ul>
<h5 id="3-2-闭锁"><a href="#3-2-闭锁" class="headerlink" title="3.2 闭锁"></a>3.2 闭锁</h5><p>闭锁是指可以<strong>延迟线程的进度</strong>直到其到达终止状态，其特性如下：</p>
<ul>
<li><p>一次性对象，<strong>不能被重置</strong>；</p>
</li>
<li><p>闭锁到达终止状态前，不允许任何线程通过；</p>
</li>
<li><p>闭锁到达终止状态后，允许线程通过；</p>
</li>
<li><p>用以确保某些活动直到其它活动都完成后再开始，例如待所需资源全部加载后才开始执行初始化。</p>
</li>
</ul>
<h5 id="3-3-栅栏"><a href="#3-3-栅栏" class="headerlink" title="3.3 栅栏"></a>3.3 栅栏</h5><p>栅栏能<strong>阻塞一组线程</strong>直到某个事件发生</p>
<ul>
<li>栅栏要求线程同时到达栅栏位置，方能继续执行；</li>
<li>非一次性；</li>
<li>闭锁用于<em>等待事件</em>，栅栏用于<em>等待线程</em>。</li>
</ul>
<h3 id="三、任务执行策略"><a href="#三、任务执行策略" class="headerlink" title="三、任务执行策略"></a>三、任务执行策略</h3><h4 id="1-串行与并行执行任务"><a href="#1-串行与并行执行任务" class="headerlink" title="1. 串行与并行执行任务"></a>1. 串行与并行执行任务</h4><h5 id="1-1-串行执行任务"><a href="#1-1-串行执行任务" class="headerlink" title="1.1 串行执行任务"></a>1.1 串行执行任务</h5><p><em>显然，服务器单线程串行执行任务，低吞吐量 &amp; 低响应速度</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket connection = socket.accept(); <span class="comment">// 接收请求</span></span><br><span class="line">            handleRequest(connection); <span class="comment">// 处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，服务器只有一个主线程来监听80端口、接收并处理请求。简言之，每次只能有一个请求被处理，后续请求必须等待前序请求完成后才能被服务器接收、处理。</p>
<h5 id="1-2-并行执行任务"><a href="#1-2-并行执行任务" class="headerlink" title="1.2 并行执行任务"></a>1.2 并行执行任务</h5><p><em>主线程监听端口、接收并分发请求，同时创建新线程来处理请求</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); <span class="comment">// 主线程接收请求</span></span><br><span class="line">            Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection); <span class="comment">// 主线程创建新线程处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(command).start(); <span class="comment">// 启动新线程，处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性：</p>
<ul>
<li><strong>在不超过服务器处理能力的前提下</strong>，提高了服务器吞吐量和响应速度；</li>
<li>主线程监听端口、接收并分发请求，创建新线程；</li>
<li>处理请求的线程<strong>并发地处理请求</strong>。</li>
</ul>
<h5 id="1-3-主线程频繁新建线程的风险"><a href="#1-3-主线程频繁新建线程的风险" class="headerlink" title="1.3 主线程频繁新建线程的风险"></a>1.3 主线程频繁新建线程的风险</h5><ul>
<li>创建和销毁线程的开销非常高；</li>
<li>大量线程带来的资源消耗会降低性能；</li>
<li>线程数量超过限制会造成系统异常。</li>
</ul>
<h4 id="2-Executor框架-——-异步任务执行框架"><a href="#2-Executor框架-——-异步任务执行框架" class="headerlink" title="2. Executor框架 —— 异步任务执行框架"></a>2. Executor框架 —— 异步任务执行框架</h4><blockquote>
<p>异步任务执行：将<strong>任务的提交过程</strong>和<strong>执行过程</strong>解耦合</p>
</blockquote>
<h5 id="2-1-为何使用Executor框架？"><a href="#2-1-为何使用Executor框架？" class="headerlink" title="2.1 为何使用Executor框架？"></a>2.1 为何使用Executor框架？</h5><p>前述两种<em>任务执行策略</em>（单线程串行执行任务、新建线程并行执行任务）均存在一定的不足。在异步任务执行框架中将任务的提交和执行解耦，其中通过<strong>线程池</strong>实现对线程的高效管理。</p>
<h5 id="2-2-Executor框架的基础-——-生产者-消费者模式"><a href="#2-2-Executor框架的基础-——-生产者-消费者模式" class="headerlink" title="2.2 Executor框架的基础 —— 生产者-消费者模式"></a>2.2 Executor框架的基础 —— 生产者-消费者模式</h5><ul>
<li>生产者：提交任务的操作</li>
<li>消费者：执行任务的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">50</span>; <span class="comment">// 线程池长度</span></span><br><span class="line">    <span class="comment">// newFixedThreadPool方法将返回一个固定长度的线程池，其长度不再变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec</span><br><span class="line">        = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Connection connection = socket.accept();</span><br><span class="line">         	Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(command); <span class="comment">// 线程池负责管理线程以执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>通过实现 Executor接口，可制定更丰富的执行策略</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Executor框架结构"><a href="#2-3-Executor框架结构" class="headerlink" title="2.3 Executor框架结构"></a>2.3 Executor框架结构</h5><p><img src="/2020/01/12/Java并发编程笔记/5.jpg" alt></p>
<p><em>Executor框架包括以下三个部分：</em></p>
<ol>
<li><p><strong>任务</strong>：被执行的任务需要实现Runnable接口或Callable接口；</p>
</li>
<li><p><strong>执行</strong>：线程执行任务，包括Executor接口和最重要的<strong>ThreadPoolExecutor</strong>类；</p>
</li>
<li><p><strong>异步计算</strong>：包括Future接口及实现Future接口的FutureTask类。</p>
</li>
</ol>
<h5 id="2-4-Executor框架的执行过程"><a href="#2-4-Executor框架的执行过程" class="headerlink" title="2.4 Executor框架的执行过程"></a>2.4 Executor框架的执行过程</h5><p>（1）创建任务对象</p>
<p>创建实现Runnable接口或Callable接口的任务对象。</p>
<p><em>实现 Runnable接口，重写 run 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>实现 Callable 接口，重写 call 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"实现Callable接口，重写Call方法，有返回值"</span>;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Runnable接口与Callable接口的区别：</strong></p>
<ul>
<li>Runnable接口无返回值；</li>
<li>Callable接口有返回值，需要声明抛出异常。</li>
</ul>
<p><em>通过工厂类 Executors 的 Callable(Runnable task) 方法可将 Runnable 对象包装成 Callable 对象</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Object&gt; task = Executors.callable(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<p>（2）执行任务</p>
<blockquote>
<p>通过实现java.util.concurrent.ExecutorService接口的对象来执行任务</p>
</blockquote>
<ol>
<li>将Runnable对象交给ExecutorService执行，调用<strong>execute</strong>方法，无返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Runnable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象，<strong>但调用Future对象的get方法，返回值为null</strong>。【源码分析见 2.5】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;Object&gt; future = (Future&lt;Object&gt;) es.submit(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(future.get()==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"future.get()返回null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将Callable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">				<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure>

<p>（3）关闭线程池</p>
<ol>
<li>对于执行ExecutorService的execute方法，调用shutdown方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"></span><br><span class="line">es.shutdown(); <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于执行ExecutorService的submit方法，主线程可执行FutureTask.get()方法等待任务执行完毕，也可通过FutureTask.cancel()方法取消任务的执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(future.get());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解"><a href="#2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解" class="headerlink" title="2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解"></a>2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解</h5><p> <strong>AbstractExecutorService</strong>类实现了ExecutorService接口并实现了<strong>submit()</strong> 方法，ThreadPoolExecutor类从AbstractExecutorService类继承了submit方法。</p>
<p><em>基于 JDK 1.8的源码，分析如下：</em></p>
<p>AbstractExecutorService类实现了ExecutorService接口，实现submit()方法。将Runnable对象交给 ExecutorService去处理且调用<code>submit(Runnable task)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask); <span class="comment">// 调用ThreadPoolExecutor类的execute方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部通过调用<code>newTaskFor(Runnable runnable, T value)</code>方法返回一个<code>FutureTask</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造<code>FutureTask</code>对象时，通过调用<code>Executors.callable(runnable, result)</code>方法<strong>将Runnable对象包装成Callable对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于提交的 Callable 对象，AbstractExecutorService 类同样是调用 newTaskFor 方法 返回一个 FutureTask 对象：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-线程池-——-高效地管理线程的生命周期"><a href="#3-线程池-——-高效地管理线程的生命周期" class="headerlink" title="3. 线程池 —— 高效地管理线程的生命周期"></a>3. 线程池 —— 高效地管理线程的生命周期</h4><p><em>重要参数：</em></p>
<ul>
<li><p>corePoolSize：线程池的目标大小，即无任何任务执行时线程池的大小，且仅当工作队列已满才会产生大于此值的线程数量。</p>
</li>
<li><p>maximumPoolSize：线程池最大同时活动线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。线程空闲时间大于存活时间，被标记为“可回收”；活动线程数大于corePoolSize时，回收标记为“可回收”的空闲线程。</p>
</li>
</ul>
<p><strong><em>两个重要的问题：</em></strong></p>
<ol>
<li><p>为什么要使用线程池，而不是直接手动创建线程？</p>
<ul>
<li><p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。</p>
</li>
<li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>为什么要通过ThreadPoolExecutor创建线程池，而不是通过工厂类Executors？<ul>
<li>使开发者更加明确线程池的运行规则，避免资源耗尽的风险。</li>
<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integet.MAX_VALUE，可能会堆积大量的请求。</li>
<li>CachedThreadPool 和 ScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程。</li>
<li>上述四种方式其本质还是调用ThreadPoolExecutor。</li>
</ul>
</li>
</ol>
<h5 id="3-1-通过工厂类Executors的静态工厂方法"><a href="#3-1-通过工厂类Executors的静态工厂方法" class="headerlink" title="3.1 通过工厂类Executors的静态工厂方法"></a>3.1 通过工厂类Executors的静态工厂方法</h5><p>通过调用工厂类Executors中的静态工厂方法，可产生如下类型的线程池：</p>
<ul>
<li>newFixedThreadPool  固定长度</li>
<li>newCachedThreadPool 可缓存</li>
<li>newSingleThreadExecutor 单线程</li>
<li>newScheduledThreadPool 延时/定时执行任务，固定长度</li>
</ul>
<p>（1）newFixedThreadPool</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为指定值nThread，keepAliveTime设为0。</p>
</li>
<li><p>固定长度的线程池。因corePoolSize为nThread，故每提交一个任务就创建一个线程，直到总数为nThreads。</p>
</li>
<li><p>keepAliveTime为0，线程不会超时。</p>
</li>
<li><p>线程执行过程中异常中断，会新建线程以补充。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）newCachedThreadPool</p>
<ul>
<li><p>corePoolSize设为0，maximumPoolSize设为Integer.MAX_VALUE，keepAliveTime设为60秒。</p>
</li>
<li><p>无可用线程时新建线程，有可用线程时则复用该线程。</p>
</li>
<li><p>因maximumPoolSize设为Integer.MAX_VALUE，即线程数最大值为2147483647。</p>
</li>
<li><p>线程存活时间为60秒，避免大量空闲线程对资源的消耗。</p>
</li>
<li><p>同步任务队列SynchronousQueue<runnable>。</runnable></p>
</li>
<li><p>此线程池适用于大量短暂的异步任务。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）newSingleThreadExecutor</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为1，keepAliveTime设为0。</p>
</li>
<li><p>首次提交任务时创建单个线程，且仅维持一个线程。</p>
</li>
<li><p>当线程在关闭前异常终止，程序新建一个线程以执行后续任务。</p>
</li>
<li><p>确保任务串行执行。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法返回的是FinalizableDelegatedExecutorService对象，其内部保存一个ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Executors类的静态方法newSingleThreadExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类FinalizableDelegatedExecutorService，其继承自Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e; <span class="comment">// 内部保存一个ExecutorService对象</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）newScheduledThreadPool</p>
<ul>
<li><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>可延时执行阻塞任务的队列。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法指定线程池基本大小、返回ScheduledThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ScheduledThreadPoolExecutor类，其调用父类ThreadPoolExecutor的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-ThreadPoolExecutor"><a href="#3-2-ThreadPoolExecutor" class="headerlink" title="3.2 ThreadPoolExecutor"></a>3.2 ThreadPoolExecutor</h5><p>（暂无）</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] 《Java并发编程实战》Goetz B. 著，童云兰译</p>
<p>[2] <a href="https://www.infoq.cn/article/ConcurrentHashMap/" target="_blank" rel="noopener">https://www.infoq.cn/article/ConcurrentHashMap/</a></p>
<p>[3] <a href="http://www.bubuko.com/infodetail-1518587.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1518587.html</a></p>
<p>[4] <a href="https://blog.csdn.net/tongdanping/article/details/79604637" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79604637</a></p>
<p>[5] <a href="https://www.cnblogs.com/xifengxiaoma/p/11477136.html" target="_blank" rel="noopener">https://www.cnblogs.com/xifengxiaoma/p/11477136.html</a></p>
<p>[6] <a href="https://www.cnblogs.com/jiansen/p/7351872.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiansen/p/7351872.html</a></p>
<p>[7] <a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a></p>
<p>[8] <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之动态规划</title>
    <url>/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>通过阅读他人优秀的文章，基于经典的青蛙跳台阶问题，深入地学习动态规划建模过程。通过递归算法、自顶向下的备忘录算法及自低向上的动态规划算法，解决实际问题。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>动态规划（Dynamic Programming）与<strong>分治法</strong>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。</p>
<p>用一个表来记录所有已解的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，这就是动态规划法的基本思路。</p>
<h4 id="二、建模"><a href="#二、建模" class="headerlink" title="二、建模"></a>二、建模</h4><p>对问题建模前，须明确以下三个重要概念：</p>
<blockquote>
<p>1、最优子结构</p>
<p>2、边界</p>
<p>3、状态转移方程</p>
</blockquote>
<h4 id="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"><a href="#三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程" class="headerlink" title="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"></a>三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程</h4><h5 id="1-对青蛙跳台阶问题的图解"><a href="#1-对青蛙跳台阶问题的图解" class="headerlink" title="1. 对青蛙跳台阶问题的图解"></a>1. 对青蛙跳台阶问题的图解</h5><p>（本小节图源：<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a> ）</p>
<ul>
<li>每次跳1级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/1.jpg" alt></p>
<ul>
<li>或每次跳2级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/2.jpg" alt></p>
<p>如果站在第n级台阶的角度上，如何到达该层？</p>
<blockquote>
<p>a. 从第n-1级台阶，跳1级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/3.jpg" alt></p>
<blockquote>
<p>b. 从第n-2级台阶，跳2级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/4.jpg" alt></p>
<p>显然，<strong>到达第n级台阶的路线总数等于到达第n-1级和第n-2级之和</strong>。</p>
<h5 id="2-建模"><a href="#2-建模" class="headerlink" title="2. 建模"></a>2. 建模</h5><ul>
<li><p>最优子结构</p>
<p>如上所述，第n级台阶的路线总数等于到达第n-1级和第n-2级之和，即 F(n) = F(n-1) + F(n-2)。</p>
</li>
<li><p>状态转移方程</p>
<p><strong>F(n) = F(n-1) + F(n-2)</strong></p>
</li>
<li><p>边界</p>
<p>F(1) = 1, F(2) = 2</p>
</li>
</ul>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><p>（1）递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（2）备忘录算法（自顶向下）</p>
<p>利用集合Map，避免递归算法中的重复计算部分，提高算法效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N, HashMap&lt;Integer, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(N))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(N);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">        map.put(N, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（3）动态规划（自底向上）</p>
<p>备忘录算法中须保存所有子状态，若仅仅保存递推所需的前两个子状态，便能优化算法的空间复杂度。</p>
<blockquote>
<p>通过自底向上的递推，仅仅利用常数额外空间，优化算法的时间和空间复杂度，这便是动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp; <span class="comment">// 更新最新的子状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、更加复杂的动态规划——国王与金矿问题"><a href="#四、更加复杂的动态规划——国王与金矿问题" class="headerlink" title="四、更加复杂的动态规划——国王与金矿问题"></a>四、更加复杂的动态规划——国王与金矿问题</h4><p>问题：有一个国家发现了n座金矿，每座金矿的黄金储量不同，且每座金矿需要参与挖掘的工人数也不同。参与挖矿工人的总数是w。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要想得到尽可能多的黄金，应该选择挖取哪几座金矿？</p>
<p>（本小节图源：<a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a> ）</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/5.jpg" alt></p>
<h5 id="1-建模"><a href="#1-建模" class="headerlink" title="1. 建模"></a>1. 建模</h5><blockquote>
<p>n：金矿数量；w：总的工人数；g[]：保存每座金矿的矿藏量；p[]：保存每座金矿的用工数</p>
</blockquote>
<p>建模过程中，需要明确最优子结构、状态转移方程和边界这三个要素。</p>
<p>（1）确定最优子结构</p>
<p>以10名工人开挖5座金矿为例。其最优子结构分为如下两种情况：</p>
<ul>
<li>若不挖第5座金矿，则最优解为10人开挖4座金矿的最优解；</li>
<li>若挖第5座金矿，则需要找到剩下的人挖剩余的4座金矿的最优解；</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/6.jpg" alt></p>
<blockquote>
<p>显然，10人挖5座金矿的最优解是这两种子状态的较大值</p>
</blockquote>
<p>（2）确定状态转移方程</p>
<ul>
<li>若第n座金矿有足够的人工开挖，则w个工人开挖n座金矿的情形，满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = max(F(n-1, w), F(n-1, w-p[n-1])+g(n-1)), n&gt;1, w&gt;=p[n-1]</p>
</blockquote>
<ul>
<li>若w个工人不能满足开采第n座金矿所需的工人数，则满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = F(n-1, w), n&gt;1, w&lt;p[n-1]</p>
</blockquote>
<p>（3）确定边界</p>
<ul>
<li>若金矿数仅为1，且工人数能满足开采该金矿所需的工人数，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = g[0], n==1, w&gt;=p[0]</p>
</blockquote>
<ul>
<li>若金矿数为1，但工人总数不满足要求，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = 0, n==1, w&lt;p[0]</p>
</blockquote>
<h5 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2. 算法实现"></a>2. 算法实现</h5><p>（1）递归解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = getMaxGold(n-<span class="number">1</span>, w, g, p);</span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p) + g[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>（2）备忘录算法</p>
<blockquote>
<p>类似于青蛙跳问题中的备忘录算法，利用集合Map保存子状态，其中HashMap的Key是包含金矿数n和工人数w的对象，Value是最多的开采量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p, HashMap&lt;KeyObject, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject a_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(a_obj)) &#123;</span><br><span class="line">        a = map.get(a_obj);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        a = getMaxGold(n-<span class="number">1</span>, w, g, p, map);</span><br><span class="line">        map.put(a_obj, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject b_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(b_obj)) &#123;</span><br><span class="line">        b = map.get(b_obj) + g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p, map);</span><br><span class="line">        map.put(b_obj, b);</span><br><span class="line">        b += g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类用于HashMap中的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyObject</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(n*w)</li>
</ul>
<p>（3）动态规划算法</p>
<p>以10名工人挖5座金矿为例，可作下表</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/7.jpg" alt></p>
<p>表中，每一行的所有数据均可<strong>由上一行数据推导得到</strong>，因而动态规划算法可基于此规律，利用前一行数据推导当前行数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] preResult = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>]; <span class="comment">// w+1列，保存上一行数据</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;p[<span class="number">0</span>]) &#123;</span><br><span class="line">            preResult[j] = <span class="number">0</span>; <span class="comment">// 当金矿数为1，但工人总数无法满足开采要求时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            preResult[j] = g[<span class="number">0</span>]; <span class="comment">// 金矿数为1，且工人总数满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> preResult[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="comment">// 外循环中，i为当前金矿索引；内循环中，j为工人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;p[i]) &#123;</span><br><span class="line">                <span class="comment">// 若j个工人不能满足开采第i+1座金矿所需的工人数</span></span><br><span class="line">                result[j] = preResult[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若第i+1座金矿有足够的人工开挖，则j个工人开挖i+1座金矿</span></span><br><span class="line">                result[j] = Math.max(preResult[j], preResult[j-p[i]]+g[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            preResult[j] = result[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(w)</li>
</ul>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a></p>
<p>[2] <a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习之虚拟机</title>
    <url>/2019/11/11/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>通读周志明先生的《深入理解Java虚拟机》一书，学习了Java虚拟机的内存模型，内存管理机制，常见的垃圾回收算法和不同类型的垃圾收集器，以及字节码文件的结构。现整理成笔记，温故而知新！</p>
<a id="more"></a>

<h3 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h3><h4 id="1-Java内存区域图示如下："><a href="#1-Java内存区域图示如下：" class="headerlink" title="1. Java内存区域图示如下："></a>1. Java内存区域图示如下：</h4><p><img src="/2019/11/11/Java学习之虚拟机/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%A4%BA%E6%84%8F.png" alt></p>
<p>值得注意的是：<strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>、<strong>堆（Heap）</strong>、<strong>方法区（Method Area）</strong>：</p>
<ol>
<li><p>虚拟机栈主要与方法调用相关，存储的局部变量表中保存<strong>对象引用</strong>；</p>
</li>
<li><p>堆：存放所有的对象实例；</p>
</li>
<li><p>方法区：与编译相关，存储虚拟机加载的类信息、<strong>静态变量</strong>、常量等；</p>
</li>
<li><p>运行时常量池：编译生成的字面量和符号引用。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/2.png" alt></p>
<h4 id="2-HotSpot虚拟机新建对象过程"><a href="#2-HotSpot虚拟机新建对象过程" class="headerlink" title="2. HotSpot虚拟机新建对象过程"></a>2. HotSpot虚拟机新建对象过程</h4><p>以常见的HotSpot为例，介绍其新建普通 Java对象的过程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BAnew%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>（1）在堆中分配内存的两种方式：</p>
<ul>
<li><p>指针碰撞：内存区域规整（未使用区域与已使用区域分界）时，仅需要移动指针</p>
</li>
<li><p>空闲列表：因内存区域杂乱无章，虚拟机维持记录可用内存区域的表</p>
</li>
</ul>
<p><strong>（2）两种保证分配内存时线程安全的方法：</strong></p>
<ul>
<li><p>同步机制，CAS + 失败重试</p>
</li>
<li><p><strong>每个线程</strong>单独预分配一块内存区域，称之为<strong>本地线程分配缓冲（TLAB）</strong></p>
</li>
</ul>
<p>（3）对象的内存布局：</p>
<ol>
<li><p>对象头：保存运行时数据，如哈希码、GC分代年龄等；另一部分保存指向类元数据的<strong>类型指针</strong></p>
</li>
<li><p>实例数据部分</p>
</li>
<li><p>填充位</p>
</li>
</ol>
<h4 id="3-对象的访问方式"><a href="#3-对象的访问方式" class="headerlink" title="3. 对象的访问方式"></a>3. 对象的访问方式</h4><p>访问对象的途径主要是通过句柄和直接访问：</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p><strong>对象类型数据</strong>是指该实例所属的类</p>
<p>查找对象的元数据信息未经过对象本身</p>
<p>优点：垃圾收集需要调整对象所在内存地址时，不影响reference；</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p>查找对象的元数据信息须经过对象本身</p>
<p>优点：访问速度快</p>
</blockquote>
<h4 id="4、内存分配策略"><a href="#4、内存分配策略" class="headerlink" title="4、内存分配策略"></a>4、内存分配策略</h4><p>具体的内存分配策略取决于 GC组合、JVM参数设置：</p>
<ol>
<li><p>对象优先在新生代 Eden 区分配，该区域不足时，发起 Minor GC；</p>
</li>
<li><p>占用大内存的对象直接进入老年代；</p>
</li>
<li><p>寿命长的对象进入老年代（根据对象年龄计数器来判断）；</p>
</li>
<li><p>Survivor 空间中相同年龄的对象达到一半空间时，年龄大于或等于该年龄的对象可进入老年代；</p>
</li>
<li><p>老年代为 Minor GC提供空间分配担保。</p>
</li>
</ol>
<h3 id="二、GC工作区域"><a href="#二、GC工作区域" class="headerlink" title="二、GC工作区域"></a>二、GC工作区域</h3><p>在 JVM中，虚拟机栈、本地方法栈和程序计数器属于线程私有，随线程结束而释放内存。JVM中的GC关注的是<strong>方法区</strong>和<strong>堆</strong>。</p>
<h4 id="1-回收堆"><a href="#1-回收堆" class="headerlink" title="1. 回收堆"></a>1. 回收堆</h4><h5 id="1-1-如何判断对象内存可回收？"><a href="#1-1-如何判断对象内存可回收？" class="headerlink" title="1.1 如何判断对象内存可回收？"></a>1.1 如何判断对象内存可回收？</h5><p><strong>可达性分析算法</strong>：根搜索方法，通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain）。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg" alt></p>
<h5 id="1-2-Java中可作为GC-Roots的四种对象："><a href="#1-2-Java中可作为GC-Roots的四种对象：" class="headerlink" title="1.2 Java中可作为GC Roots的四种对象："></a>1.2 Java中可作为GC Roots的四种对象：</h5><ul>
<li><p>虚拟机栈的本地变量表中引用的对象</p>
</li>
<li><p>方法区类静态属性引用的对象</p>
</li>
<li><p>方法区常量引用的对象</p>
</li>
<li><p>本地方法栈Native方法引用的对象</p>
</li>
</ul>
<h5 id="1-3-经可达性分析后，可回收对象就一定会被回收？"><a href="#1-3-经可达性分析后，可回收对象就一定会被回收？" class="headerlink" title="1.3 经可达性分析后，可回收对象就一定会被回收？"></a>1.3 经可达性分析后，可回收对象就一定会被回收？</h5><p>经可达性分析后，被定为可回收的对象须经历<strong>两次标记</strong>方能被GC回收内存。【重点：finalize()方法】</p>
<h5 id="1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"><a href="#1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？" class="headerlink" title="1.4 JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"></a>1.4 JVM为什么不采用经典的<strong>引用计数</strong>算法来判断对象是否可回收？</h5><p>引用计数算法实现简单，但面临一个重要缺陷：当两个对象互相引用（循环引用）时，相应的内存区域无法被回收，导致<strong>内存泄漏</strong></p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt></p>
<h5 id="1-5-引用分类（是否回收被引用对象所在的内存区域）"><a href="#1-5-引用分类（是否回收被引用对象所在的内存区域）" class="headerlink" title="1.5 引用分类（是否回收被引用对象所在的内存区域）"></a>1.5 引用分类（是否回收被引用对象所在的内存区域）</h5><ol>
<li><p>强引用：new出来的对象引用关系，不会回收；</p>
</li>
<li><p>软引用：有用、非必需，在内存溢出前进行二次回收；</p>
</li>
<li><p>弱引用：生存至下一次GC工作前，一旦GC开始回收内存，则直接回收其对象；</p>
</li>
<li><p>虚引用：无法通过虚引用取得对象，仅能在此对象被回收时通知系统。</p>
</li>
</ol>
<h4 id="2、回收方法区"><a href="#2、回收方法区" class="headerlink" title="2、回收方法区"></a>2、回收方法区</h4><p>方法区待回收的内容主要为：废弃常量 和 无用的类。</p>
<p>（1）废弃常量：当常量池中的常量不被任何对象引用时，则可以清理出常量池。</p>
<p>（2）无用的类：无用的类须满足下述三个条件，</p>
<ul>
<li><p>Java堆中该类所有的实例均已被回收；</p>
</li>
<li><p>该类的加载器ClassLoader已被回收；</p>
</li>
<li><p>无法通过反射机制访问该类的方法。</p>
</li>
</ul>
<h3 id="三、回收算法"><a href="#三、回收算法" class="headerlink" title="三、回收算法"></a>三、回收算法</h3><p>JVM 针对 Java堆 采用的回收算法主要分为：<strong>标记-清除算法、复制算法和标记-整理算法</strong>；采用的策略为：分代收集算法，即新生代采用复制算法，老年代采用标记-清除算法和标记-整理算法</p>
<h4 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h4><h5 id="1-1-标记-清除（Mark-Sweep）算法"><a href="#1-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="1.1 标记-清除（Mark-Sweep）算法"></a>1.1 标记-清除（Mark-Sweep）算法</h5><p>在标记阶段，由<strong>根节点开始经可达性分析</strong>，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象；</p>
<p>在清除阶段，清除所有未被标记的对象。</p>
<ul>
<li><p><em>特点：将循环引用标记为不可达，解决了引用计数算法无法处理循环引用的问题.</em></p>
</li>
<li><p><em>缺点：1、效率低；2、易导致内存区域不规整（即大量不连续的内存碎片）。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-2-复制（Copying）算法"><a href="#1-2-复制（Copying）算法" class="headerlink" title="1.2 复制（Copying）算法"></a>1.2 复制（Copying）算法</h5><p>内存对半分，先使用一半，需要清理时先将存活对象转移至保留内存区域，随后全部回收刚使用过的一半内存。</p>
<p><strong>适用于新生代</strong>中对象存活率低、可回收对象比例高的场景。</p>
<ul>
<li><em>优点：1、无内存碎片；2、效率高。</em></li>
<li><em>缺点：1、实际使用内存仅占一半，浪费资源；2、当对象存活率高时，需要较为频繁的复制操作，效率降低。</em></li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-3-标记-整理（Mark-Compact）算法"><a href="#1-3-标记-整理（Mark-Compact）算法" class="headerlink" title="1.3 标记-整理（Mark-Compact）算法"></a>1.3 标记-整理（Mark-Compact）算法</h5><p>针对老年代中对象存活率高，若使用复制算法，则效率低。</p>
<p>标记-整理算法（或标记-压缩算法）核心在于：标记完成后，将“分散”的存活对象移动至“端集中”区域，随后清理其端边界以外的内存。</p>
<ul>
<li><p><em>优点：1、适用于对象存活率高的场景；2、无内存碎片。</em></p>
</li>
<li><p><em>缺点：标记、整理过程代价高昂。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-4-分代收集（Generational-Collection）算法"><a href="#1-4-分代收集（Generational-Collection）算法" class="headerlink" title="1.4 分代收集（Generational Collection）算法"></a>1.4 分代收集（Generational Collection）算法</h5><p>将 Java堆分为<strong>新生代</strong>和<strong>老年代</strong></p>
<ul>
<li><p>新生代：对象存活率低，垃圾多；</p>
</li>
<li><p>老年代：对象存活率高，垃圾少。</p>
</li>
</ul>
<p>基于上述算法的优缺点，分代收集的策略是：<em>对新生代采用复制算法，对老年代采用标记-清除或标记-整理算法</em> 。</p>
<p>在新生代中，分为：较大的<strong>Eden空间</strong>和两块较小的<strong>Survivor空间</strong>。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt></p>
<ol>
<li><p>在新生代中，先使用Eden和一块Survivor区域，另一块Survivor区域保留，其空间比例一般为8：1：1；</p>
</li>
<li><p>回收时，Eden和Survivor(From)中<strong>存活时间长和大对象直接进入老年代</strong>，其余存活对象进入Survivor(To)区域；</p>
</li>
<li><p>当Survivor(To)区域空间不足时，利用<strong>分配担保机制</strong>，非存活时间长或大对象的存活对象同样被放入老年代中；</p>
</li>
<li><p>清理Eden和Survivor(From)。</p>
</li>
</ol>
<h4 id="2-HotSpot-的算法实现"><a href="#2-HotSpot-的算法实现" class="headerlink" title="2. HotSpot 的算法实现"></a>2. HotSpot 的算法实现</h4><p>（1）在可达性分析算法中，如何快速、精确地找出（枚举）根节点（GC Roots）？</p>
<p>精确：GC进行时停止所有 Java线程，确保分析时引用关系不再变化；</p>
<p>速度：OopMap（Ordinary Object Pointer Map）普通对象指针的Map数据结构，保存对象引用信息。</p>
<p>（2）Safe Point &amp; Safe Region</p>
<blockquote>
<p>安全点：GC中断线程的“位置”</p>
</blockquote>
<h3 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h3><p>重要概念：</p>
<p>（1）在垃圾收集器中，并发（Concurrent）与并行（Parallel）的区别：</p>
<ul>
<li><p>并发：用户进程与垃圾收集进程并发执行。单CPU环境，只能交替执行；多CPU环境，可同时执行。</p>
<blockquote>
<p><em>CMS 在并发标记、清理阶段</em></p>
</blockquote>
</li>
<li><p>并行：用户进程暂停，在多CPU环境中，多条垃圾收集线程可同时执行。</p>
</li>
</ul>
<p>在垃圾收集器中，并发与并行的重要区别在于<strong>前者不用暂停用户进程，后者必须暂停用户进程</strong>，这与常说的线程并发和并行的概念还是有点不同！单核和多核环境只决定了线程能否同时执行。</p>
<p>（2）吞吐量与GC停顿时间的关系</p>
<ul>
<li><p>吞吐量越高，表示CPU利用效率越高</p>
</li>
<li><p>GC停顿时间缩短是以牺牲吞吐量和新生代空间大小换来的</p>
</li>
</ul>
<p>因此，追求更短的 GC停顿时间，适合交互频繁的场景，代价是 CPU利用率下降；追求更高的 CPU利用率，适合计算量大的场景，代价是 GC停顿时间延长。*</p>
<p>（3）Minor GC 和 Full GC</p>
<ul>
<li><p>Minor GC：发生在新生代的垃圾收集动作，GC 频繁且速度快；</p>
</li>
<li><p>Major GC / Full GC：发生在老年代，速度比 Minor GC 慢。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt></p>
<h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p>（1）单线程：单条GC线程完成收集，且必须暂停其它所有用户正常工作线程（中断其它的 Java 线程）；</p>
<p>（2）对于单CPU环境，Serial 没有线程交互开销，最高的单线程收集效率；</p>
<p>（3）Client 模式下默认的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/Serial.jpg" alt></p>
<h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p>（1）多线程：多条GC线程（多核时才可能同时执行），且必须暂停其它所有用户正常工作线程；</p>
<p>（2）除多线程外，ParNew 其余实现与 Serial 相同；</p>
<p>（3）对于单CPU环境，ParNew 存在线程交互开销，效率低于 Serial；</p>
<p>（4）对于多核CPU环境，ParNew 因多线程并行，效率一般高于 Serial；</p>
<p>（5）Server模式下首选的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParNew.jpg" alt></p>
<h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>（1）与 ParNew 在基本实现上相似；</p>
<p>（2）吞吐量优先：在GC停顿时间和CPU效率间平衡选择，不同于 CMS 等收集器追求尽可能短的 GC 停顿时          间；</p>
<p>（3）GC Ergonomics：自适应调节策略。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParallelScavenge.jpg" alt></p>
<h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p>（1）Serial 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p><img src="/2019/11/11/Java学习之虚拟机/SerialOld.jpg" alt></p>
<h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p>（1）Parallel Scavenge 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p>（3）Parallel Scavenge + Parallel Old 组合：吞吐量优先，适合注重吞吐量和CPU资源敏感的场景</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParallelOld.jpg" alt></p>
<h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p>（1）标记 - 清理 算法</p>
<p>（2）突出点：CMS ( Concurrent Mark Sweep ) 收集器在运行期间，<strong>不需要一直中断其它线程</strong>，因此能实现<strong>最短的 GC 停顿时间</strong></p>
<p>（3）分为以下四个步骤：</p>
<ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清理</p>
</li>
</ul>
<p>其中，并发标记 / 并发清理期间，不暂停其它 CPU 核上的线程，耗时较长；初始标记 / 重新标记期间，需要暂停其它所有线程，耗时较短。</p>
<p>（4）CMS 的不足：</p>
<ul>
<li><p>对CPU资源敏感，使吞吐量下降，CPU利用率降低</p>
</li>
<li><p>并发清理阶段其它用户线程产生的“浮动垃圾”须等到下次GC</p>
</li>
<li><p>潜在的 Concurrent Mode Failure 问题</p>
</li>
<li><p>清理算法产生大量空间碎片</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/CMS.jpg" alt></p>
<h4 id="7-G1-Garbage-First-收集器"><a href="#7-G1-Garbage-First-收集器" class="headerlink" title="7. G1( Garbage-First ) 收集器"></a>7. G1( Garbage-First ) 收集器</h4><p>基本原理：Region + 区域回收优先级</p>
<p>(1) 不再使用 新生代 / 老年代 划分，而是使用 <strong>Region</strong> 划分堆内存区域；</p>
<p>(2) G1追踪不同的 Region，并维护 <strong>优先列表</strong>，由此决定优先GC的区域；</p>
<p>(3) 不同的Region之间的对象引用关系保存在 Remembered Set中（新生代与老年代之间亦是）。</p>
<p><em>优点：</em></p>
<ul>
<li><p>更适合多 CPU的环境；</p>
</li>
<li><p>可独自运作，且对寿命不同的对象也采取不同的策略；</p>
</li>
<li><p>无内存碎片；</p>
</li>
<li><p><strong>可预测的暂停</strong>。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/g1.jpg" alt></p>
<p>运行过程如下：</p>
<ol>
<li><p>初始标记：标记GC Roots直接关联的对象；</p>
</li>
<li><p>并发标记：可达性分析，耗时长、与其它 Java线程并发；</p>
</li>
<li><p>最终标记：Remembered Set Logs中数据（记录并发标记阶段的引用变化）与Remembered Set合并；</p>
</li>
<li><p>筛选回收：有选择地确定GC Region。</p>
</li>
</ol>
<h3 id="五、虚拟机类加载"><a href="#五、虚拟机类加载" class="headerlink" title="五、虚拟机类加载"></a>五、虚拟机类加载</h3><p><strong><em>虚拟机将编译得到的字节码文件加载到内存，经连接、解析等过程，得到可直接使用的 Java 类型的过程，称为类加载</em></strong>。</p>
<p><strong><em>程序运行时期进行</em></strong></p>
<h4 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h4><p>类的生命周期如下图</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt></p>
<h5 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h5><p>加载Class文件过程三个动作：</p>
<ol>
<li><p>通过<strong>非数组类</strong>的全限定名获取二进制字节流，但具体的获取途径并未规定（可以从ZIP包、网络、JSP文件等）；</p>
<blockquote>
<p><em>数组类直接由虚拟机加载，不经过类加载器</em></p>
</blockquote>
</li>
<li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</p>
</li>
<li><p>在内存中生成类的访问入口对象 java.lang.Class。</p>
<blockquote>
<p><em>HotSpot 虚拟机将 Class 对象存放在方法区</em></p>
</blockquote>
</li>
</ol>
<h5 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h5><p><img src="/2019/11/11/Java学习之虚拟机/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E6%B5%81%E7%A8%8B.jpg" alt></p>
<blockquote>
<p>符号引用验证发生于解析阶段，说明<strong>类加载过程各项“工作”是按先后顺序开始，但不一定是前一阶段结束才开始后一阶段，不同阶段的“工作”可并行</strong></p>
</blockquote>
<h5 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h5><p>在方法区为<strong>类静态变量</strong>分配内存并初始化为零值，<strong>final</strong>修饰的<strong>类静态常量</strong>赋给定的初值</p>
<h5 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h5><p>（1）符号引用：存放于常量池中的常量，包括：</p>
<ol>
<li><p>类和接口的全限定名；</p>
</li>
<li><p>字段名和描述符；</p>
</li>
<li><p>方法名和描述符。</p>
</li>
</ol>
<p>（2）解析过程：将符号引用解析、翻译，匹配对应的物理内存地址，即直接引用。</p>
<h5 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h5><p>初始化阶段，执行类构造器的 <code>&lt;clinit&gt;()</code> 方法</p>
<blockquote>
<p>类变量赋值语句 &amp;&amp; 静态代码块</p>
</blockquote>
<h4 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h4><p>双亲委派模型的要点：</p>
<ol>
<li><p>子类加载器先请求父类加载器尝试加载；</p>
</li>
<li><p>父类加载器无法加载时，子类加载器再尝试加载；</p>
</li>
<li><p><strong>所有的加载请求首先被启动类加载器处理</strong>。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt></p>
<h3 id="六、并发"><a href="#六、并发" class="headerlink" title="六、并发"></a>六、并发</h3><h4 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h4><blockquote>
<p>定义了<strong>线程共享的变量</strong>从虚拟机内存中被读取或写入的底层实现</p>
<p>线程共享变量：实例字段、静态字段、构成数组对象的元素</p>
</blockquote>
<h4 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1 主内存与工作内存"></a>1.1 主内存与工作内存</h4><ul>
<li><p>工作内存中保存主内存中（共享）变量的拷贝副本；</p>
</li>
<li><p>工作内存中还保存了<strong>线程私有的变量</strong>；</p>
</li>
<li><p>线程对（共享）变量的读写操作必须经过工作内存才可与主内存交互；</p>
</li>
<li><p>线程间（共享）变量值的传递须借助主内存。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<h4 id="1-2-内存间交互"><a href="#1-2-内存间交互" class="headerlink" title="1.2 内存间交互"></a>1.2 内存间交互</h4><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">作用对象</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock</td>
<td align="center">主内存中的变量</td>
<td align="center">锁定状态，线程独占</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">主内存中的变量</td>
<td align="center">解除锁定状态</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">主内存中的变量</td>
<td align="center">将变量值传输至对应的工作内存中</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">工作内存中的变量</td>
<td align="center">read 操作后，将变量值放入工作内存的变量副本中</td>
</tr>
<tr>
<td align="center">use</td>
<td align="center">工作内存中的变量</td>
<td align="center">使用变量值</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">工作内存中的变量</td>
<td align="center">赋值</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">工作内存中的变量</td>
<td align="center">将变量值传输至主内存中</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">主内存中的变量</td>
<td align="center">store 操作后，变量值存入主内存的变量中</td>
</tr>
</tbody></table>
<h4 id="1-3-原子性、可见性和有序性"><a href="#1-3-原子性、可见性和有序性" class="headerlink" title="1.3 原子性、可见性和有序性"></a>1.3 原子性、可见性和有序性</h4><p>（1）原子性</p>
<ol>
<li>read、load、use、assign、store、write 均为原子性的变量操作，实现<strong>基本数据类型的访问和读写操作是原子性的</strong>；</li>
<li>lock 和 unlock 操作，更大范围内实现原子性（<strong>synchronized</strong> 关键字）。</li>
</ol>
<p>（2）可见性</p>
<ol>
<li><strong>volatile</strong> 关键字，<strong>最轻量级的同步机制</strong>，其修饰的变量对所有线程是可见的；</li>
<li>final 关键字；</li>
<li><strong>synchronized</strong> 关键字，同步代码块。</li>
</ol>
<p>（3）有序性</p>
<ol>
<li><em>线程内表现为串行的语义</em> ：在本线程内观察，操作是有序的；</li>
<li><em>指令重排</em> &amp; <em>工作内存与主内存同步延迟</em> ： 从另一个线程观察，被观察线程内的操作是无序的。</li>
</ol>
<h4 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2. Java线程"></a>2. Java线程</h4><blockquote>
<p>线程将进程的<strong>资源分配</strong>和<strong>执行调度</strong>分开，线程共享进程资源（内存地址、文件I/O等），线程独立被CPU调用、执行。</p>
</blockquote>
<p>实现线程的三种方式：内核线程实现、用户线程实现、用户线程加轻量级进程的混合实现。</p>
<h5 id="2-1-内核线程实现"><a href="#2-1-内核线程实现" class="headerlink" title="2.1 内核线程实现"></a>2.1 内核线程实现</h5><p><em>内核线程（Kernel-Level Thread, KLT）*：由操作系统内核完成线程切换、调度、任务映射等操作，用户程序通过 *轻量级进程 （Light Weight Process, LWP)</em> 接口使用内核线程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：系统调用代价高</p>
</blockquote>
<h5 id="2-2-用户线程实现"><a href="#2-2-用户线程实现" class="headerlink" title="2.2 用户线程实现"></a>2.2 用户线程实现</h5><p><em>用户线程（User Thread, UT）</em> ：建立在用户空间的线程库，用户线程的建立、同步、调度和销毁在用户态中完成。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：用户态操作，代价小；实现过程异常复杂。</p>
</blockquote>
<h5 id="2-3-用户线程加轻量级进程的混合实现"><a href="#2-3-用户线程加轻量级进程的混合实现" class="headerlink" title="2.3 用户线程加轻量级进程的混合实现"></a>2.3 用户线程加轻量级进程的混合实现</h5><blockquote>
<p>轻量级进程是用户线程与内核线程之间的桥梁</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] 《深入理解Java虚拟机》周志明 著</p>
<p>[2] <a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p>
<p>[3] <a href="https://blog.csdn.net/wen7280/article/details/54428387" target="_blank" rel="noopener">https://blog.csdn.net/wen7280/article/details/54428387</a></p>
<p>[4] <a href="https://www.jianshu.com/p/114bf4d9e59e" target="_blank" rel="noopener">https://www.jianshu.com/p/114bf4d9e59e</a></p>
<p>[5] <a href="https://www.jianshu.com/p/50d5c88b272dc" target="_blank" rel="noopener">https://www.jianshu.com/p/50d5c88b272dc</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码阅读笔记</title>
    <url>/2019/09/05/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于JDK 1.8的HashMap阅读笔记，主要包括如下方面：</p>
<ul>
<li>HashMap的属性、构造方法及常用方法源码分析。</li>
<li>自定义的类，如何确保Key的一致性？</li>
<li>HashMap在JDK 1.8与JDK 1.7中的差异。</li>
</ul>
<a id="more"></a>

<h4 id="1-HashMap的概述"><a href="#1-HashMap的概述" class="headerlink" title="1. HashMap的概述"></a>1. HashMap的概述</h4><ul>
<li>HashMap允许空的键和空的值，是线程不安全的。Hashtable不允许空的键和空的值，是线程安全的。</li>
<li>HashMap不保证有序。</li>
<li>如果迭代性能很重要，则不要将初始容量设置得过高（或负载因子过低）。</li>
<li>多线程结构修改时（添加或删除键值对）必须保证同步，如Collections.synchronizedMap方法返回一个同步的Map。</li>
</ul>
<hr>
<h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h4><h5 id="2-1-类的静态属性"><a href="#2-1-类的静态属性" class="headerlink" title="2.1 类的静态属性"></a>2.1 类的静态属性</h5><p>（1）<strong>初始容量</strong>：16，且必须为2的幂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap规定哈希数组的容量为2的次幂。设n为容量。当n为2的幂时，转化成二进制为：100…00。在计算索引时（hash&amp;(n-1)），n-1为：011…11。</p>
<p>对于小于n-1的哈希值，索引位置就是哈希值；对于大于n-1的哈希值，索引位置就是取模。</p>
<p>因此，在获取索引时提高了与运算的速度，且保证了散列的均匀性。</p>
</blockquote>
<p>（2）<strong>最大容量</strong>：2^30 且应该为2的次幂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：那最大容量为什么不是 <code>1 &lt;&lt; 31</code> 呢？<code>1 &lt;&lt; 31</code> 的结果是-2147483648。</p>
<p>那最大容量为什么不是 <code>Integer.MAX_VALUE</code> ，即 <code>2^31 - 1</code> 呢？规定哈希数组的容量为2的幂。</p>
</blockquote>
<p>（3）<strong>默认负载因子</strong>：选择0.75是空间与时间的均衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>（4）<strong>链表转树的阈值</strong>：当链表结点个数达到TREEIFY_THRESHOLD时，链表转换为红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：为什么选择8？</p>
<p>理想情况下使用随机的哈希值，节点分布在桶中的频率遵循泊松分布。按照泊松分布的计算可以明确，链表中元素个数达到8时，其概率已经很低。因此，选择8是根据概率计算得到的一个合适的值，它既不会使链表长度不足，又不是令其太长。</p>
</blockquote>
<p>（5）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>哈希表容量达到MIN_TREEIFY_CAPACITY时，才允许链表转换成红黑树。</p>
<ul>
<li>MIN_TREEIFY_CAPACITY不小于TREEIFY_THRESHOLD的4倍。</li>
<li><strong>若哈希表容量不足MIN_TREEIFY_CAPACITY，而桶内元素又太多时，直接扩容</strong>。</li>
</ul>
<p>（6）<strong>树转链表的阈值</strong>：扩容时，原红黑树内结点数量不大于UNTREEIFY_THRESHOLD时，红黑树转换为链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-成员属性"><a href="#2-2-成员属性" class="headerlink" title="2.2 成员属性"></a>2.2 成员属性</h5><p>（1）<strong>modCount</strong>：记录哈希表的结构修改次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>使用迭代器时，若调用HashMap的remove()方法试图删除元素时，会抛出ConcurrentModificationException异常（fail-fast策略）。</p>
<p>其底层实现正是基于modCount属性。</p>
<p>每一次对HashMap对象<strong>结构的修改</strong>，modCount加1。在迭代器初始化时，会将该值赋予迭代器的expectedModCount变量。迭代过程中，如调用迭代器的next()方法，会调用checkForComodification()方法以检查modCount是否等于expectedModCount。若是，则正常；若否，则抛出异常。</p>
<p>因此，在使用迭代器时，必须使用迭代器的remove()方法移除集合元素。这一过程的本质是迭代器对象调用集合的remove()方法<strong>并将被修改的modCount值重新赋予expectedModCount变量</strong>，使二者保持一致。</p>
<hr>
<h4 id="3-节点内部类"><a href="#3-节点内部类" class="headerlink" title="3. 节点内部类"></a>3. 节点内部类</h4><p>（1）Node静态内部类：数组元素和链表节点。</p>
<blockquote>
<p>JDK 1.7中为Entry类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断两个Entry是否相等，仅当key和value均相等时，返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）TreeNode静态内部类：红黑树的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*其它方法略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h4><p>HashMap中的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>; <span class="comment">// 默认负载因子，0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>; <span class="comment">// 默认的初始容量，16；默认的负载因子，0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（1）使用指定的初始容量和负载因子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量大于最大容量时，将其置为最大容量。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 大于initialCapacity且最接近的2的次幂。</span></span><br><span class="line"><span class="comment">     * 随后扩容阈值还是会被重新计算。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>threshold：需要扩容时的阈值，在此先对其调用 tableSizeFor()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法返回的是一个<strong>大于形参且最接近的2的幂的值</strong>。<strong>创建哈希表时，threshold阈值会重新赋值</strong>。</p>
<p>（2）其它构造函数</p>
<p>都是调用第一种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用与指定Map相同的映射构造一个新的HashMap</p>
<p>此构造方法使用与指定Map相同的映射构造一个新的HashMap。 使用默认的加载因子（0.75）和足以将映射保存在指定Map中的初始容量创建HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将指定Map中的键值对复制进HashMap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>; <span class="comment">// 重新计算初始容量</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5. put方法"></a>5. put方法</h4><p>HashMap的put方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）首先看计算key哈希值的方法：</p>
<ul>
<li><p>当key为null时，哈希值为0；</p>
</li>
<li><p>否则，调用Object基类的native的hashCode()方法，且将哈希值的高16位做异或运算。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：为什么要对高16位做异或运算？</p>
<p>putVal方法中的第二个if语句，p = tab[i = (n - 1) &amp; hash] 。我们是根据key的哈希值来保存在散列表中的，我们表默认的初始容量是16，要放到散列表中，就是0-15的位置上。也就是<code>tab[i = (n - 1) &amp; hash]</code>。</p>
<p>可以发现的是：在做<code>&amp;</code>运算的时候，仅仅是<strong>后4位有效</strong>。那如果我们key的哈希值高位变化很大，低位变化很小。直接拿过去做<code>&amp;</code>运算，这就会导致计算出来的Hash值相同的很多，即哈希冲突严重。使用异或运算，向下传播较高位的影响，，否则由于表范围的限制，这些位将永远不会在索引计算中使用。</p>
</blockquote>
<p><em>详细解析如下：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设现有键A和键B，通过调用hashCode方法计算得到的hash分别为:</span><br><span class="line">A: 1111 1111 1111 0000 0000 0000 0000 0001</span><br><span class="line">B: 0000 0000 0000 1111 1111 1111 1111 0001</span><br><span class="line">假设底层数组长度为8，即n=7，二进制表示为：</span><br><span class="line">n: 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line"></span><br><span class="line">对A和n做&amp;运算得：</span><br><span class="line">   0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line">对B和n做&amp;运算得：</span><br><span class="line">   0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line">可见，虽然A和B的hash相差甚远，但是它们还是被分入同一个桶中。</span><br></pre></td></tr></table></figure>

<p>当有大量的<strong>高位变化明显、但低位不变化</strong>的hash结果时，会造成哈希冲突严重，使得散列不均匀。</p>
<p>为了解决这一问题，采用<strong>用key的哈希值的高16位与其自身做异或运算</strong>的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先对A和A的高16位做异或运算，再与n做与运算：</span><br><span class="line">  1111 1111 1111 0000 0000 0000 0000 0001</span><br><span class="line">^ 0000 0000 0000 0000 1111 1111 1111 0000</span><br><span class="line">  1111 1111 1111 0000 1111 1111 1111 0001</span><br><span class="line">&amp; 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">  0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line"></span><br><span class="line">对B和B的高16位做异或或运算，再与n做与运算：</span><br><span class="line">  0000 0000 0000 1111 1111 1111 1111 0001</span><br><span class="line">^ 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">  0000 0000 0000 1111 1111 1111 1111 1110</span><br><span class="line">&amp; 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">  0000 0000 0000 0000 0000 0000 0000 0110 = 6</span><br></pre></td></tr></table></figure>

<p>经过处理，A和B对应的Node元素将存入数组tab的不同索引！</p>
<p>因此，hash(Object key)方法的目的在于：对于HashMap这种数组总长度一般不大（一般小于2^16）的情形，将哈希值高位的变化传递至低位，使得散列更加均匀。</p>
<p>至于为什么选择 <code>^</code> ？这是因为相较于 <code>&amp;</code> 和 <code>|</code> ，<code>^</code> 得到1/0的概率均为50%，更加符合hash算法设计的初衷。</p>
<p>（2）调用putVal方法</p>
<ul>
<li>hash：key的哈希值</li>
<li>key：键</li>
<li>value：待插入的值</li>
<li>onlyIfAbsent：true - 不更新已存在的旧值；false - 更新已存在的旧值</li>
<li>evict：false - 哈希表处于创建模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 散列表不存在或散列表长度为0时，调用resize()方法以初始化哈希表。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 当对应的桶为空时，新建一个Node结点，并将其放入桶中。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 对应的桶不为空，即桶中至少有一个元素。桶中链表的头结点指针此时为p。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 判断数组tab存储的是否为同一个key元素，若是则通过变量e记录之，</span></span><br><span class="line"><span class="comment">         * 以便在下面的代码中用新值value覆盖旧值。</span></span><br><span class="line"><span class="comment">         * 通过分别验证hashCode相等和key相等来保证key的唯一性。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果结点p为红黑树结点，则调用数的插入方法插入。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * key不是桶中链表的头结点，则沿链表寻找对应的结点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 未找到结点，在链表尾部插入新结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 插入新结点后，链表长度达到链转树的阈值时，链表转换为红黑树。</span></span><br><span class="line"><span class="comment">                     * TREEIFY_THRESHOLD-1：减去头结点。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到对应的结点，使用指针p记录该结点。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用新值更新旧值，并返回旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 记录对HashMap结构上的修改次数</span></span><br><span class="line">    <span class="comment">// 哈希表的尺寸超过扩容阈值，执行扩容操作。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：计算哈希数组的下标位置，为何要使用tab[i = (n - 1) &amp; hash]的操作？直接使用哈希值作为数组的索引不行吗？</p>
<p>答：Object类的hashCode()方法是根据<strong>对象的内存地址经特定算法计算得到的整型参数</strong>，其范围广。HashMap的容量一般不大，显然不合适。</p>
<p>在HashMap中，与运算是根据其容量大小，<strong>取哈希值一定数量的低位作为下标</strong>，其本质是将哈希值对容量取模。</p>
<p>以上，包括对哈希值进行异或运算和与运算，其核心目的都是为了使哈希过程随机化和均匀化，避免过度的哈希冲突。</p>
</blockquote>
<p>（3）key的一致性</p>
<p>在putVal方法中，判断key是否相同时，使用了如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))</span><br></pre></td></tr></table></figure>

<p>首先来看Object基类的equals(Object obj)方法，根据 JDK 1.8的API文档，其有如下特性：</p>
<ul>
<li>自反性：对任何非空的 x，x.equals(x) 返回true；</li>
<li>对称性：对任何非空的 x 和 y，当且仅当 x.equals(y) 返回 true 时，y.equals(x) 才返回true；</li>
<li>传递性：对任何非空的 x、y 和 z，若 x.equals(y) 和 y.equals(z) 均返回true，x.equals(z) 也应该返回true；</li>
<li>一致性：对任何非空的 x 和 y，若未加修改，那么多次调用 x.equals(y) 方法，返回结果均保持一致。</li>
<li>对任何非空的 x，x.equals(null) 应返回false。</li>
<li>对任何非空的 x 和 y，当且仅当 x 和 y 引用相同的对象（即 x==y）时，x.equals(y) 方法才返回true。可见，基类Object的equals方法本质上是<strong>内存地址比较</strong>。</li>
</ul>
<p>再来看看Object类的hashCode()方法，它有如下约定：</p>
<ul>
<li>对同一个对象多次调用，返回相同的哈希值；</li>
<li>equals方法返回true的两个对象，应返回相同的哈希值；</li>
<li>equals方法返回false的两个对象，对返回的哈希值没有明确要求，可相同也可不相同。</li>
</ul>
<p>综上，关于equals方法和hashCode方法有一个重要的约定：<strong>equals方法返回true时，hashCode方法返回相同的哈希值。</strong></p>
<p><strong><em>那么，对于自定义的 key类，如何保证 key的一致性呢？</em></strong></p>
<blockquote>
<p>结论：重写equals和hashCode方法，以满足上述约定。</p>
</blockquote>
<p><em>坏例子</em></p>
<p>自行定义一个 Key 的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get/set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立 HashMap 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stA和stB指向的均为同一个人</span></span><br><span class="line">    Student stA = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="string">"007"</span>);</span><br><span class="line">    Student stB = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="string">"007"</span>);</span><br><span class="line">    HashMap&lt;Student, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(stA, <span class="number">97</span>);</span><br><span class="line">    map.put(stB, <span class="number">75</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;Student@<span class="number">15</span>db9742=<span class="number">97</span>, Student@<span class="number">6</span>d06d69c=<span class="number">75</span>&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>stA</code> 和 <code>stB</code> 指向同一个对象，二者的 <code>key</code> 应该是相同的，但输出结果表明二者的 <code>key</code> 是不同的。</p>
<p>在HashMap的源码中，是<strong>通过比较hash相等和key相等来保证key的一致性的</strong>。对于Student类，其equals方法实际上调用的是Object基类的equals方法，即比较 <code>stA</code> 和 <code>stB</code> 的<strong>内存地址</strong>。</p>
<p>显然，<code>stA</code> 和 <code>stB</code> 表明同一个人，是指其name和id属性共同确定了张三这个人，但是二者的内存地址是不同的。在这里，我们比较key是否一致，应由name和id属性共同决定！</p>
<p>对于自定义的Key类，应保证<strong>重写equals方法和hashCode方法</strong>，以满足二者的约定条件，保证Key的一致性。</p>
<p><em>重写 Student 类的 equals 方法，使其实现比较 name 和 id 属性是否为相同的字符串。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass()!=obj.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Student otherObj = (Student) obj;</span><br><span class="line">    <span class="keyword">if</span>(name==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(otherObj.name!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!name.equals(otherObj.name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(otherObj.id!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!id.equals(otherObj.id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>重写 Student 类的 hashCode 方法，使其符合 equals 方法返回 true 则返回相同哈希值的约定。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ((name==<span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    result = prime * result + ((id==<span class="keyword">null</span>) ? <span class="number">0</span> : id.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;Student@<span class="number">16f</span>482f=<span class="number">75</span>&#125;</span><br></pre></td></tr></table></figure>

<p>保证了 Key 的一致性！</p>
<hr>
<h4 id="6-resize方法"><a href="#6-resize方法" class="headerlink" title="6. resize方法"></a>6. resize方法</h4><p>final修饰的resize()方法：初始化和扩容时使用。</p>
<ul>
<li>初始化时，将哈希表的初始容量设置为16，扩容阈值设置为12。</li>
<li>扩容时，新表的容量和扩容阈值均被设置为旧表的2倍。</li>
<li>当旧表容量超过最大容量（2^30）时，无法扩容。只能将扩容阈值设为整型最大值（2^31 - 1）,并返回旧的哈希表。</li>
<li>JDK 1.8 开始，向链表中插入结点的方式由头插法（JDK 1.7）修改为尾插法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/***当前旧的哈希表容量大于0***/</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 旧的哈希表容量已超过最大容量（2^30），无法扩容。</span></span><br><span class="line"><span class="comment">         * 只能将扩容阈值设为整型最大值（2^31 - 1）,并返回旧的哈希表。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新表的容量和扩容阈值均被设为旧表的2倍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***当前旧的哈希表容量等于0***/</span></span><br><span class="line">    <span class="comment">// 旧表的扩容阈值大于0，将新表的容量设为该值，新表的扩容阈值设置在第34行。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化表，表的容量设为默认值，为16；表的扩容阈值默认为12。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 构建新的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***拷贝旧表至新表的操作***/</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 桶中仅有一个结点时，计算在新表中的索引。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 循环过程实现了将Head和Tail指针分别指向链表的头尾结点。</span></span><br><span class="line"><span class="comment">                     * loHead和loTail表示结点在新表中的索引与旧表一致；</span></span><br><span class="line"><span class="comment">                     * hiHead和hiTail表示结点在新表中的索引为旧表索引+旧表容量</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+旧容量</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 新数组中的存储位置：原索引</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 新数组中的存储位置：原索引+旧容量</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容后，确定新的哈希数组中的索引的机制：</p>
<ul>
<li>扩容后，哈希表的容量为旧表的2倍。</li>
<li>重新依据hashCode &amp; (n-1)计算索引时，哈希值不变、n增大为2倍，<strong>导致最终的计算结果多了一位</strong>。<ul>
<li>哈希值对应的位为0，则新增的1对与运算结果无影响，新索引 = 旧索引；</li>
<li>哈希值对应的位为1，则新增的1对与运算结果有影响，新索引 = 旧索引+旧表容量。</li>
</ul>
</li>
</ul>
<p><strong>JDK 1.8中重新确定新的哈希数组索引的机制，相较于JDK 1.7有什么异同？</strong></p>
<ul>
<li>本质：<strong>二者相同</strong>。即JDK 1.8若重新计算hashCode，再进行与操作，得到的结果是不变的，即新索引 = 旧索引或者新索引 = 旧索引+旧表容量。</li>
<li>性能：重新计算key的哈希值需要消耗一定的性能，而JDK 1.8只需要执行一次与操作就能得到结果，显然后者更快。</li>
</ul>
<p><strong>JDK 1.7形成环状链表的风险？</strong></p>
<p>JDK 1.7在扩容时，将旧数组上的数据转移至新数组的过程中，其操作为<strong>按旧链表正序遍历，在新的桶中以头插法存入新节点</strong>。这种操作易导致<strong>链表逆序</strong>。</p>
<p>多线程并发扩容时，容易造成环形链表，导致遍历链表时形成死循环（Infinite Loop）。</p>
<p>JDK 1.8采用尾插法，避免上述问题。但需要明确的是，在JDK .18中，<strong>HashMap仍然是线程不安全的类</strong>。</p>
<hr>
<h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7. get方法"></a>7. get方法</h4><p>get(Object key)方法可返回指定key的值。若指定的key不存在或<strong>显式地为null</strong>，返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法调用getNode方法，沿链表或红黑树查找与key一致的节点。关于如何保证key的一致性，前已述及。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-remove方法"><a href="#8-remove方法" class="headerlink" title="8. remove方法"></a>8. remove方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用removeNode()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点在桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 链表头节点即是目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 头节点不是目标节点，首先判断是否已经树化，随后去树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 尚未树化，遍历链表，锁定目标节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// 修改集合结构的操作，触发modCount值变化</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-containsKey方法"><a href="#9-containsKey方法" class="headerlink" title="9. containsKey方法"></a>9. containsKey方法</h4><p>调用getNode方法，当key不存在或显式的为null时，皆返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-treeifyBin方法"><a href="#10-treeifyBin方法" class="headerlink" title="10. treeifyBin方法"></a>10. treeifyBin方法</h4><p>链表转换为红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只有当哈希表容量不小于MIN_TREEIFY_CAPACITY，链表才能转换为红黑树，</span></span><br><span class="line"><span class="comment">     * 否则，只能扩容处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-HashMap在JDK-1-7与JDK-1-8中的区别"><a href="#11-HashMap在JDK-1-7与JDK-1-8中的区别" class="headerlink" title="11.  HashMap在JDK 1.7与JDK 1.8中的区别"></a>11.  HashMap在JDK 1.7与JDK 1.8中的区别</h4><table>
<thead>
<tr>
<th align="center">不同点</th>
<th align="center">JDK 1.7</th>
<th align="center">JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">节点实现类</td>
<td align="center">Entry&lt;K, V&gt;</td>
<td align="center">Node&lt;K, V&gt;，TreeNode&lt;K, V&gt;</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">数组+链表</td>
<td align="center">数组+链表+红黑树</td>
</tr>
<tr>
<td align="center">计算key的哈希值</td>
<td align="center">4次位运算+5次异或运算</td>
<td align="center">1次位运算+1次异或运算</td>
</tr>
<tr>
<td align="center">链表节点插入方式</td>
<td align="center">尾插法</td>
<td align="center">头插法</td>
</tr>
<tr>
<td align="center">初始化方式</td>
<td align="center">单独的inflateTable方法</td>
<td align="center">集成在resize方法中</td>
</tr>
<tr>
<td align="center">扩容时计算新索引</td>
<td align="center">重新计算（慢）</td>
<td align="center">原索引或原索引+旧容量（快）</td>
</tr>
</tbody></table>
<hr>
<h4 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h4><p>基于JDK 1.8版本的HashMap。</p>
<ul>
<li><p>HashMap的初始容量默认为16，最大容量为2^30，且容量一定是2的幂。</p>
</li>
<li><p>链表转红黑树的条件：哈希表的总节点数大于或等于MIN_TREEIFY_CAPACITY（默认：64），且链表的节点数大于或等于TREEIFY_THRESHOLD（默认：8）。</p>
</li>
<li><p>HashMap真正初始化哈希表（即初始化哈希数组<code>table</code>）是在首次添加键值对，即首次调用put方法时，且真正的初始化方法集成在resize方法中。在JDK 1.7版本中，初始化哈希表是在首次调用put方法，且哈希数组为null的情况下，直接调用inflateTable方法。</p>
</li>
<li><p>在计算key的哈希值时，采用高16位异或运算，是为了将高16位的变化引入低16位，使散列更加均匀。</p>
</li>
<li><p>对于自定义的key类，应重写equals和hashCode方法，使其满足约定。</p>
</li>
<li><p>HashMap允许null的键，是因为当key为null时，哈希值为0。因此，HashMap仅允许一个键为null。</p>
</li>
<li><p>扩容时，若旧表容量超过最大值，不扩容；成功扩容后，新表容量和阈值均为旧表的2倍。</p>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.jianshu.com/p/d4fee00fe2f8" target="_blank" rel="noopener">HashMap源码解析</a></p>
<p>[2] <a href="https://www.jianshu.com/p/2c1491d866f7" target="_blank" rel="noopener">HashMap就是这么简单【源码剖析】</a></p>
<p>[3] <a href="https://blog.csdn.net/weixin_41888813/article/details/99715799" target="_blank" rel="noopener">如何将自定义的类对象作为key存储到HashMap中？</a></p>
]]></content>
      <categories>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Sound Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC框架学习笔记</title>
    <url>/2019/08/26/Spring%20MVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><strong>MVC模式</strong></p>
<blockquote>
<p>Model：数据模型层，封装用户的输入/输出数据</p>
<p>Controller：控制层，前、后端交互</p>
<p>View：视图层，前端显示</p>
</blockquote>
<hr>
<h4 id="1-Spring-MVC流程"><a href="#1-Spring-MVC流程" class="headerlink" title="1. Spring MVC流程"></a>1. Spring MVC流程</h4><p>Spring MVC框架流程图如下，其中最核心的是<strong>前端控制器（DispatcherServlet）</strong></p>
<p>![](Spring MVC框架学习笔记/Spring MVC框架流程图.png)</p>
<p><em>流程描述如下：</em></p>
<ol>
<li><p>用户请求被拦截、发送至前端控制器（DispatcherServlet）；</p>
</li>
<li><p>DispatcherServlet请求处理器映射器（HandlerMapping）查找相应的处理器（Handler），HandlerMapping将Handler、Intercepter（拦截器）返回给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet根据返回的Handler，请求处理器适配器（HandlerAdapter）执行Handler；</p>
</li>
<li><p>HandlerAdapter调用自己的Handler方法，利用 Java的<strong>反射机制</strong>执行具体的Controller方法，获得ModelAndView 视图对象；</p>
</li>
<li><p>HandlerAdapter将ModelAndView 视图对象发送给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet请求视图处理器（ViewResolver）解析，返回结果；</p>
</li>
<li><p>DispatcherServlet渲染视图，<strong>将Model中的模型数据填充到View视图的Request域</strong>，生成最终的View视图；</p>
</li>
<li><p>DispatcherServlet发送Response响应至用户界面。</p>
</li>
</ol>
<h4 id="2-DispatcherServlet"><a href="#2-DispatcherServlet" class="headerlink" title="2. DispatcherServlet"></a>2. DispatcherServlet</h4><p>DispatcherServlet是Spring MVC处理Http请求的核心组件：</p>
<p>（1）其顶级父类是HttpServlet，因此DispatcherServlet本质上是一个Servlet；</p>
<p>（2）其中的doService方法负责处理request请求；</p>
<p>（3）核心方法<strong>doDispatch</strong>负责处理拦截，转发请求，调用处理器获得结果，并得到结果视图。</p>
<p>web.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用配置的springmvc.xml文件对DispatcherServlet进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置拦截url符合".action"的请求至前端处理器DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-HandlerMapping"><a href="#3-HandlerMapping" class="headerlink" title="3. HandlerMapping"></a>3. HandlerMapping</h4><p>HandlerMapping常见有：BeanNameUrlHandlerMapping、SimpleUrlHandlerMapping、ControllerClassNameHandlerMapping。</p>
<p>Springmvc.xml配置如下</p>
<p>（1）BeanNameUrlHandlerMapping</p>
<p>映射规则：将bean的name作为url进行匹配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器BeanNameUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置被url映射的Handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/test.action"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）SimpleUrlHandlerMapping</p>
<p>通过<property>标签配置url与handler的映射关系</property></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器SimpleUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_A"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_B"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Handler --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA.action"</span>&gt;</span>ControllerTestA<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB.action"</span>&gt;</span>ControllerTestB<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）ControllerClassNameHandlerMapping</p>
<p>采用CoC惯例优先原则</p>
<ul>
<li><p>对普通的Controller类，将类名“xxxController”映射至“/xxx*”的请求url</p>
</li>
<li><p>对MultiActionController（多动作控制器）类，会将特定的方法“yyy”映射至“/xxx/yyy.action”的请求url</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerBeanNameHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-HandlerAdapter"><a href="#4-HandlerAdapter" class="headerlink" title="4. HandlerAdapter"></a>4. HandlerAdapter</h4><p>（1）SimpleControllerHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>SimpleControllerHandlerAdapter要求编写实现Controller接口的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	modelAndView.addObject();</span><br><span class="line">	modelAndView.setViewName();</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）HttpRequestHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>HttpRequestHandlerAdapter要求编写实现<strong>HttpRequestHandler接口</strong>的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.HttpRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">	request.setAttribute();</span><br><span class="line">	request.getRequestDispatcher();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpRequestHandlerAdapter与 SimpleControllerHandlerAdapter相比优点在于：</em></strong></p>
<ul>
<li>前者可以通过request获得http请求信息，及设置返回对象response的格式，如 JSON串！</li>
</ul>
<h4 id="5-注解方式使用HandlerMapping和HandlerAdapter"><a href="#5-注解方式使用HandlerMapping和HandlerAdapter" class="headerlink" title="5. 注解方式使用HandlerMapping和HandlerAdapter"></a>5. 注解方式使用HandlerMapping和HandlerAdapter</h4><p>“但是这种开发模式有一个缺点，<strong>一个Handler类中只能编写一个方法</strong>“”。</p>
<p>注：上面原话来自于《Spring MVC+Mybatis开发从入门到项目实战》p151。但是对这句话的理解产生了歧义！如MultiActionController类中就能编写多个处理方法。</p>
<p>改成：<strong>一个Handler类中一般只能编写一个处理方法</strong>。</p>
<blockquote>
<p>通过注解的方式，可以在单个Handler中通过@RequestMapping注解方式配置多个方法！</p>
</blockquote>
<p>（1）配置方式</p>
<p>使用默认的注解的映射器和适配器</p>
<blockquote>
<p>Spring MVC使用的默认注解的映射器和适配器是<strong>RequestMappingHandlerMapping</strong>和<strong>RequestMappingHandlerAdapter</strong></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者手动注明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）编写Handler类</p>
<p>此时，Handler不需要实现Controller接口或者HttpRequestHandler：</p>
<p><strong>@Controller</strong>：标明Handler控制器类</p>
<p><strong>@RequestMapping</strong>：将url请求映射至Handler类中特定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin.ssm.</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/queryMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/deleteMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）配置Handler类的bean</p>
<p>逐个Handler类配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或扫描指定包下所有@Controller注解的Handler类（推荐）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin.ssm.controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Handler"><a href="#6-Handler" class="headerlink" title="6. Handler"></a>6. Handler</h4><h5 id="6-1-请求映射-RequestMapping注解"><a href="#6-1-请求映射-RequestMapping注解" class="headerlink" title="6.1 请求映射@RequestMapping注解"></a>6.1 请求映射@RequestMapping注解</h5><p>（1）请求路径</p>
<ol>
<li><p>类上注解@RequestMapping：请求域，相对Web应用根目录，表示此Handler所有方法的请求路径均在此路径下；</p>
</li>
<li><p>方法上注解@RequestMapping：相对于请求域路径。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求URL为：http://localhost:8080/"WebProjectName"/RequestArea/test.action</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"RequestArea"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerDemo</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）限定请求</p>
<blockquote>
<p>只能在方法上@RequestMapping实现</p>
</blockquote>
<ol>
<li><p>限制请求方法：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</p>
<p>@RequestMapping(value=”/test”, method=RequestMethod.GET)  // 限制请求方法为GET</p>
</li>
<li><p>限制请求参数：</p>
<p>@RequestMapping(value=”/test”, params=”username”) // 限制请求参数中必须含参数“username”</p>
</li>
<li><p>限制请求头：</p>
<p>@RequestMapping(value=”/test”, headers=”Content-Type:text/html;charset=”utf-8”)</p>
</li>
</ol>
<h5 id="6-2-参数绑定"><a href="#6-2-参数绑定" class="headerlink" title="6.2 参数绑定"></a>6.2 参数绑定</h5><p>（1）可直接绑定的类型：HttpRequest、HttpResponse、HttpSession、Model、ModelMap</p>
<p>（2）简单参数</p>
<ul>
<li><p>value：查询结果字段名 user_id 与 Java实体类中成员变量名 userId 可以不一致；</p>
</li>
<li><p>defaultValue：默认值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=&#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryDemo</span><span class="params">(Model model,@RequestParam(value=<span class="string">"user_id"</span>,defaultValue=<span class="string">"1"</span>)</span> Integer userId)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）绑定包装类</p>
<p>Spring MVC会完成创建相应的实体类 Fruit 并使用set方法注入属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/queryFruitsByCondition"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryFruitsByCondition</span><span class="params">(Model model,Fruit fruit)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）绑定集合</p>
<h4 id="7-视图解析器"><a href="#7-视图解析器" class="headerlink" title="7. 视图解析器"></a>7. 视图解析器</h4><h5 id="7-1-Spring-MVC中的视图解析器"><a href="#7-1-Spring-MVC中的视图解析器" class="headerlink" title="7.1 Spring MVC中的视图解析器"></a>7.1 Spring MVC中的视图解析器</h5><p>（1）AbstractCachingViewResolver</p>
<p>抽象类，定义了视图解析器<strong>缓存</strong>已解析视图的方法。</p>
<p>（2）UrlBasedViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存功能；</p>
</li>
<li><p>前缀属性prefix指定视图资源所在路径的前缀，后缀属性suffix指定视图资源所在路径的后缀；</p>
</li>
<li><p>支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀prefix属性指定了视图资源所在路径的前缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀suffix属性指定了视图资源所在路径的后缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解析至指定的视图，此处用来展示jsp页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>InternalResourceView类在服务器端通过<em>跳转</em> 的方式访问不能直接访问的/WEB-INF/目录下的资源</p>
<p><strong>（3）InternalResourceViewResolver</strong></p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存功能 + 支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>viewClass指定为InternalResourceView，因此不支持解析为其它视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体实现实例如下：</p>
<p>对于UserController类，其实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	定义toLogin()方法，处理拦截器传来的重定向至登录</span></span><br><span class="line"><span class="comment">	 *	页面的请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/user/toLogin.action"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/login.jsp"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器返回一个ModelAndView对象，InternalResourceViewResolver将名为“login.jsp”的<strong>视图View</strong>解析成一个InternalResourceView对象后，并将返回的model模型属性信息存放到对应的HttpRequest属性中，最后利用<strong>RequestDispatcher</strong>将请求<strong>跳转</strong>至资源“/WEB-INF/pages/login.jsp”。</p>
<p>（4）BeanNameViewResolver</p>
<ol>
<li><p>不继承 AbstractCachingViewResolver，因而无缓存视图的能力；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>在springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将此视图解析器的优先级设为高 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"toLogin"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Controller层返回名为“toLogin”<strong>（即类型为InternalResourceView的bean的id）</strong>的逻辑视图时，类似的，视图解析器BeanNameViewResolver将该视图解析为<strong>InternalResourceView对象</strong>，并跳转至指定资源。</p>
<p>（5）XmlViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>类似于BeanNameViewResolver，只是InternalResourceView类型的bean的配置信息单独配置在views.xml文件中；</p>
</li>
<li><p><strong>对views.xml存放位置无要求</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.XmlViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定路径下的配置文件/WEB-INF/views.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;bean id="</span><span class="attr">toLogin</span>" <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（6）ResourceBundleViewResolver</strong></p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>视图资源文件为properties属性文件，且必须<strong>位于classpath根目录下</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ResourceBundleViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定视图资源文件名为viewResource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"viewResource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>视图视图资源文件为viewResource，路径必须为”classpath:viewResource.properties”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.(class)=org.springframework.web.servlet.view.InternalResourceView</span><br><span class="line">login.url=/WEB-INF/pages/login.jsp</span><br></pre></td></tr></table></figure>

<p>（7）FreeMarkerViewResolver</p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存；</p>
</li>
<li><p>指定解析后的视图类型为<strong>FreeMarkerView</strong>；</p>
</li>
<li><p>得到的模板文件，可输出为多种文本文档，如HTML、XML、RTF等。</p>
</li>
</ol>
<p>首先在springmvc.xml中配置该视图解析器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"fm_"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".html"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随后仍在springmvc.xml中配置FreeMarkerView类生成的最终视图模板的位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/freemarker/template"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置的视图模板路径下，新建 “fm_freemarker.html” 的模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarkerView<span class="tag">&lt;/<span class="name">title</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 取出数据放入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（8）VelocityViewResolver</p>
<ol>
<li><p>与FreeMarkerViewResolver相似</p>
</li>
<li><p>extends UrlBasedViewResolver；</p>
</li>
<li><p>指定解析后的视图类型为VelocityView。</p>
</li>
</ol>
<h5 id="7-2-视图解析器链-ViewResolverChain"><a href="#7-2-视图解析器链-ViewResolverChain" class="headerlink" title="7.2 视图解析器链 ViewResolverChain"></a>7.2 视图解析器链 ViewResolverChain</h5><p>（1）ViewResolver 实现 Ordered 接口，order属性明确了视图解析器链中不同视图解析器的优先级；</p>
<p>（2）<strong>order越小，优先级越高</strong>；</p>
<p>（3）解析视图时，先从优先级高的解析器开始，若不能解析，则找下一优先级的解析器，若均不能解析，则返回一个null的View对象，抛异常；</p>
<p>（4）<strong>InternalResourceViewResolver可解析任意视图</strong>。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1]《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架学习笔记</title>
    <url>/2019/08/22/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><em>一些概念：</em></p>
<ol>
<li><p>ORM：Object Relation Mapping，对象关系映射。通过操作 Java对象来操作关系型数据库。</p>
</li>
<li><p>POJO与 JavaBean</p>
<ul>
<li>POJO：只有private属性和get/set方法且没有其他继承、实现的 Java对象。</li>
<li>JavaBean：private成员变量、get/set方法、<strong>空参构造函数</strong>、<strong>可序列化</strong>。</li>
</ul>
</li>
</ol>
<h4 id="1-Mybatis框架运行流程示意图如下："><a href="#1-Mybatis框架运行流程示意图如下：" class="headerlink" title="1. Mybatis框架运行流程示意图如下："></a>1. Mybatis框架运行流程示意图如下：</h4><p><img src="/2019/08/22/Mybatis框架学习笔记/1.jpg" alt></p>
<h4 id="2-基本配置示例："><a href="#2-基本配置示例：" class="headerlink" title="2. 基本配置示例："></a>2. 基本配置示例：</h4><p>（1）日志输出环境配置文件 <em>log4j.properties</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志级别</span><br><span class="line"># 在开发环境下，日志级别设置为DEBUG，生产环境设置为INFO或ERROR</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># 配置将日志信息打印至控制台</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 定制打印界面格式</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>

<p>（2）数据库配置文件 <em>db.properties</em> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据库配置文件</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br><span class="line">#c3p0.pool.maxPoolSize=400</span><br><span class="line">#c3p0.pool.minPoolSize=50</span><br><span class="line">#c3p0.pool.initialPoolSize=50</span><br><span class="line">#c3p0.pool.acquireIncrement=100</span><br></pre></td></tr></table></figure>

<p>（3）Mybatis核心配置文件 <em>SqlMapConfig.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- properties标签，引入外部配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置日志输出模式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用延迟加载（懒加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用积极加载，false表示按需加载（即消极加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否开启二级缓存 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置数据类型的别名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 自动为cn.merlin.mybatis.po包下所有的Java类配置别名，类名称s首字母小写 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.merlin.mybatis.po"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"cn.merlin.mybatis.test.QueryPlugin"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置MyBatis环境信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每一个environment标签对应一个单独的数据库环境 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 事务管理 --&gt;</span>	</span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 数据库配置信息 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 映射器，配置SQL映射文件的位置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"UserMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"BankMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"cn/merlin/mybatis/mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）SQL映射文件 <em>UserMapper.xml</em></p>
<blockquote>
<p>加载时机：Mapper映射文件随会话工厂对象 SqlSessionFactory 时被加载。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span> &gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 根据id查询对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE id = #&#123;value&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 当user表中仅有部分字段名称与User类的属性名对应时</span></span><br><span class="line"><span class="comment">		如user_id和user_name字段不对应</span></span><br><span class="line"><span class="comment">		需要使用resultMap标签</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;resultMap type="user" id="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		&lt;id property="id" column="user_id"/&gt;</span></span><br><span class="line"><span class="comment">		&lt;result property="username" column="user_name"/&gt;</span></span><br><span class="line"><span class="comment">	&lt;/resultMap&gt;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&lt;select id="findUserById" parameterType="integer" resultMap="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		SELECT * FROM user WHERE user_id = #&#123;value&#125;</span></span><br><span class="line"><span class="comment">	&lt;/select&gt; --&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 模糊查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserListByUsername"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用"#&#123;&#125;"替代"$&#123;&#125;"可以有效避免SQL注入 --&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE username LIKE "%" #&#123;value&#125; "%"</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 插入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span> &gt;</span></span><br><span class="line">		INSERT INTO user (username,password,gender,province,city) </span><br><span class="line">		VALUE (#&#123;username&#125;,#&#123;password&#125;,#&#123;gender&#125;,#&#123;province&#125;,#&#123;city&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 演示自定义的查询包装类 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByUserQueryInfo"</span> <span class="attr">parameterType</span>=<span class="string">"userQueryInfo"</span> <span class="attr">resultType</span>=<span class="string">"userInstance"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE user.username = #&#123;userInstance.username&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:</p>
<ol>
<li>使用<strong>“#{}”</strong>替代”${}”可以有效<strong>避免SQL注入攻击</strong>；</li>
<li>当表中部分字段名与 Java类成员变量名不匹配时，需要使用<strong>resultMap</strong>完成列名转换。</li>
</ol>
</blockquote>
<h4 id="3-获取sqlSession会话对象的三种途径："><a href="#3-获取sqlSession会话对象的三种途径：" class="headerlink" title="3. 获取sqlSession会话对象的三种途径："></a>3. 获取sqlSession会话对象的三种途径：</h4><h5 id="3-1-XML配置文件中set属性注入"><a href="#3-1-XML配置文件中set属性注入" class="headerlink" title="3.1 XML配置文件中set属性注入"></a>3.1 XML配置文件中set属性注入</h5><p>spring配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserDaoImpl 需继承 <strong>SqlSessionDaoSupport 类</strong>，方能通过get方法获取sqlSession。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession(); <span class="comment">// 调用父类（SqlSessionDaoSupport）的getSqlSession()方法</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-注解方式"><a href="#3-2-注解方式" class="headerlink" title="3.2 注解方式"></a>3.2 注解方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span> <span class="comment">// 注入sqlSessionFactory对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-手动获取"><a href="#3-3-手动获取" class="headerlink" title="3.3 手动获取"></a>3.3 手动获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装配，获取SqlSessionFactory对象</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">// 调用SqlSessionFactory类的openSession()方法</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p><strong><em>SqlSessionDaoSupport原理</em></strong></p>
<p>抽象类SqlSessionDaoSupport中有成员变量SqlSession，并配置了get方法。通过setSqlSessionFactory方法可以获得sqlSession实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.externalSqlSession) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sqlSession = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Mapper输出映射类型"><a href="#4-Mapper输出映射类型" class="headerlink" title="4. Mapper输出映射类型"></a>4. Mapper输出映射类型</h4><h5 id="4-1-resultType"><a href="#4-1-resultType" class="headerlink" title="4.1 resultType"></a>4.1 resultType</h5><p>（1）支持基本数据类型、基本数据包装类、自定义包装类（如 JavaBean）；</p>
<p>（2）输出时创建自定义包装类的前提是：<strong>表字段名与包装类属性名完全一致</strong>；</p>
<p>（3）当（2）不满足时，还可以输出为<strong>HashMap</strong>结构、</p>
<h5 id="4-2-resultMap"><a href="#4-2-resultMap" class="headerlink" title="4.2 resultMap"></a>4.2 resultMap</h5><p>当表字段名与包装类属性名不完全一致时</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id="userResultMap"唯一地标识resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"cn.com.mybatis.po.User"</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- id标签：与主键相对应 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"_id"</span> <span class="attr">properties</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- result：普通列 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"_username"</span> <span class="attr">properties</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByResultMap"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	select id _id,username _username from user where id = #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意resultMap中的<strong>association</strong>、<strong>collection</strong>标签，在涉及 Java包装类属性含有其它包装类或 List集合时会用到。</p>
</blockquote>
<h4 id="5-延迟加载"><a href="#5-延迟加载" class="headerlink" title="5. 延迟加载"></a>5. 延迟加载</h4><p>（1）功能：对于有关联的表，先查询单表，有需要时才查询关联表，以节约资源</p>
<p>（2）设置：</p>
<ul>
<li><p>lazyLoadingEnabled:true 开启延迟加载</p>
</li>
<li><p>aggressiveLazyLoading:false 开启消极加载（即按需加载）</p>
</li>
</ul>
<h4 id="6-动态代理"><a href="#6-动态代理" class="headerlink" title="6. 动态代理"></a>6. 动态代理</h4><blockquote>
<p>不编写DAO层操作数据库代码，在符合一定规范的前提下，由Mapper代理自动完成数据交互。</p>
</blockquote>
<p>示例：</p>
<p>（1）编写名称与Mapper配置文件相同的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">findCustomerById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写CustomerMapper.xml文件</p>
<blockquote>
<p>namespace 设为 接口的全包名：cn.com.mybatis.mapper.CustomerMapper</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.com.mybatis.mapper.CustomerMapper"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findCustomerById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"customer"</span>&gt;</span></span><br><span class="line">		select * from customer where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用SqlSession类的getMapper()方法，获取代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    CustomerMapper customerMapper = sqlSession.getMapper(CustomerMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    Customer customer = customerMapper.findCustomerById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-缓存（HashMap结构）"><a href="#7-缓存（HashMap结构）" class="headerlink" title="7. 缓存（HashMap结构）"></a>7. 缓存（<strong>HashMap</strong>结构）</h4><h5 id="7-1-一级缓存"><a href="#7-1-一级缓存" class="headerlink" title="7.1 一级缓存"></a>7.1 一级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/2.jpg" alt></p>
<blockquote>
<p>一级缓存基于SqlSession会话对象实例，sqlSession级别独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/3.jpg" alt></p>
<blockquote>
<p>查询时，sqlSession首先查询一级缓存，若无，再查询数据库，并将结果存储至一级缓存</p>
</blockquote>
<h5 id="7-2-二级缓存"><a href="#7-2-二级缓存" class="headerlink" title="7.2 二级缓存"></a>7.2 二级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/4.jpg" alt></p>
<blockquote>
<p>二级缓存基于Mapper实例，namespace一致则共享，否则独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/5.jpg" alt></p>
<blockquote>
<p>不同的SqlSession实例，执行同一个Mapper文件中的SQL语句，共享二级缓存</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] 《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五大常用算法之分治法</title>
    <url>/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>是一种十分重要的算法思想，其精髓是”分而治之”，即把复杂的问题分解成数个小规模的、形式相同的子问题，再逐个”击破”子问题，最后合并所有子问题的解以解决原问题。诸如快速排序、归并排序、快速傅里叶变换等算法均是分治法思想的重要体现。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>分治法（Divide and Conquer）与<strong>动态规划</strong>类似，二者最大的区别在于：适用于分治法求解的问题，经分解后得到的<strong>子问题往往是相互独立的</strong>。</p>
<p>分治法可解决的问题，应具备如下特征：</p>
<p>（1）问题的规模缩小后，更容易解决。</p>
<p>（2）该问题可分解为若干个小规模的、形式相同的问题，即该问题具有最优子结构性质。这体现了<strong>递归思想</strong>在分治法中的应用。</p>
<p><strong>（3）利用该问题分解出的子问题的解能够合并为该问题的解。</strong>这决定了某一问题是否适用于分治法。不符时应考虑贪心法或<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">动态规划</a>。</p>
<p>（4）子问题是相互独立的。子问题若不独立，应考虑<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">动态规划</a>。</p>
<h4 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h4><p>二分查找是分治思想的重要且常用的实现算法之一。</p>
<p>二分查找的基本思路是：将目标对象（一般为数组）一分为二，递归地进入子对象继续进行二分查找，直至子问题可以很容易被解决。其核心代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">    mid = (hi+lo)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 最小规模的子问题，直接返回子问题的结果</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">        hi = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、最大子序和问题"><a href="#三、最大子序和问题" class="headerlink" title="三、最大子序和问题"></a>三、最大子序和问题</h4><p>最大子序和问题是一道经典的算法题，可参见LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>。</p>
<p>问题描述：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<p>在<a href="https://merlinhu0112.github.io/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">动态规划和分治法求解最大子序和问题</a>一文中，采用动态规划法解决了此问题。如何用分治法解决此问题呢？</p>
<p>分治法的核心在于如何将目标数组划分为若干个子数组并分别求出子数组的最大子序和。容易想到，将数组沿 <code>(left+right)/2</code> 划分为两段，分别递归求解两段的最大子序和，随后合并结果（即从两个值中选择较大者）。</p>
<p>那么，取上述两段最大子序和中的较大者就是数组 <code>nums</code> 的最大子序和了吗？</p>
<p>显然，上述结论是不成立的。因为将数组一分为二，没有考虑到<strong>数组跨越中间元素组成的序列</strong>的情况。那么，考虑它就是咯！</p>
<p>就测试用例而言，我们可沿索引为 <code>4</code> 的元素将 <code>nums</code> 划分为：</p>
<ul>
<li>[-2, 1, -3, 4, -1]，左半段，leftSum；</li>
<li>[2, 1, -5, 4]，右半段，rightSum；</li>
<li>[ … , 4, <strong>-1</strong>, 2, … ]，跨越中间元素的数组，crossSum。</li>
<li>取上述三者的最大值。</li>
</ul>
<p>对于左右半段，递归调用函数即可求解。如何求解跨越中间元素数组的最大子序和（crossSum）呢？</p>
<p>如图，以已经划分至最小规模的 <code>[-2, 1, -3]</code> 为例。我们从 <code>-1</code> 出发，扫描至左端边界，求得跨越中间元素数组的<strong>含边界</strong> <code>-1</code> 的最大子序和 <code>leftCrossSum</code> ；再从 <code>-3</code> 出发，扫描至右端边界，求得跨越中间元素数组的含边界 <code>-3</code> 的最大子序 <code>rightCrossSum</code> ；二者之和即为 <code>crossSum</code> 。</p>
<p><img src="/2020/02/26/五大常用算法之分治法/fig1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursion(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = recursion(nums, left, mid); <span class="comment">// 继续划分，递归求解，左段</span></span><br><span class="line">    <span class="keyword">int</span> rightSum = recursion(nums, mid+<span class="number">1</span>, right); <span class="comment">// 继续划分，递归求解，右段</span></span><br><span class="line">    <span class="keyword">int</span> crossSum = crossSum(nums, left, right); <span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> leftCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid; i&gt;=left; i--) &#123;</span><br><span class="line">        <span class="comment">// 扫描左边</span></span><br><span class="line">        leftCurrSum += nums[i];</span><br><span class="line">        leftCrossSum = Math.max(leftCrossSum, leftCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> rightCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>; i&lt;=right; i++) &#123;</span><br><span class="line">        <span class="comment">// 扫描右边</span></span><br><span class="line">        rightCurrSum += nums[i];</span><br><span class="line">        rightCrossSum = Math.max(rightCrossSum, rightCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCrossSum+rightCrossSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n log n)；</li>
<li>空间复杂度：O(log n)。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划和分治法求解最大子序和问题</title>
    <url>/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>基于LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>，总结<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">动态规划</a>和<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>的解题思路，同时涉及经典的Kadane算法。</p>
<a id="more"></a>

<h4 id="一、题目介绍"><a href="#一、题目介绍" class="headerlink" title="一、题目介绍"></a>一、题目介绍</h4><p>题目：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<h4 id="二、动态规划法"><a href="#二、动态规划法" class="headerlink" title="二、动态规划法"></a>二、动态规划法</h4><p>在<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">五大常用算法之动态规划</a>中学习了动态规划中首先需要确定的三个要素：</p>
<ul>
<li><p>最优子结构</p>
</li>
<li><p>边界</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>在本题中，对于数组 <code>nums</code> 中索引为 <code>i</code> 的元素，其<strong>当前最大子序和</strong>为下列二者中的较大者：</p>
<ul>
<li>索引 <code>i-1</code> 处的当前最大子序和，加上索引 <code>i</code> 处的 <code>nums</code> 数组元素值；</li>
<li>索引 <code>i</code> 处的 <code>nums</code> 数组元素值。</li>
</ul>
<p>设 <code>dp</code> 数组保存每个元素位置的<strong>当前最大子序和</strong>。</p>
<p>状态转移方程为：<code>dp[i] = max( (dp[i-1]+nums[i]), (nums[i]) )</code>；边界条件为：<code>dp[0] = nums[0]</code>。</p>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/dp_1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// dp数组存储nums数组每个元素位置的当前最大子序和</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max((dp[i-<span class="number">1</span>]+nums[i]), nums[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.length; ++i) &#123;</span><br><span class="line">        res = Math.max(dp[i], res); <span class="comment">// 遍历dp数组，找出最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="三、Kadane算法"><a href="#三、Kadane算法" class="headerlink" title="三、Kadane算法"></a>三、Kadane算法</h4><blockquote>
<p>Kadane算法是一种动态规划算法。</p>
</blockquote>
<p>在上述动态规划算法中，使用 <code>dp</code> 数组保存数组 <code>nums</code> 所有位置的最大子序和。在经典的 kadane算法中，对此进行了优化。</p>
<p>Kadane算法采用两个辅助变量：</p>
<ul>
<li>currSum：当前位置 <code>i</code> 的最大子序和，对应的是 <code>dp</code> 中 <code>i</code> 位置的元素值；</li>
<li>maxSum：保存全局最大子序和。</li>
</ul>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/kadane.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        currSum = Math.max((currSum+nums[i]), nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、分治法"><a href="#四、分治法" class="headerlink" title="四、分治法"></a>四、分治法</h4><p>关于分治法求解过程，详见<a href="https://merlinhu0112.github.io/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/" target="_blank" rel="noopener">五大常用算法之分治法</a>。</p>
<h4 id="五、算法性能总结："><a href="#五、算法性能总结：" class="headerlink" title="五、算法性能总结："></a>五、算法性能总结：</h4><p>暴力法的时间复杂度较高，为 O(n^3) 或 O(n^2)。</p>
<p>分治法的思路较为复杂，从是否跨越中间元素出发，将数组分为三个不会重合的子序列，对其分别求出最大子序和，取三者中的较大者即可。该算法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。</p>
<p>动态规划法的思路更加直观、易理解。算法性能也是最优的，时间复杂度可达 O(n)，空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建线程的方式</title>
    <url>/2020/02/21/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>尽管提倡使用线程池高效地管理线程，但了解线程创建的基础方法还是非常有必要的。</p>
<a id="more"></a>

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>创建线程的四种方式：</p>
<ul>
<li>继承Thread类，无返回结果</li>
<li>实现Runnable接口，无返回结果</li>
<li>通过FutureTask类，有返回结果</li>
<li>通过线程池创建</li>
</ul>
<h3 id="二、继承Thread类创建线程类"><a href="#二、继承Thread类创建线程类" class="headerlink" title="二、继承Thread类创建线程类"></a>二、继承Thread类创建线程类</h3><blockquote>
<p>Java的单继承机制，使得类继承Thread类后，不能再继承其它类。</p>
</blockquote>
<h5 id="1-具体实现过程如下："><a href="#1-具体实现过程如下：" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>继承Thread类，重写<strong>run( )</strong>方法。run( )方法表示线程要执行的任务，被称为执行体。</li>
<li>创建Thread子类对象实例，即创建线程对象。</li>
<li>调用线程对象的<strong>start( )</strong>方法启动该线程。</li>
</ol>
<h5 id="2-实现代码"><a href="#2-实现代码" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之一：继承Thread类，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   MyThread myThread = <span class="keyword">new</span> MyThread(); <span class="comment">// 实例化线程对象</span></span><br><span class="line">   myThread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式"><a href="#3-匿名内部类形式" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><p><em>上述还可以写成匿名内部类的形式</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、通过Runnable接口创建线程类"><a href="#二、通过Runnable接口创建线程类" class="headerlink" title="二、通过Runnable接口创建线程类"></a>二、通过Runnable接口创建线程类</h3><blockquote>
<p>在多数情况下，如果仅覆盖run( )方法而不涉及Thread类的其它方法，不建议使用第一种途径新建线程。</p>
</blockquote>
<h5 id="1-具体实现过程如下：-1"><a href="#1-具体实现过程如下：-1" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>定义Runnable接口的实现类，重写run( )方法。该实现类的实例作为<strong>任务对象</strong>，run( )方法为执行体。</li>
<li>传入任务对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
</ol>
<h5 id="2-实现代码-1"><a href="#2-实现代码-1" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RunnableTask类——任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之二：实现Runnable接口，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunnableTask runTask = <span class="keyword">new</span> RunnableTask(); <span class="comment">// 实例化任务类</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runTask); <span class="comment">// 传入任务对象，创建线程对象</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式-1"><a href="#3-匿名内部类形式-1" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、通过FutureTask类创建有返回结果的线程"><a href="#三、通过FutureTask类创建有返回结果的线程" class="headerlink" title="三、通过FutureTask类创建有返回结果的线程"></a>三、通过FutureTask类创建有返回结果的线程</h3><blockquote>
<p>FutureTask实现 <code>Future</code> 和 <code>Runnable</code> 接口，是一个可取消的<strong>异步计算任务</strong>，通过其可跟踪任务的执行情况，获取任务的执行结果。</p>
</blockquote>
<p>FutureTask类的两个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable); <span class="comment">// 执行给定的Callable对象</span></span><br><span class="line">FutureTask(Runnable runnable, V result); <span class="comment">// 执行给定的Runnable对象，成功后返回给定的result</span></span><br></pre></td></tr></table></figure>

<h5 id="1-具体实现过程如下：-2"><a href="#1-具体实现过程如下：-2" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>创建Callable接口的实现类，重写call( )方法。call( )方法为执行体，<strong>有返回值</strong>。或者，创建Runnable接口的实现类，重写run( )方法。run( )方法为执行体，无返回值。</li>
<li>调用FutureTask类的构造方法创建FutureTask对象，其中对Runnable对象需要指定result。</li>
<li>传入FutureTask对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
<li>调用FutureTask对象的<strong>get( )</strong>方法获取线程执行结束的返回值。</li>
</ol>
<h5 id="2-实现代码-2"><a href="#2-实现代码-2" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><ol>
<li><em>对于 Callable对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Callable接口的实现类，重写call( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">// call( )方法有返回值</span></span><br><span class="line">		<span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"异步计算任务开始"</span>);</span><br><span class="line">			number = Math.random()*<span class="number">10</span>;</span><br><span class="line">			number += <span class="number">500</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTask()); <span class="comment">// 传入Callable对象，创建FutureTask对象</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask); <span class="comment">// 传入FutureTask对象，创建线程对象</span></span><br><span class="line">    thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    Double result = futureTask.get(); <span class="comment">// 通过FutureTask类的get()方法获取异步计算结果</span></span><br><span class="line">    System.out.println(<span class="string">"计算结果为："</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><em>对于 Runnable 对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Runnable接口的实现类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开启线程"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Double&gt;(<span class="keyword">new</span> RunnableTask(), <span class="number">520.0</span>);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    Double result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、通过线程池管理线程"><a href="#四、通过线程池管理线程" class="headerlink" title="四、通过线程池管理线程"></a>四、通过线程池管理线程</h3><blockquote>
<p>通过工厂类 Executors 或 ThreadPoolExecutor 类可创建线程池，通过线程池可管理线程。</p>
</blockquote>
<p><em>以 Executors 为例</em></p>
<p>（1）Executors 可生成四种不同的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>; <span class="comment">// 固定长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>; <span class="comment">// 可缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>; <span class="comment">// 单线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>; <span class="comment">// 延时/定时执行任务，固定长度</span></span><br></pre></td></tr></table></figure>

<p>（2）演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">    es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.cnblogs.com/jinggod/p/8485106.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinggod/p/8485106.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类中代码加载顺序</title>
    <url>/2020/02/04/Java%E7%B1%BB%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>Java中静态变量、静态代码块、构造代码块、成员变量和构造方法的加载顺序，以及父类、子类中的加载顺序。</p>
<a id="more"></a>

<h3 id="一、单一类中代码的首次加载顺序"><a href="#一、单一类中代码的首次加载顺序" class="headerlink" title="一、单一类中代码的首次加载顺序"></a>一、单一类中代码的首次加载顺序</h3><blockquote>
<p>静态变量/静态代码块 &gt;&gt;&gt; 成员变量/构造代码块 &gt;&gt;&gt; 构造方法</p>
</blockquote>
<p><em>代码示例：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 静态变量、静态代码块和构造方法的加载次序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Test();</span><br><span class="line">		<span class="comment">//new Test().staticFunction();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	static &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(a); // 报错，因为静态变量a的加载顺序在此静态代码块之后</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 静态变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态变量比构造代码块先加载，a = "</span>+a);</span><br><span class="line">		a = <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="string">"构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载"</span>);</span><br><span class="line">		System.out.println(<span class="string">"构造代码块加载时，修改了静态变量a的值：a = "</span>+a);</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载前，完成成员变量初始化：b = "</span>+b); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// 成员变量初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态代码块</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法只有在被调用时才会加载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法被调用"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块被加载</span><br><span class="line">静态变量比构造代码块先加载，a = <span class="number">1</span></span><br><span class="line">构造代码块被加载</span><br><span class="line">构造方法被加载</span><br><span class="line">构造代码块加载时，修改了静态变量a的值：a = <span class="number">3</span></span><br><span class="line">构造方法被加载前，完成成员变量初始化：b = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>结合示例代码和其运行结果，可知在<strong>（首次）加载类</strong>的时候，</p>
<ul>
<li>首先，加载<strong>静态变量</strong>和<strong>静态代码块</strong>，其中二者的加载顺序<strong>与代码顺序相同</strong>；</li>
<li>其次，<em>在调用构造方法后</em>，按代码顺序<strong>先加载成员变量</strong>和<strong>构造代码块</strong>；</li>
<li>最后，加载<strong>构造函数</strong>。</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li>静态变量和静态代码块仅在首次加载类时被加载；</li>
<li>每调用一次构造方法，都要按序加载成员变量、构造代码块、构造函数；</li>
<li>静态方法仅在被调用时才会加载。</li>
</ul>
<h3 id="二、首次加载时父类与子类的情况"><a href="#二、首次加载时父类与子类的情况" class="headerlink" title="二、首次加载时父类与子类的情况"></a>二、首次加载时父类与子类的情况</h3><p><em>加载顺序规则如下</em>：</p>
<ol>
<li><p>按代码位置加载<strong>父类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>父类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>父类的构造方法</strong>；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>子类的构造方法</strong>。</p>
</li>
</ol>
<p><em>代码示例如下：</em></p>
<p>（父类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的成员变量：fatherEle = "</span>+fatherEle);</span><br><span class="line">		System.out.println(<span class="string">"父类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> fatherEle = <span class="number">520</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（子类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的成员变量：sonEle = "</span>+sonEle);</span><br><span class="line">		System.out.println(<span class="string">"子类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sonEle = <span class="number">1314</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（测试方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 父类、子类代码加载顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态代码块被加载</span><br><span class="line">子类的静态代码块被加载</span><br><span class="line">父类的构造代码块被加载</span><br><span class="line">父类的成员变量：fatherEle = <span class="number">520</span></span><br><span class="line">父类的构造方法被加载</span><br><span class="line">子类的构造代码块被加载</span><br><span class="line">子类的成员变量：sonEle = <span class="number">1314</span></span><br><span class="line">子类的构造方法被加载</span><br></pre></td></tr></table></figure>

<h3 id="三、非首次加载时父类与子类的情况"><a href="#三、非首次加载时父类与子类的情况" class="headerlink" title="三、非首次加载时父类与子类的情况"></a>三、非首次加载时父类与子类的情况</h3><blockquote>
<p>静态变量和静态代码块不需要再加载，其余按上述（3~6）执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之回溯算法</title>
    <url>/2020/01/13/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基于八皇后问题给出回溯算法的解析过程。回溯算法是真的难，过于抽象，还需反反复复地看看看！</p>
<a id="more"></a>

<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>回溯法（探索与回溯法）是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“<strong>回溯点</strong>”。</p>
<p>其基本思想是，在包含问题的所有解的解空间树中，按照<strong>深度优先搜索</strong>的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</p>
<h4 id="二、典型应用之八皇后问题"><a href="#二、典型应用之八皇后问题" class="headerlink" title="二、典型应用之八皇后问题"></a>二、典型应用之八皇后问题</h4><p>题干：八皇后问题由马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。试问总共有多少种摆放的方法？==（92种）==</p>
<h5 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h5><ul>
<li><p>显然，棋盘上每一行（或每一列）上只能同时出现一个皇后。要解决此问题，可先摆放第1行的皇后，紧接着摆放第2行的皇后。</p>
</li>
<li><p>在摆放第i行的皇后时，需要判断其是否与前面所有行已存在的皇后产生冲突。</p>
</li>
<li><p>若无，直接放置，并继续下一行，直至摆放完最后一行。</p>
</li>
<li><p>若产生冲突，则调整此行的皇后位置。若此行所有位置均不符合要求，则需要<strong>回溯至第i-1行，调整改行皇后的位置</strong>，直至回溯至第1行。</p>
</li>
</ul>
<h5 id="2-图解"><a href="#2-图解" class="headerlink" title="2. 图解"></a>2. 图解</h5><p>（1）放置第1行的皇后：8格均可，先尝试放置在第1格。红色表示<strong>下一行</strong>对应位置已被锁定。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/1.jpg" alt></p>
<p>（2）放置第2行的皇后：前两格已被第1行的皇后锁定，故只能在后6格中任选，选第3格。相应的，前两行放置好的皇后也锁定了第3行部分位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/2.jpg" alt></p>
<p>（3）放置第3行的皇后：在未被锁定的后4格中任选，选第5格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/3.jpg" alt></p>
<p>（4）放置第4行的皇后：只有3格可选，选第2格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/4.jpg" alt></p>
<p>（5）放置第5行的皇后：只剩2格可选，选第1格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/5.jpg" alt></p>
<p>（6）放置第6行的皇后：只能选择第4格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/6.jpg" alt></p>
<p>（7）放置第7行的皇后：只能选择第6格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/7.jpg" alt></p>
<p>（8）放置完前7行后可发现，第8行所有位置均被锁定。故回溯至第7行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/8.jpg" alt></p>
<p>（9）第7行仅有一个位置，且已尝试过，故继续回溯至第6行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/9.jpg" alt></p>
<p>（10）同样地，继续回溯至第5行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/10.jpg" alt></p>
<p>（11）第5行有两个位置，前一个已被尝试过，故选择第4格作为第5行皇后的新位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/11.jpg" alt></p>
<blockquote>
<p>很不幸，第5行重新放置后，第6行所有位置被锁定，故仍需回溯至第4行。在此就不继续演示了。</p>
</blockquote>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题，基于递归的回溯思想，解决此问题</span></span><br><span class="line"><span class="comment"> * 2020-01-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] checkerboard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 棋盘的列投影，记录每一行的皇后存放的列索引值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> len = <span class="number">8</span>; <span class="comment">// 棋盘的行或列长度为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> queens = <span class="number">8</span>; <span class="comment">// 皇后数，为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// 记录总共的解法数，对八皇后问题，应为92</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EightQueens</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归地放置皇后到第i+1行合适的位置</span></span><br><span class="line"><span class="comment">	 * 放置第i+1行的皇后之后，需要判断其是否与之前的皇后冲突，若无，递归进入下一行；</span></span><br><span class="line"><span class="comment">	 * 若产生冲突，将其往后移动一列，避免冲突</span></span><br><span class="line"><span class="comment">	 * 注意for循环内部是递归嵌套的，若到最后某一行皇后已无法移动，则会逐步返回上一层，直至</span></span><br><span class="line"><span class="comment">	 * 调整首行以实现放入所有皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putQueen</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==queens) &#123;</span><br><span class="line">			total++; <span class="comment">// 此语句执行则说明当前结果是一种可行解法，故总解法数加1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;len; col++) &#123;</span><br><span class="line">				checkerboard[i] = col; <span class="comment">// 对于第i+1行，该行的皇后放在第col+1列；若if语句为false，则调整第i+1行的皇后位置</span></span><br><span class="line">				<span class="keyword">if</span>(check(i)) &#123;</span><br><span class="line">					putQueen(i+<span class="number">1</span>); <span class="comment">// 若检查发现，第i+1行及之前各行皇后位置均满足题意，则递归移动下一行</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断第i+1行放入的皇后是否与之前的皇后产生冲突</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">			<span class="comment">// j为第i+1行之前的所有行，需要逐一比较</span></span><br><span class="line">			<span class="keyword">if</span>(checkerboard[i]==checkerboard[j] || i-checkerboard[i]==j-checkerboard[j] ||</span><br><span class="line">					i+checkerboard[i]==j+checkerboard[j]) &#123;</span><br><span class="line">				<span class="comment">// checkerboard[i]==checkerboard[j] 判断不同行的皇后是否在同一列</span></span><br><span class="line">				<span class="comment">// i-checkerboard[i]==j-checkerboard[j] 判断不同行的皇后是否在左对角线上</span></span><br><span class="line">				<span class="comment">// i+checkerboard[i]==j+checkerboard[j] 判断不同行的皇后是否在右对角线上</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 辅助方法，启动putQueen</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		putQueen(<span class="number">0</span>); <span class="comment">// 从第1行开始，其行序号为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.php.cn/faq/415926.html" target="_blank" rel="noopener">https://www.php.cn/faq/415926.html</a></p>
<p>[2] <a href="https://www.jianshu.com/p/dd3c3f3e84c0" target="_blank" rel="noopener">https://www.jianshu.com/p/dd3c3f3e84c0</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程学习笔记</title>
    <url>/2020/01/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。</p>
<a id="more"></a>

<p>多线程</p>
<ul>
<li><p>优点：多线程程序提高了资源利用效率；</p>
</li>
<li><p>并发安全性问题：多个线程共享进程的部分资源，对于这些共享变量的访问操作可能出现并发异常；</p>
<blockquote>
<p>解决途径：Java提供的同步机制</p>
</blockquote>
</li>
<li><p>活跃性问题：线程陷入死循环，影响后序代码的执行；</p>
</li>
<li><p>性能消耗问题。</p>
</li>
</ul>
<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>重要概念：</p>
<ul>
<li>状态访问操作：任何可能影响对象外部可见行为的操作；</li>
<li>共享：多个线程可同时访问；</li>
<li>可变：变量值可变。</li>
</ul>
<h4 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h4><h5 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h5><p>（1）简单描述线程安全</p>
<blockquote>
<p>当多个线程访问某个类时，该类始终表现出正确的行为，则该类是线程安全的。</p>
</blockquote>
<p>（2）无状态对象是线程安全的</p>
<blockquote>
<p>无状态对象：不包含任何域和对其它类中域的引用，在操作过程中不保存数据，是不变的类，线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessClass</span></span>&#123;</span><br><span class="line">	<span class="comment">// 不含域，即无成员变量（实例变量和类变量）及局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a; <span class="comment">// Instance Variable(non-static variable)，实例变量，不含</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">// Class Variable(static variable)，类变量，不含</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">10</span>; <span class="comment">// Local Variable，局部变量，不含</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态的对象示例 -- Servlet</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行过程中，仅由线程独享的栈中保存临时数据，因而是线程安全的</span></span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(res, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-竞态条件（Race-Condition）"><a href="#1-2-竞态条件（Race-Condition）" class="headerlink" title="1.2 竞态条件（Race Condition）"></a>1.2 竞态条件（Race Condition）</h5><p>（1）什么是竞态条件？</p>
<p>并发编程中，由于不恰当的执行时序而出现不正确的结果。</p>
<blockquote>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</blockquote>
<p>（2）常见的竞态条件类型</p>
<ol>
<li>先检查后执行（Check-Then-Act）：通过一个可能失效的观测结果来决定下一步的动作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span></span>&#123;</span><br><span class="line">    Private ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyInitRace <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于示例 <strong>延迟初始化</strong> 类，两个线程交替执行过程中，可能均观测到 <code>instance==null</code>，于是分别实例化新的<code>ExpensiveObject</code> 对象，造成 <code>getInstance()</code> 方法返回不同的实例，这是异常情况。</p>
<ol start="2">
<li>读取 - 修改 - 写入：非原子性的操作造成并发异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 访问计数器，线程每访问一次，加1</span></span><br><span class="line">    ...</span><br><span class="line">    count++; <span class="comment">// count++是非原子性的操作，它包括：读取旧值、修改值、写入新值 这三个操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程交替执行时，<code>count++</code> 操作是 <strong>非原子性</strong> 的，最终两个线程分别执行完 <code>count++</code> 操作后得到的 <code>count</code> 是相同的，显然这出现了并发异常。</p>
<p>（3）对于竞态条件，如何保证并发安全性？</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png" alt></p>
<h4 id="2-多线程的安全性"><a href="#2-多线程的安全性" class="headerlink" title="2. 多线程的安全性"></a>2. 多线程的安全性</h4><blockquote>
<p>安全的多线程并发应保证原子性、可见性和有序性</p>
</blockquote>
<h5 id="2-1-原子性、可见性和有序性"><a href="#2-1-原子性、可见性和有序性" class="headerlink" title="2.1 原子性、可见性和有序性"></a>2.1 原子性、可见性和有序性</h5><p>（1）原子性：对于单个或者多个操作，要么全部执行且不会被中断，要么都不执行。</p>
<blockquote>
<p>Atomic包、synchronized关键字、Lock接口</p>
</blockquote>
<p>（2）可见性：对于共享的可变变量，当一个线程修改了它，其它线程能立即看到变化。</p>
<blockquote>
<p>关键字 synchronized、volatile 和 final，Lock接口</p>
</blockquote>
<p>（3）有序性: </p>
<blockquote>
<p>happens-before原则</p>
</blockquote>
<ul>
<li>程序的执行顺序与代码顺序相同；</li>
<li>JVM在实际执行时会发生 <em>指令重排序</em> ；</li>
<li>重排序对单线程程序无影响，对多线程程序可能会造成并发异常！</li>
</ul>
<h5 id="2-2-如何保证可见性？"><a href="#2-2-如何保证可见性？" class="headerlink" title="2.2 如何保证可见性？"></a>2.2 如何保证可见性？</h5><p><img src="/2020/01/12/Java并发编程笔记/%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt></p>
<h4 id="3-Java-的同步机制"><a href="#3-Java-的同步机制" class="headerlink" title="3. Java 的同步机制"></a>3. Java 的同步机制</h4><blockquote>
<p>同步以保证线程安全。Java提供关键字<strong>synchronized（内置锁）</strong> 和 <strong>Lock接口</strong> 这两种机制实现同步。关键字<strong>volatile</strong> 仅保证可见性，不保证原子性。</p>
</blockquote>
<h5 id="3-1-多线程并发异常演示"><a href="#3-1-多线程并发异常演示" class="headerlink" title="3.1 多线程并发异常演示"></a>3.1 多线程并发异常演示</h5><p>（1）Bank类模拟银行账户存取操作，其中未对相应的方法进行同步，使其面临并发异常的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟多线程并发操作银行账户，Bank类实现了取钱和存钱操作。</span></span><br><span class="line"><span class="comment"> * 注意：在实际应用中，涉及金融数字时不应采用任何基本数据类型，而应使用BigDecimal类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）两个线程分别对同一个Bank实例进行反复地存、取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestBank类，演示在无同步前提下，多个线程并发地对Bank类实例</span></span><br><span class="line"><span class="comment"> * 进行操作是否会出现并发异常。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 存钱线程</span></span><br><span class="line">		Thread addThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.addMoney(<span class="number">300</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 取钱线程</span></span><br><span class="line">		Thread subThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.subMoney(<span class="number">500</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		addThread.start();</span><br><span class="line">		subThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.RuntimeException: 当前账户余额不足</span><br><span class="line">	at javasynchronization.Bank.subMoney(Bank.java:20)</span><br><span class="line">	at javasynchronization.UnsafeThread$2.run(UnsafeThread.java:39)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1500 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结合第2行和第4行可知，并发出现异常：存入300元后余额应为1300元；在1300元的基础上支取500元恰好剩余800元。</p>
<p>第12行显示，支取线程因异常而中断，此后为单线程（存钱）操作，不存在并发风险。</p>
</blockquote>
<h5 id="3-2-synchronized-修饰的同步方法【内置锁】"><a href="#3-2-synchronized-修饰的同步方法【内置锁】" class="headerlink" title="3.2 synchronized 修饰的同步方法【内置锁】"></a>3.2 synchronized 修饰的同步方法【内置锁】</h5><blockquote>
<p>关键字 synchronized，Java 所有对象都有一个内置锁，重量级锁。</p>
</blockquote>
<p>（1）SynchronizedBank类，通过<strong>synchronized</strong>实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronizedBank类，模拟银行账户的存取操作，是线程安全的类。</span></span><br><span class="line"><span class="comment"> * 关键字synchronized对subMoney和addMoney方法进行修饰，即利用</span></span><br><span class="line"><span class="comment"> * Java内置锁对上述方法进行加锁，以实现复合操作的原子性，保证线程</span></span><br><span class="line"><span class="comment"> * 安全。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果（测试代码类似于3.1部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1100 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-3-synchronized-同步代码块"><a href="#3-3-synchronized-同步代码块" class="headerlink" title="3.3 synchronized 同步代码块"></a>3.3 synchronized 同步代码块</h5><blockquote>
<p>与 synchronized 修饰的<strong>同步方法</strong>相比，<strong>同步代码块</strong>可<strong>仅对涉及共享变量的操作语句进行加锁</strong>。</p>
</blockquote>
<p>（1）同步代码块示例（由于打印语句需要读取共享变量，故仍要纳入同步代码块中，造成误认为同步方法与同步代码块加锁区域是相同的！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynBloBank类，通过同步代码块避免并发风险。其与SynchronizedBank类中</span></span><br><span class="line"><span class="comment"> * synchronized关键字修饰的同步方法类似，只是同步代码块的同步范围更小（对</span></span><br><span class="line"><span class="comment"> * 影响并发安全性的语句进行同步）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynBloBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynBloBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 同步代码块，锁对象是"this"，即调用此方法者</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 900 元</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 700 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 500 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步代码块：对有并发风险的操作语句进行加锁；</p>
<p>同步方法：对含有并发风险操作的方法进行加锁。</p>
</blockquote>
<h5 id="3-4-ReentrantLock-【显示锁】"><a href="#3-4-ReentrantLock-【显示锁】" class="headerlink" title="3.4 ReentrantLock 【显示锁】"></a>3.4 ReentrantLock 【显示锁】</h5><blockquote>
<p>ReentrantLock类实现Lock接口</p>
</blockquote>
<p>（1）ReentrantLock加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank类，线程安全类。</span></span><br><span class="line"><span class="comment"> * Lock接口定义了锁的操作（包括lock和unlock）。ReentrantLock类实现Lock接口，</span></span><br><span class="line"><span class="comment"> * 默认采用非公平的锁策略。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 锁对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 8888 元</span><br><span class="line">Thread-1 支取 500 元，余额为 8388 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8688 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8188 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8488 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8788 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8288 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-5-关键字-volatile-【不行！】"><a href="#3-5-关键字-volatile-【不行！】" class="headerlink" title="3.5 关键字 volatile 【不行！】"></a>3.5 关键字 volatile 【不行！】</h5><blockquote>
<p>volatile 关键字可以<strong>实现可见性</strong>，但<strong>无法保证原子性</strong>。</p>
</blockquote>
<p>（1）volatile 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VolatileBank类，关键字volatile修饰成员变量count，保证</span></span><br><span class="line"><span class="comment"> * 可见性，但不能保证原子性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VolatileBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1500 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机测试结果表明：并发过程出现异常，即 <em>关键字 volatile 无法保证原子性！</em></p>
</blockquote>
<h4 id="4-Java-中的锁"><a href="#4-Java-中的锁" class="headerlink" title="4. Java 中的锁"></a>4. Java 中的锁</h4><p><img src="/2020/01/12/Java并发编程笔记/Java%E4%B8%AD%E7%9A%84%E9%94%81.png" alt></p>
<h5 id="4-1-synchronized及锁升级过程"><a href="#4-1-synchronized及锁升级过程" class="headerlink" title="4.1 synchronized及锁升级过程"></a>4.1 synchronized及锁升级过程</h5><blockquote>
<p>JDK 1.5之后，synchronized锁被划分为四种状态：无锁 - 偏向锁 - 轻量级锁 - 重量级锁。</p>
</blockquote>
<p>（1）Java普通对象的内存布局</p>
<p>（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> &amp; <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt></p>
<p>（2）锁升级过程</p>
<p>Java锁升级过程（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5CJava%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ol>
<li><p>无锁</p>
<ul>
<li>偏向锁标志位：0</li>
<li>锁标志位：01</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li>设定 -XX:BiasedLockingStartupDelay = 0，由默认轻量级锁改为偏向锁。</li>
<li>偏向锁标志位：1</li>
<li>锁标志位：01</li>
<li><strong>记录当前线程ID</strong></li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li><p>锁标志位：00</p>
</li>
<li><p>当<strong>第二个线程</strong>参与竞争偏向锁时，对象根据对象头markdown中记录的<strong>线程ID</strong>发现是新线程，<strong>立即撤销偏向锁，升级为轻量级锁</strong>。</p>
</li>
<li><p>线程生成<strong>LockRecord</strong>保存在线程栈中。每个线程通过<strong>CAS（自旋）</strong>操作，试图将对象头中的<strong>指向栈中锁记录的指针</strong>记录为自己的LockRecord。成功则获取锁。</p>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>锁标志位：10</li>
<li>锁竞争加剧（如线程自旋次数或自旋的线程数超过阈值），由轻量级锁升级为重量级锁。</li>
<li>重量级锁开始切换用户态/内核态，开销较大。</li>
</ul>
</li>
</ol>
<h5 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h5><p>（暂无）</p>
<h5 id="4-3-ReentrantReadWriteLock"><a href="#4-3-ReentrantReadWriteLock" class="headerlink" title="4.3 ReentrantReadWriteLock"></a>4.3 ReentrantReadWriteLock</h5><p>（暂无）</p>
<h3 id="二、Java类库中的并发基础构建模块"><a href="#二、Java类库中的并发基础构建模块" class="headerlink" title="二、Java类库中的并发基础构建模块"></a>二、Java类库中的并发基础构建模块</h3><h4 id="1-同步容器类"><a href="#1-同步容器类" class="headerlink" title="1. 同步容器类"></a>1. 同步容器类</h4><ul>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<p>同步容器类通过“封装状态，同步所有公有方法”使得每次只有一个线程可以访问容器的状态，以此实现线程安全。</p>
<h5 id="1-1-为什么要为同步容器类额外地进行客户端加锁？"><a href="#1-1-为什么要为同步容器类额外地进行客户端加锁？" class="headerlink" title="1.1 为什么要为同步容器类额外地进行客户端加锁？"></a>1.1 为什么要为同步容器类额外地进行客户端加锁？</h5><blockquote>
<p>客户端加锁：对于使用某个对象的客户端代码，通过对象本身用于保护其状态的锁来保护这段客户端代码。</p>
</blockquote>
<p><em>对于复合操作，同步容器类可能会出现并发异常，但这种异常并非是同步容器类被破坏导致的</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步容器类Vector，对其进行复合操作时可能会出现异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    vector.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程 <code>Thread_A</code> 和 <code>Thread_B</code> 并发地对 <code>Vector</code> 实例进行复合操作时，<strong>无法破坏 vector 对象</strong>，但从下图可以看出，对调用者 <code>Thread_A</code> 来说，出现异常。</p>
<p><img src="/2020/01/12/Java并发编程笔记/3.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行客户端加锁，以保证对同步容器类实例的复合操作是线程安全的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象vector的锁来进行客户端加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">   		<span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    	vector.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-对容器进行迭代操作是有并发风险的"><a href="#1-2-对容器进行迭代操作是有并发风险的" class="headerlink" title="1.2 对容器进行迭代操作是有并发风险的"></a>1.2 对容器进行迭代操作是有并发风险的</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在迭代操作中，其它线程可能并发地修改容器，导致当前线程迭代出现异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    	doSomething(vector.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-如何降低加锁带来的性能影响？"><a href="#1-3-如何降低加锁带来的性能影响？" class="headerlink" title="1.3 如何降低加锁带来的性能影响？"></a>1.3 如何降低加锁带来的性能影响？</h5><blockquote>
<p>克隆容器，在<strong>线程封闭</strong>的副本上进行加锁、复合操作。</p>
</blockquote>
<h4 id="2-并发容器类"><a href="#2-并发容器类" class="headerlink" title="2. 并发容器类"></a>2. 并发容器类</h4><h5 id="2-1-并发容器类与同步容器类的比较"><a href="#2-1-并发容器类与同步容器类的比较" class="headerlink" title="2.1 并发容器类与同步容器类的比较"></a>2.1 并发容器类与同步容器类的比较</h5><p>（1）同步容器类在执行每一个操作时均持有锁，虽保证了线程安全，但降低了并发性。</p>
<p>（2）多个线程竞争同步容器类的锁时，将严重降低系统吞吐量。</p>
<p>（3）并发容器类较同步容器类有更好地并发性能。</p>
<h5 id="2-2-以ConcurrentHashMap为例"><a href="#2-2-以ConcurrentHashMap为例" class="headerlink" title="2.2 以ConcurrentHashMap为例"></a>2.2 以ConcurrentHashMap为例</h5><p>（1）加锁策略 —— <strong>分段锁（Lock Striping）</strong>，细粒度的锁</p>
<ul>
<li>Hashtable（同步容器类）：执行每个操作时均持有锁，提供独占式访问；</li>
<li>SynchronizedMap（同步且基于散列的Map，Collections类中定义的内部类）：独占式访问</li>
<li>ConcurrentHashMap：不是将每个方法在同一个锁上同步，因此<strong>不提供独占式访问</strong>；多个线程可并发访问容器。</li>
</ul>
<p>（2）分段锁策略的特性</p>
<ul>
<li>多个读取线程可并发地访问容器；</li>
<li>多个写入线程可并发地修改容器；</li>
<li>读取线程和并发线程可并发地操作容器。</li>
</ul>
<p>（3）ConcurrentHashMap的优势</p>
<ul>
<li>并发环境下提高系统吞吐量；</li>
<li>迭代器不会抛出ConcurrentModificationException。</li>
</ul>
<h5 id="2-3-ConcurrentHashMap结构及分段锁"><a href="#2-3-ConcurrentHashMap结构及分段锁" class="headerlink" title="2.3 ConcurrentHashMap结构及分段锁"></a>2.3 ConcurrentHashMap结构及分段锁</h5><p><img src="/2020/01/12/Java并发编程笔记/4.jpg" alt></p>
<p>如图所示，ConcurrentHashMap被分为多个片段（Segment），同时一个片段被分为多个HashEntry。</p>
<ul>
<li>Segment继承 <code>ReentrantLock</code> ，扮演锁的角色；</li>
<li>HashEntry用于存储键值对数据（注意：ConcurrentHashMap中key和value均不得为null）；</li>
<li>修改HashEntry数组的数据时，线程必须<strong>先获得对应的Segment锁</strong>。</li>
</ul>
<h4 id="3-同步工具类"><a href="#3-同步工具类" class="headerlink" title="3. 同步工具类"></a>3. 同步工具类</h4><blockquote>
<p>同步工具类是指能根据其自身的状态来<strong>协调线程的控制流</strong>的对象。</p>
</blockquote>
<p>示例：阻塞队列（BlockingQueue）、信号量（Semaphore）、栅栏（Barrier）、闭锁（Latch）</p>
<h5 id="3-1-信号量"><a href="#3-1-信号量" class="headerlink" title="3.1 信号量"></a>3.1 信号量</h5><p>信号量通过管理一组虚拟的许可来控制操作，其具体实现如下：</p>
<ul>
<li>控制同时访问数</li>
<li>实现资源池</li>
<li>对容器施加边界</li>
</ul>
<h5 id="3-2-闭锁"><a href="#3-2-闭锁" class="headerlink" title="3.2 闭锁"></a>3.2 闭锁</h5><p>闭锁是指可以<strong>延迟线程的进度</strong>直到其到达终止状态，其特性如下：</p>
<ul>
<li><p>一次性对象，<strong>不能被重置</strong>；</p>
</li>
<li><p>闭锁到达终止状态前，不允许任何线程通过；</p>
</li>
<li><p>闭锁到达终止状态后，允许线程通过；</p>
</li>
<li><p>用以确保某些活动直到其它活动都完成后再开始，例如待所需资源全部加载后才开始执行初始化。</p>
</li>
</ul>
<h5 id="3-3-栅栏"><a href="#3-3-栅栏" class="headerlink" title="3.3 栅栏"></a>3.3 栅栏</h5><p>栅栏能<strong>阻塞一组线程</strong>直到某个事件发生</p>
<ul>
<li>栅栏要求线程同时到达栅栏位置，方能继续执行；</li>
<li>非一次性；</li>
<li>闭锁用于<em>等待事件</em>，栅栏用于<em>等待线程</em>。</li>
</ul>
<h3 id="三、任务执行策略"><a href="#三、任务执行策略" class="headerlink" title="三、任务执行策略"></a>三、任务执行策略</h3><h4 id="1-串行与并行执行任务"><a href="#1-串行与并行执行任务" class="headerlink" title="1. 串行与并行执行任务"></a>1. 串行与并行执行任务</h4><h5 id="1-1-串行执行任务"><a href="#1-1-串行执行任务" class="headerlink" title="1.1 串行执行任务"></a>1.1 串行执行任务</h5><p><em>显然，服务器单线程串行执行任务，低吞吐量 &amp; 低响应速度</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket connection = socket.accept(); <span class="comment">// 接收请求</span></span><br><span class="line">            handleRequest(connection); <span class="comment">// 处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，服务器只有一个主线程来监听80端口、接收并处理请求。简言之，每次只能有一个请求被处理，后续请求必须等待前序请求完成后才能被服务器接收、处理。</p>
<h5 id="1-2-并行执行任务"><a href="#1-2-并行执行任务" class="headerlink" title="1.2 并行执行任务"></a>1.2 并行执行任务</h5><p><em>主线程监听端口、接收并分发请求，同时创建新线程来处理请求</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); <span class="comment">// 主线程接收请求</span></span><br><span class="line">            Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection); <span class="comment">// 主线程创建新线程处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(command).start(); <span class="comment">// 启动新线程，处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性：</p>
<ul>
<li><strong>在不超过服务器处理能力的前提下</strong>，提高了服务器吞吐量和响应速度；</li>
<li>主线程监听端口、接收并分发请求，创建新线程；</li>
<li>处理请求的线程<strong>并发地处理请求</strong>。</li>
</ul>
<h5 id="1-3-主线程频繁新建线程的风险"><a href="#1-3-主线程频繁新建线程的风险" class="headerlink" title="1.3 主线程频繁新建线程的风险"></a>1.3 主线程频繁新建线程的风险</h5><ul>
<li>创建和销毁线程的开销非常高；</li>
<li>大量线程带来的资源消耗会降低性能；</li>
<li>线程数量超过限制会造成系统异常。</li>
</ul>
<h4 id="2-Executor框架-——-异步任务执行框架"><a href="#2-Executor框架-——-异步任务执行框架" class="headerlink" title="2. Executor框架 —— 异步任务执行框架"></a>2. Executor框架 —— 异步任务执行框架</h4><blockquote>
<p>异步任务执行：将<strong>任务的提交过程</strong>和<strong>执行过程</strong>解耦合</p>
</blockquote>
<h5 id="2-1-为何使用Executor框架？"><a href="#2-1-为何使用Executor框架？" class="headerlink" title="2.1 为何使用Executor框架？"></a>2.1 为何使用Executor框架？</h5><p>前述两种<em>任务执行策略</em>（单线程串行执行任务、新建线程并行执行任务）均存在一定的不足。在异步任务执行框架中将任务的提交和执行解耦，其中通过<strong>线程池</strong>实现对线程的高效管理。</p>
<h5 id="2-2-Executor框架的基础-——-生产者-消费者模式"><a href="#2-2-Executor框架的基础-——-生产者-消费者模式" class="headerlink" title="2.2 Executor框架的基础 —— 生产者-消费者模式"></a>2.2 Executor框架的基础 —— 生产者-消费者模式</h5><ul>
<li>生产者：提交任务的操作</li>
<li>消费者：执行任务的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">50</span>; <span class="comment">// 线程池长度</span></span><br><span class="line">    <span class="comment">// newFixedThreadPool方法将返回一个固定长度的线程池，其长度不再变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec</span><br><span class="line">        = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Connection connection = socket.accept();</span><br><span class="line">         	Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(command); <span class="comment">// 线程池负责管理线程以执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>通过实现 Executor接口，可制定更丰富的执行策略</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Executor框架结构"><a href="#2-3-Executor框架结构" class="headerlink" title="2.3 Executor框架结构"></a>2.3 Executor框架结构</h5><p><img src="/2020/01/12/Java并发编程笔记/5.jpg" alt></p>
<p><em>Executor框架包括以下三个部分：</em></p>
<ol>
<li><p><strong>任务</strong>：被执行的任务需要实现Runnable接口或Callable接口；</p>
</li>
<li><p><strong>执行</strong>：线程执行任务，包括Executor接口和最重要的<strong>ThreadPoolExecutor</strong>类；</p>
</li>
<li><p><strong>异步计算</strong>：包括Future接口及实现Future接口的FutureTask类。</p>
</li>
</ol>
<h5 id="2-4-Executor框架的执行过程"><a href="#2-4-Executor框架的执行过程" class="headerlink" title="2.4 Executor框架的执行过程"></a>2.4 Executor框架的执行过程</h5><p>（1）创建任务对象</p>
<p>创建实现Runnable接口或Callable接口的任务对象。</p>
<p><em>实现 Runnable接口，重写 run 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>实现 Callable 接口，重写 call 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"实现Callable接口，重写Call方法，有返回值"</span>;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Runnable接口与Callable接口的区别：</strong></p>
<ul>
<li>Runnable接口无返回值；</li>
<li>Callable接口有返回值，需要声明抛出异常。</li>
</ul>
<p><em>通过工厂类 Executors 的 Callable(Runnable task) 方法可将 Runnable 对象包装成 Callable 对象</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Object&gt; task = Executors.callable(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<p>（2）执行任务</p>
<blockquote>
<p>通过实现java.util.concurrent.ExecutorService接口的对象来执行任务</p>
</blockquote>
<ol>
<li>将Runnable对象交给ExecutorService执行，调用<strong>execute</strong>方法，无返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Runnable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象，<strong>但调用Future对象的get方法，返回值为null</strong>。【源码分析见 2.5】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;Object&gt; future = (Future&lt;Object&gt;) es.submit(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(future.get()==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"future.get()返回null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将Callable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">				<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure>

<p>（3）关闭线程池</p>
<ol>
<li>对于执行ExecutorService的execute方法，调用shutdown方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"></span><br><span class="line">es.shutdown(); <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于执行ExecutorService的submit方法，主线程可执行FutureTask.get()方法等待任务执行完毕，也可通过FutureTask.cancel()方法取消任务的执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(future.get());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解"><a href="#2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解" class="headerlink" title="2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解"></a>2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解</h5><p> <strong>AbstractExecutorService</strong>类实现了ExecutorService接口并实现了<strong>submit()</strong> 方法，ThreadPoolExecutor类从AbstractExecutorService类继承了submit方法。</p>
<p><em>基于 JDK 1.8的源码，分析如下：</em></p>
<p>AbstractExecutorService类实现了ExecutorService接口，实现submit()方法。将Runnable对象交给 ExecutorService去处理且调用<code>submit(Runnable task)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask); <span class="comment">// 调用ThreadPoolExecutor类的execute方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部通过调用<code>newTaskFor(Runnable runnable, T value)</code>方法返回一个<code>FutureTask</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造<code>FutureTask</code>对象时，通过调用<code>Executors.callable(runnable, result)</code>方法<strong>将Runnable对象包装成Callable对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于提交的 Callable 对象，AbstractExecutorService 类同样是调用 newTaskFor 方法 返回一个 FutureTask 对象：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-线程池-——-高效地管理线程的生命周期"><a href="#3-线程池-——-高效地管理线程的生命周期" class="headerlink" title="3. 线程池 —— 高效地管理线程的生命周期"></a>3. 线程池 —— 高效地管理线程的生命周期</h4><p><em>重要参数：</em></p>
<ul>
<li><p>corePoolSize：线程池的目标大小，即无任何任务执行时线程池的大小，且仅当工作队列已满才会产生大于此值的线程数量。</p>
</li>
<li><p>maximumPoolSize：线程池最大同时活动线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。线程空闲时间大于存活时间，被标记为“可回收”；活动线程数大于corePoolSize时，回收标记为“可回收”的空闲线程。</p>
</li>
</ul>
<p><strong><em>两个重要的问题：</em></strong></p>
<ol>
<li><p>为什么要使用线程池，而不是直接手动创建线程？</p>
<ul>
<li><p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。</p>
</li>
<li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>为什么要通过ThreadPoolExecutor创建线程池，而不是通过工厂类Executors？<ul>
<li>使开发者更加明确线程池的运行规则，避免资源耗尽的风险。</li>
<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integet.MAX_VALUE，可能会堆积大量的请求。</li>
<li>CachedThreadPool 和 ScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程。</li>
<li>上述四种方式其本质还是调用ThreadPoolExecutor。</li>
</ul>
</li>
</ol>
<h5 id="3-1-通过工厂类Executors的静态工厂方法"><a href="#3-1-通过工厂类Executors的静态工厂方法" class="headerlink" title="3.1 通过工厂类Executors的静态工厂方法"></a>3.1 通过工厂类Executors的静态工厂方法</h5><p>通过调用工厂类Executors中的静态工厂方法，可产生如下类型的线程池：</p>
<ul>
<li>newFixedThreadPool  固定长度</li>
<li>newCachedThreadPool 可缓存</li>
<li>newSingleThreadExecutor 单线程</li>
<li>newScheduledThreadPool 延时/定时执行任务，固定长度</li>
</ul>
<p>（1）newFixedThreadPool</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为指定值nThread，keepAliveTime设为0。</p>
</li>
<li><p>固定长度的线程池。因corePoolSize为nThread，故每提交一个任务就创建一个线程，直到总数为nThreads。</p>
</li>
<li><p>keepAliveTime为0，线程不会超时。</p>
</li>
<li><p>线程执行过程中异常中断，会新建线程以补充。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）newCachedThreadPool</p>
<ul>
<li><p>corePoolSize设为0，maximumPoolSize设为Integer.MAX_VALUE，keepAliveTime设为60秒。</p>
</li>
<li><p>无可用线程时新建线程，有可用线程时则复用该线程。</p>
</li>
<li><p>因maximumPoolSize设为Integer.MAX_VALUE，即线程数最大值为2147483647。</p>
</li>
<li><p>线程存活时间为60秒，避免大量空闲线程对资源的消耗。</p>
</li>
<li><p>同步任务队列SynchronousQueue<runnable>。</runnable></p>
</li>
<li><p>此线程池适用于大量短暂的异步任务。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）newSingleThreadExecutor</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为1，keepAliveTime设为0。</p>
</li>
<li><p>首次提交任务时创建单个线程，且仅维持一个线程。</p>
</li>
<li><p>当线程在关闭前异常终止，程序新建一个线程以执行后续任务。</p>
</li>
<li><p>确保任务串行执行。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法返回的是FinalizableDelegatedExecutorService对象，其内部保存一个ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Executors类的静态方法newSingleThreadExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类FinalizableDelegatedExecutorService，其继承自Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e; <span class="comment">// 内部保存一个ExecutorService对象</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）newScheduledThreadPool</p>
<ul>
<li><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>可延时执行阻塞任务的队列。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法指定线程池基本大小、返回ScheduledThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ScheduledThreadPoolExecutor类，其调用父类ThreadPoolExecutor的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-ThreadPoolExecutor"><a href="#3-2-ThreadPoolExecutor" class="headerlink" title="3.2 ThreadPoolExecutor"></a>3.2 ThreadPoolExecutor</h5><p>（暂无）</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] 《Java并发编程实战》Goetz B. 著，童云兰译</p>
<p>[2] <a href="https://www.infoq.cn/article/ConcurrentHashMap/" target="_blank" rel="noopener">https://www.infoq.cn/article/ConcurrentHashMap/</a></p>
<p>[3] <a href="http://www.bubuko.com/infodetail-1518587.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1518587.html</a></p>
<p>[4] <a href="https://blog.csdn.net/tongdanping/article/details/79604637" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79604637</a></p>
<p>[5] <a href="https://www.cnblogs.com/xifengxiaoma/p/11477136.html" target="_blank" rel="noopener">https://www.cnblogs.com/xifengxiaoma/p/11477136.html</a></p>
<p>[6] <a href="https://www.cnblogs.com/jiansen/p/7351872.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiansen/p/7351872.html</a></p>
<p>[7] <a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a></p>
<p>[8] <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之动态规划</title>
    <url>/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>通过阅读他人优秀的文章，基于经典的青蛙跳台阶问题，深入地学习动态规划建模过程。通过递归算法、自顶向下的备忘录算法及自低向上的动态规划算法，解决实际问题。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>动态规划（Dynamic Programming）与<strong>分治法</strong>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。</p>
<p>用一个表来记录所有已解的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，这就是动态规划法的基本思路。</p>
<h4 id="二、建模"><a href="#二、建模" class="headerlink" title="二、建模"></a>二、建模</h4><p>对问题建模前，须明确以下三个重要概念：</p>
<blockquote>
<p>1、最优子结构</p>
<p>2、边界</p>
<p>3、状态转移方程</p>
</blockquote>
<h4 id="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"><a href="#三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程" class="headerlink" title="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"></a>三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程</h4><h5 id="1-对青蛙跳台阶问题的图解"><a href="#1-对青蛙跳台阶问题的图解" class="headerlink" title="1. 对青蛙跳台阶问题的图解"></a>1. 对青蛙跳台阶问题的图解</h5><p>（本小节图源：<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a> ）</p>
<ul>
<li>每次跳1级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/1.jpg" alt></p>
<ul>
<li>或每次跳2级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/2.jpg" alt></p>
<p>如果站在第n级台阶的角度上，如何到达该层？</p>
<blockquote>
<p>a. 从第n-1级台阶，跳1级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/3.jpg" alt></p>
<blockquote>
<p>b. 从第n-2级台阶，跳2级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/4.jpg" alt></p>
<p>显然，<strong>到达第n级台阶的路线总数等于到达第n-1级和第n-2级之和</strong>。</p>
<h5 id="2-建模"><a href="#2-建模" class="headerlink" title="2. 建模"></a>2. 建模</h5><ul>
<li><p>最优子结构</p>
<p>如上所述，第n级台阶的路线总数等于到达第n-1级和第n-2级之和，即 F(n) = F(n-1) + F(n-2)。</p>
</li>
<li><p>状态转移方程</p>
<p><strong>F(n) = F(n-1) + F(n-2)</strong></p>
</li>
<li><p>边界</p>
<p>F(1) = 1, F(2) = 2</p>
</li>
</ul>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><p>（1）递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（2）备忘录算法（自顶向下）</p>
<p>利用集合Map，避免递归算法中的重复计算部分，提高算法效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N, HashMap&lt;Integer, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(N))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(N);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">        map.put(N, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（3）动态规划（自底向上）</p>
<p>备忘录算法中须保存所有子状态，若仅仅保存递推所需的前两个子状态，便能优化算法的空间复杂度。</p>
<blockquote>
<p>通过自底向上的递推，仅仅利用常数额外空间，优化算法的时间和空间复杂度，这便是动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp; <span class="comment">// 更新最新的子状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、更加复杂的动态规划——国王与金矿问题"><a href="#四、更加复杂的动态规划——国王与金矿问题" class="headerlink" title="四、更加复杂的动态规划——国王与金矿问题"></a>四、更加复杂的动态规划——国王与金矿问题</h4><p>问题：有一个国家发现了n座金矿，每座金矿的黄金储量不同，且每座金矿需要参与挖掘的工人数也不同。参与挖矿工人的总数是w。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要想得到尽可能多的黄金，应该选择挖取哪几座金矿？</p>
<p>（本小节图源：<a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a> ）</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/5.jpg" alt></p>
<h5 id="1-建模"><a href="#1-建模" class="headerlink" title="1. 建模"></a>1. 建模</h5><blockquote>
<p>n：金矿数量；w：总的工人数；g[]：保存每座金矿的矿藏量；p[]：保存每座金矿的用工数</p>
</blockquote>
<p>建模过程中，需要明确最优子结构、状态转移方程和边界这三个要素。</p>
<p>（1）确定最优子结构</p>
<p>以10名工人开挖5座金矿为例。其最优子结构分为如下两种情况：</p>
<ul>
<li>若不挖第5座金矿，则最优解为10人开挖4座金矿的最优解；</li>
<li>若挖第5座金矿，则需要找到剩下的人挖剩余的4座金矿的最优解；</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/6.jpg" alt></p>
<blockquote>
<p>显然，10人挖5座金矿的最优解是这两种子状态的较大值</p>
</blockquote>
<p>（2）确定状态转移方程</p>
<ul>
<li>若第n座金矿有足够的人工开挖，则w个工人开挖n座金矿的情形，满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = max(F(n-1, w), F(n-1, w-p[n-1])+g(n-1)), n&gt;1, w&gt;=p[n-1]</p>
</blockquote>
<ul>
<li>若w个工人不能满足开采第n座金矿所需的工人数，则满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = F(n-1, w), n&gt;1, w&lt;p[n-1]</p>
</blockquote>
<p>（3）确定边界</p>
<ul>
<li>若金矿数仅为1，且工人数能满足开采该金矿所需的工人数，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = g[0], n==1, w&gt;=p[0]</p>
</blockquote>
<ul>
<li>若金矿数为1，但工人总数不满足要求，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = 0, n==1, w&lt;p[0]</p>
</blockquote>
<h5 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2. 算法实现"></a>2. 算法实现</h5><p>（1）递归解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = getMaxGold(n-<span class="number">1</span>, w, g, p);</span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p) + g[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>（2）备忘录算法</p>
<blockquote>
<p>类似于青蛙跳问题中的备忘录算法，利用集合Map保存子状态，其中HashMap的Key是包含金矿数n和工人数w的对象，Value是最多的开采量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p, HashMap&lt;KeyObject, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject a_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(a_obj)) &#123;</span><br><span class="line">        a = map.get(a_obj);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        a = getMaxGold(n-<span class="number">1</span>, w, g, p, map);</span><br><span class="line">        map.put(a_obj, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject b_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(b_obj)) &#123;</span><br><span class="line">        b = map.get(b_obj) + g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p, map);</span><br><span class="line">        map.put(b_obj, b);</span><br><span class="line">        b += g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类用于HashMap中的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyObject</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(n*w)</li>
</ul>
<p>==（3）动态规划算法==</p>
<p>以10名工人挖5座金矿为例，可作下表</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/7.jpg" alt></p>
<p>表中，每一行的所有数据均可<strong>由上一行数据推导得到</strong>，因而动态规划算法可基于此规律，利用前一行数据推导当前行数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] preResult = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>]; <span class="comment">// w+1列，保存上一行数据</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;p[<span class="number">0</span>]) &#123;</span><br><span class="line">            preResult[j] = <span class="number">0</span>; <span class="comment">// 当金矿数为1，但工人总数无法满足开采要求时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            preResult[j] = g[<span class="number">0</span>]; <span class="comment">// 金矿数为1，且工人总数满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> preResult[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="comment">// 外循环中，i为当前金矿索引；内循环中，j为工人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;p[i]) &#123;</span><br><span class="line">                <span class="comment">// 若j个工人不能满足开采第i+1座金矿所需的工人数</span></span><br><span class="line">                result[j] = preResult[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若第i+1座金矿有足够的人工开挖，则j个工人开挖i+1座金矿</span></span><br><span class="line">                result[j] = Math.max(preResult[j], preResult[j-p[i]]+g[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            preResult[j] = result[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(w)</li>
</ul>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a></p>
<p>[2] <a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习之虚拟机</title>
    <url>/2019/11/11/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>通读周志明先生的《深入理解Java虚拟机》一书，学习了Java虚拟机的内存模型，内存管理机制，常见的垃圾回收算法和不同类型的垃圾收集器，以及字节码文件的结构。现整理成笔记，温故而知新！</p>
<a id="more"></a>

<h3 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h3><h4 id="1-Java内存区域图示如下："><a href="#1-Java内存区域图示如下：" class="headerlink" title="1. Java内存区域图示如下："></a>1. Java内存区域图示如下：</h4><p><img src="/2019/11/11/Java学习之虚拟机/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%A4%BA%E6%84%8F.png" alt></p>
<p>值得注意的是：<strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>、<strong>堆（Heap）</strong>、<strong>方法区（Method Area）</strong>：</p>
<ol>
<li><p>虚拟机栈主要与方法调用相关，存储的局部变量表中保存<strong>对象引用</strong>；</p>
</li>
<li><p>堆：存放所有的对象实例；</p>
</li>
<li><p>方法区：与编译相关，存储虚拟机加载的类信息、<strong>静态变量</strong>、常量等；</p>
</li>
<li><p>运行时常量池：编译生成的字面量和符号引用。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/2.png" alt></p>
<h4 id="2-HotSpot虚拟机新建对象过程"><a href="#2-HotSpot虚拟机新建对象过程" class="headerlink" title="2. HotSpot虚拟机新建对象过程"></a>2. HotSpot虚拟机新建对象过程</h4><p>以常见的HotSpot为例，介绍其新建普通 Java对象的过程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BAnew%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>（1）在堆中分配内存的两种方式：</p>
<ul>
<li><p>指针碰撞：内存区域规整（未使用区域与已使用区域分界）时，仅需要移动指针</p>
</li>
<li><p>空闲列表：因内存区域杂乱无章，虚拟机维持记录可用内存区域的表</p>
</li>
</ul>
<p><strong>（2）两种保证分配内存时线程安全的方法：</strong></p>
<ul>
<li><p>同步机制，CAS + 失败重试</p>
</li>
<li><p><strong>每个线程</strong>单独预分配一块内存区域，称之为<strong>本地线程分配缓冲（TLAB）</strong></p>
</li>
</ul>
<p>（3）对象的内存布局：</p>
<ol>
<li><p>对象头：保存运行时数据，如哈希码、GC分代年龄等；另一部分保存指向类元数据的<strong>类型指针</strong></p>
</li>
<li><p>实例数据部分</p>
</li>
<li><p>填充位</p>
</li>
</ol>
<h4 id="3-对象的访问方式"><a href="#3-对象的访问方式" class="headerlink" title="3. 对象的访问方式"></a>3. 对象的访问方式</h4><p>访问对象的途径主要是通过句柄和直接访问：</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p><strong>对象类型数据</strong>是指该实例所属的类</p>
<p>查找对象的元数据信息未经过对象本身</p>
<p>优点：垃圾收集需要调整对象所在内存地址时，不影响reference；</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p>查找对象的元数据信息须经过对象本身</p>
<p>优点：访问速度快</p>
</blockquote>
<h4 id="4、内存分配策略"><a href="#4、内存分配策略" class="headerlink" title="4、内存分配策略"></a>4、内存分配策略</h4><p>具体的内存分配策略取决于 GC组合、JVM参数设置：</p>
<ol>
<li><p>对象优先在新生代 Eden 区分配，该区域不足时，发起 Minor GC；</p>
</li>
<li><p>占用大内存的对象直接进入老年代；</p>
</li>
<li><p>寿命长的对象进入老年代（根据对象年龄计数器来判断）；</p>
</li>
<li><p>Survivor 空间中相同年龄的对象达到一半空间时，年龄大于或等于该年龄的对象可进入老年代；</p>
</li>
<li><p>老年代为 Minor GC提供空间分配担保。</p>
</li>
</ol>
<h3 id="二、GC工作区域"><a href="#二、GC工作区域" class="headerlink" title="二、GC工作区域"></a>二、GC工作区域</h3><p>在 JVM中，虚拟机栈、本地方法栈和程序计数器属于线程私有，随线程结束而释放内存。JVM中的GC关注的是<strong>方法区</strong>和<strong>堆</strong>。</p>
<h4 id="1-回收堆"><a href="#1-回收堆" class="headerlink" title="1. 回收堆"></a>1. 回收堆</h4><h5 id="1-1-如何判断对象内存可回收？"><a href="#1-1-如何判断对象内存可回收？" class="headerlink" title="1.1 如何判断对象内存可回收？"></a>1.1 如何判断对象内存可回收？</h5><p><strong>可达性分析算法</strong>：根搜索方法，通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain）。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg" alt></p>
<h5 id="1-2-Java中可作为GC-Roots的四种对象："><a href="#1-2-Java中可作为GC-Roots的四种对象：" class="headerlink" title="1.2 Java中可作为GC Roots的四种对象："></a>1.2 Java中可作为GC Roots的四种对象：</h5><ul>
<li><p>虚拟机栈的本地变量表中引用的对象</p>
</li>
<li><p>方法区类静态属性引用的对象</p>
</li>
<li><p>方法区常量引用的对象</p>
</li>
<li><p>本地方法栈Native方法引用的对象</p>
</li>
</ul>
<h5 id="1-3-经可达性分析后，可回收对象就一定会被回收？"><a href="#1-3-经可达性分析后，可回收对象就一定会被回收？" class="headerlink" title="1.3 经可达性分析后，可回收对象就一定会被回收？"></a>1.3 经可达性分析后，可回收对象就一定会被回收？</h5><p>经可达性分析后，被定为可回收的对象须经历<strong>两次标记</strong>方能被GC回收内存。【重点：finalize()方法】</p>
<h5 id="1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"><a href="#1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？" class="headerlink" title="1.4 JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"></a>1.4 JVM为什么不采用经典的<strong>引用计数</strong>算法来判断对象是否可回收？</h5><p>引用计数算法实现简单，但面临一个重要缺陷：当两个对象互相引用（循环引用）时，相应的内存区域无法被回收，导致<strong>内存泄漏</strong></p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt></p>
<h5 id="1-5-引用分类（是否回收被引用对象所在的内存区域）"><a href="#1-5-引用分类（是否回收被引用对象所在的内存区域）" class="headerlink" title="1.5 引用分类（是否回收被引用对象所在的内存区域）"></a>1.5 引用分类（是否回收被引用对象所在的内存区域）</h5><ol>
<li><p>强引用：new出来的对象引用关系，不会回收；</p>
</li>
<li><p>软引用：有用、非必需，在内存溢出前进行二次回收；</p>
</li>
<li><p>弱引用：生存至下一次GC工作前，一旦GC开始回收内存，则直接回收其对象；</p>
</li>
<li><p>虚引用：无法通过虚引用取得对象，仅能在此对象被回收时通知系统。</p>
</li>
</ol>
<h4 id="2、回收方法区"><a href="#2、回收方法区" class="headerlink" title="2、回收方法区"></a>2、回收方法区</h4><p>方法区待回收的内容主要为：废弃常量 和 无用的类。</p>
<p>（1）废弃常量：当常量池中的常量不被任何对象引用时，则可以清理出常量池。</p>
<p>（2）无用的类：无用的类须满足下述三个条件，</p>
<ul>
<li><p>Java堆中该类所有的实例均已被回收；</p>
</li>
<li><p>该类的加载器ClassLoader已被回收；</p>
</li>
<li><p>无法通过反射机制访问该类的方法。</p>
</li>
</ul>
<h3 id="三、回收算法"><a href="#三、回收算法" class="headerlink" title="三、回收算法"></a>三、回收算法</h3><p>JVM 针对 Java堆 采用的回收算法主要分为：<strong>标记-清除算法、复制算法和标记-整理算法</strong>；采用的策略为：分代收集算法，即新生代采用复制算法，老年代采用标记-清除算法和标记-整理算法</p>
<h4 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h4><h5 id="1-1-标记-清除（Mark-Sweep）算法"><a href="#1-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="1.1 标记-清除（Mark-Sweep）算法"></a>1.1 标记-清除（Mark-Sweep）算法</h5><p>在标记阶段，由<strong>根节点开始经可达性分析</strong>，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象；</p>
<p>在清除阶段，清除所有未被标记的对象。</p>
<ul>
<li><p><em>特点：将循环引用标记为不可达，解决了引用计数算法无法处理循环引用的问题.</em></p>
</li>
<li><p><em>缺点：1、效率低；2、易导致内存区域不规整（即大量不连续的内存碎片）。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-2-复制（Copying）算法"><a href="#1-2-复制（Copying）算法" class="headerlink" title="1.2 复制（Copying）算法"></a>1.2 复制（Copying）算法</h5><p>内存对半分，先使用一半，需要清理时先将存活对象转移至保留内存区域，随后全部回收刚使用过的一半内存。</p>
<p><strong>适用于新生代</strong>中对象存活率低、可回收对象比例高的场景。</p>
<ul>
<li><em>优点：1、无内存碎片；2、效率高。</em></li>
<li><em>缺点：1、实际使用内存仅占一半，浪费资源；2、当对象存活率高时，需要较为频繁的复制操作，效率降低。</em></li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-3-标记-整理（Mark-Compact）算法"><a href="#1-3-标记-整理（Mark-Compact）算法" class="headerlink" title="1.3 标记-整理（Mark-Compact）算法"></a>1.3 标记-整理（Mark-Compact）算法</h5><p>针对老年代中对象存活率高，若使用复制算法，则效率低。</p>
<p>标记-整理算法（或标记-压缩算法）核心在于：标记完成后，将“分散”的存活对象移动至“端集中”区域，随后清理其端边界以外的内存。</p>
<ul>
<li><p><em>优点：1、适用于对象存活率高的场景；2、无内存碎片。</em></p>
</li>
<li><p><em>缺点：标记、整理过程代价高昂。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-4-分代收集（Generational-Collection）算法"><a href="#1-4-分代收集（Generational-Collection）算法" class="headerlink" title="1.4 分代收集（Generational Collection）算法"></a>1.4 分代收集（Generational Collection）算法</h5><p>将 Java堆分为<strong>新生代</strong>和<strong>老年代</strong></p>
<ul>
<li><p>新生代：对象存活率低，垃圾多；</p>
</li>
<li><p>老年代：对象存活率高，垃圾少。</p>
</li>
</ul>
<p>基于上述算法的优缺点，分代收集的策略是：<em>对新生代采用复制算法，对老年代采用标记-清除或标记-整理算法</em> 。</p>
<p>在新生代中，分为：较大的<strong>Eden空间</strong>和两块较小的<strong>Survivor空间</strong>。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt></p>
<ol>
<li><p>在新生代中，先使用Eden和一块Survivor区域，另一块Survivor区域保留，其空间比例一般为8：1：1；</p>
</li>
<li><p>回收时，Eden和Survivor(From)中<strong>存活时间长和大对象直接进入老年代</strong>，其余存活对象进入Survivor(To)区域；</p>
</li>
<li><p>当Survivor(To)区域空间不足时，利用<strong>分配担保机制</strong>，非存活时间长或大对象的存活对象同样被放入老年代中；</p>
</li>
<li><p>清理Eden和Survivor(From)。</p>
</li>
</ol>
<h4 id="2-HotSpot-的算法实现"><a href="#2-HotSpot-的算法实现" class="headerlink" title="2. HotSpot 的算法实现"></a>2. HotSpot 的算法实现</h4><p>（1）在可达性分析算法中，如何快速、精确地找出（枚举）根节点（GC Roots）？</p>
<p>精确：GC进行时停止所有 Java线程，确保分析时引用关系不再变化；</p>
<p>速度：OopMap（Ordinary Object Pointer Map）普通对象指针的Map数据结构，保存对象引用信息。</p>
<p>（2）Safe Point &amp; Safe Region</p>
<blockquote>
<p>安全点：GC中断线程的“位置”</p>
</blockquote>
<h3 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h3><p>重要概念：</p>
<p>（1）在垃圾收集器中，并发（Concurrent）与并行（Parallel）的区别：</p>
<ul>
<li><p>并发：用户进程与垃圾收集进程并发执行。单CPU环境，只能交替执行；多CPU环境，可同时执行。</p>
<blockquote>
<p><em>CMS 在并发标记、清理阶段</em></p>
</blockquote>
</li>
<li><p>并行：用户进程暂停，在多CPU环境中，多条垃圾收集线程可同时执行。</p>
</li>
</ul>
<p>在垃圾收集器中，并发与并行的重要区别在于<strong>前者不用暂停用户进程，后者必须暂停用户进程</strong>，这与常说的线程并发和并行的概念还是有点不同！单核和多核环境只决定了线程能否同时执行。</p>
<p>（2）吞吐量与GC停顿时间的关系</p>
<ul>
<li><p>吞吐量越高，表示CPU利用效率越高</p>
</li>
<li><p>GC停顿时间缩短是以牺牲吞吐量和新生代空间大小换来的</p>
</li>
</ul>
<p>因此，追求更短的 GC停顿时间，适合交互频繁的场景，代价是 CPU利用率下降；追求更高的 CPU利用率，适合计算量大的场景，代价是 GC停顿时间延长。*</p>
<p>（3）Minor GC 和 Full GC</p>
<ul>
<li><p>Minor GC：发生在新生代的垃圾收集动作，GC 频繁且速度快；</p>
</li>
<li><p>Major GC / Full GC：发生在老年代，速度比 Minor GC 慢。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt></p>
<h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p>（1）单线程：单条GC线程完成收集，且必须暂停其它所有用户正常工作线程（中断其它的 Java 线程）；</p>
<p>（2）对于单CPU环境，Serial 没有线程交互开销，最高的单线程收集效率；</p>
<p>（3）Client 模式下默认的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/Serial.jpg" alt></p>
<h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p>（1）多线程：多条GC线程（多核时才可能同时执行），且必须暂停其它所有用户正常工作线程；</p>
<p>（2）除多线程外，ParNew 其余实现与 Serial 相同；</p>
<p>（3）对于单CPU环境，ParNew 存在线程交互开销，效率低于 Serial；</p>
<p>（4）对于多核CPU环境，ParNew 因多线程并行，效率一般高于 Serial；</p>
<p>（5）Server模式下首选的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParNew.jpg" alt></p>
<h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>（1）与 ParNew 在基本实现上相似；</p>
<p>（2）吞吐量优先：在GC停顿时间和CPU效率间平衡选择，不同于 CMS 等收集器追求尽可能短的 GC 停顿时          间；</p>
<p>（3）GC Ergonomics：自适应调节策略。</p>
<p>![](Java学习之虚拟机/Parallel Scavenge.jpg)</p>
<h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p>（1）Serial 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p><img src="/2019/11/11/Java学习之虚拟机/SerialOld.jpg" alt></p>
<h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p>（1）Parallel Scavenge 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p>（3）Parallel Scavenge + Parallel Old 组合：吞吐量优先，适合注重吞吐量和CPU资源敏感的场景</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParallelOld.jpg" alt></p>
<h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p>（1）标记 - 清理 算法</p>
<p>（2）突出点：CMS ( Concurrent Mark Sweep ) 收集器在运行期间，<strong>不需要一直中断其它线程</strong>，因此能实现<strong>最短的 GC 停顿时间</strong></p>
<p>（3）分为以下四个步骤：</p>
<ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清理</p>
</li>
</ul>
<p>其中，并发标记 / 并发清理期间，不暂停其它 CPU 核上的线程，耗时较长；初始标记 / 重新标记期间，需要暂停其它所有线程，耗时较短。</p>
<p>（4）CMS 的不足：</p>
<ul>
<li><p>对CPU资源敏感，使吞吐量下降，CPU利用率降低</p>
</li>
<li><p>并发清理阶段其它用户线程产生的“浮动垃圾”须等到下次GC</p>
</li>
<li><p>潜在的 Concurrent Mode Failure 问题</p>
</li>
<li><p>清理算法产生大量空间碎片</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/CMS.jpg" alt></p>
<h4 id="7-G1-Garbage-First-收集器"><a href="#7-G1-Garbage-First-收集器" class="headerlink" title="7. G1( Garbage-First ) 收集器"></a>7. G1( Garbage-First ) 收集器</h4><p>基本原理：Region + 区域回收优先级</p>
<p>(1) 不再使用 新生代 / 老年代 划分，而是使用 <strong>Region</strong> 划分堆内存区域；</p>
<p>(2) G1追踪不同的 Region，并维护 <strong>优先列表</strong>，由此决定优先GC的区域；</p>
<p>(3) 不同的Region之间的对象引用关系保存在 Remembered Set中（新生代与老年代之间亦是）。</p>
<p><em>优点：</em></p>
<ul>
<li><p>更适合多 CPU的环境；</p>
</li>
<li><p>可独自运作，且对寿命不同的对象也采取不同的策略；</p>
</li>
<li><p>无内存碎片；</p>
</li>
<li><p><strong>可预测的暂停</strong>。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/g1.jpg" alt></p>
<p>运行过程如下：</p>
<ol>
<li><p>初始标记：标记GC Roots直接关联的对象；</p>
</li>
<li><p>并发标记：可达性分析，耗时长、与其它 Java线程并发；</p>
</li>
<li><p>最终标记：Remembered Set Logs中数据（记录并发标记阶段的引用变化）与Remembered Set合并；</p>
</li>
<li><p>筛选回收：有选择地确定GC Region。</p>
</li>
</ol>
<h3 id="五、虚拟机类加载"><a href="#五、虚拟机类加载" class="headerlink" title="五、虚拟机类加载"></a>五、虚拟机类加载</h3><p><strong><em>虚拟机将编译得到的字节码文件加载到内存，经连接、解析等过程，得到可直接使用的 Java 类型的过程，称为类加载</em></strong>。</p>
<p><strong><em>程序运行时期进行</em></strong></p>
<h4 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h4><p>类的生命周期如下图</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt></p>
<h5 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h5><p>加载Class文件过程三个动作：</p>
<ol>
<li><p>通过<strong>非数组类</strong>的全限定名获取二进制字节流，但具体的获取途径并未规定（可以从ZIP包、网络、JSP文件等）；</p>
<blockquote>
<p><em>数组类直接由虚拟机加载，不经过类加载器</em></p>
</blockquote>
</li>
<li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</p>
</li>
<li><p>在内存中生成类的访问入口对象 java.lang.Class。</p>
<blockquote>
<p><em>HotSpot 虚拟机将 Class 对象存放在方法区</em></p>
</blockquote>
</li>
</ol>
<h5 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h5><p><img src="/2019/11/11/Java学习之虚拟机/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E6%B5%81%E7%A8%8B.jpg" alt></p>
<blockquote>
<p>符号引用验证发生于解析阶段，说明<strong>类加载过程各项“工作”是按先后顺序开始，但不一定是前一阶段结束才开始后一阶段，不同阶段的“工作”可并行</strong></p>
</blockquote>
<h5 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h5><p>在方法区为<strong>类静态变量</strong>分配内存并初始化为零值，<strong>final</strong>修饰的<strong>类静态常量</strong>赋给定的初值</p>
<h5 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h5><p>（1）符号引用：存放于常量池中的常量，包括：</p>
<ol>
<li><p>类和接口的全限定名；</p>
</li>
<li><p>字段名和描述符；</p>
</li>
<li><p>方法名和描述符。</p>
</li>
</ol>
<p>（2）解析过程：将符号引用解析、翻译，匹配对应的物理内存地址，即直接引用。</p>
<h5 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h5><p>初始化阶段，执行类构造器的 <code>&lt;clinit&gt;()</code> 方法</p>
<blockquote>
<p>类变量赋值语句 &amp;&amp; 静态代码块</p>
</blockquote>
<h4 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h4><p>双亲委派模型的要点：</p>
<ol>
<li><p>子类加载器先请求父类加载器尝试加载；</p>
</li>
<li><p>父类加载器无法加载时，子类加载器再尝试加载；</p>
</li>
<li><p><strong>所有的加载请求首先被启动类加载器处理</strong>。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt></p>
<h3 id="六、并发"><a href="#六、并发" class="headerlink" title="六、并发"></a>六、并发</h3><h4 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h4><blockquote>
<p>定义了<strong>线程共享的变量</strong>从虚拟机内存中被读取或写入的底层实现</p>
<p>线程共享变量：实例字段、静态字段、构成数组对象的元素</p>
</blockquote>
<h4 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1 主内存与工作内存"></a>1.1 主内存与工作内存</h4><ul>
<li><p>工作内存中保存主内存中（共享）变量的拷贝副本；</p>
</li>
<li><p>工作内存中还保存了<strong>线程私有的变量</strong>；</p>
</li>
<li><p>线程对（共享）变量的读写操作必须经过工作内存才可与主内存交互；</p>
</li>
<li><p>线程间（共享）变量值的传递须借助主内存。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<h4 id="1-2-内存间交互"><a href="#1-2-内存间交互" class="headerlink" title="1.2 内存间交互"></a>1.2 内存间交互</h4><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">作用对象</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock</td>
<td align="center">主内存中的变量</td>
<td align="center">锁定状态，线程独占</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">主内存中的变量</td>
<td align="center">解除锁定状态</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">主内存中的变量</td>
<td align="center">将变量值传输至对应的工作内存中</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">工作内存中的变量</td>
<td align="center">read 操作后，将变量值放入工作内存的变量副本中</td>
</tr>
<tr>
<td align="center">use</td>
<td align="center">工作内存中的变量</td>
<td align="center">使用变量值</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">工作内存中的变量</td>
<td align="center">赋值</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">工作内存中的变量</td>
<td align="center">将变量值传输至主内存中</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">主内存中的变量</td>
<td align="center">store 操作后，变量值存入主内存的变量中</td>
</tr>
</tbody></table>
<h4 id="1-3-原子性、可见性和有序性"><a href="#1-3-原子性、可见性和有序性" class="headerlink" title="1.3 原子性、可见性和有序性"></a>1.3 原子性、可见性和有序性</h4><p>（1）原子性</p>
<ol>
<li>read、load、use、assign、store、write 均为原子性的变量操作，实现<strong>基本数据类型的访问和读写操作是原子性的</strong>；</li>
<li>lock 和 unlock 操作，更大范围内实现原子性（<strong>synchronized</strong> 关键字）。</li>
</ol>
<p>（2）可见性</p>
<ol>
<li><strong>volatile</strong> 关键字，<strong>最轻量级的同步机制</strong>，其修饰的变量对所有线程是可见的；</li>
<li>final 关键字；</li>
<li><strong>synchronized</strong> 关键字，同步代码块。</li>
</ol>
<p>（3）有序性</p>
<ol>
<li><em>线程内表现为串行的语义</em> ：在本线程内观察，操作是有序的；</li>
<li><em>指令重排</em> &amp; <em>工作内存与主内存同步延迟</em> ： 从另一个线程观察，被观察线程内的操作是无序的。</li>
</ol>
<h4 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2. Java线程"></a>2. Java线程</h4><blockquote>
<p>线程将进程的<strong>资源分配</strong>和<strong>执行调度</strong>分开，线程共享进程资源（内存地址、文件I/O等），线程独立被CPU调用、执行。</p>
</blockquote>
<p>实现线程的三种方式：内核线程实现、用户线程实现、用户线程加轻量级进程的混合实现。</p>
<h5 id="2-1-内核线程实现"><a href="#2-1-内核线程实现" class="headerlink" title="2.1 内核线程实现"></a>2.1 内核线程实现</h5><p><em>内核线程（Kernel-Level Thread, KLT）*：由操作系统内核完成线程切换、调度、任务映射等操作，用户程序通过 *轻量级进程 （Light Weight Process, LWP)</em> 接口使用内核线程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：系统调用代价高</p>
</blockquote>
<h5 id="2-2-用户线程实现"><a href="#2-2-用户线程实现" class="headerlink" title="2.2 用户线程实现"></a>2.2 用户线程实现</h5><p><em>用户线程（User Thread, UT）</em> ：建立在用户空间的线程库，用户线程的建立、同步、调度和销毁在用户态中完成。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：用户态操作，代价小；实现过程异常复杂。</p>
</blockquote>
<h5 id="2-3-用户线程加轻量级进程的混合实现"><a href="#2-3-用户线程加轻量级进程的混合实现" class="headerlink" title="2.3 用户线程加轻量级进程的混合实现"></a>2.3 用户线程加轻量级进程的混合实现</h5><blockquote>
<p>轻量级进程是用户线程与内核线程之间的桥梁</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] 《深入理解Java虚拟机》周志明 著</p>
<p>[2] <a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p>
<p>[3] <a href="https://blog.csdn.net/wen7280/article/details/54428387" target="_blank" rel="noopener">https://blog.csdn.net/wen7280/article/details/54428387</a></p>
<p>[4] <a href="https://www.jianshu.com/p/114bf4d9e59e" target="_blank" rel="noopener">https://www.jianshu.com/p/114bf4d9e59e</a></p>
<p>[5] <a href="https://www.jianshu.com/p/50d5c88b272dc" target="_blank" rel="noopener">https://www.jianshu.com/p/50d5c88b272dc</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC框架学习笔记</title>
    <url>/2019/08/26/Spring%20MVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><strong>MVC模式</strong></p>
<blockquote>
<p>Model：数据模型层，封装用户的输入/输出数据</p>
<p>Controller：控制层，前、后端交互</p>
<p>View：视图层，前端显示</p>
</blockquote>
<hr>
<h4 id="1-Spring-MVC流程"><a href="#1-Spring-MVC流程" class="headerlink" title="1. Spring MVC流程"></a>1. Spring MVC流程</h4><p>Spring MVC框架流程图如下，其中最核心的是<strong>前端控制器（DispatcherServlet）</strong></p>
<p>![](Spring MVC框架学习笔记/Spring MVC框架流程图.png)</p>
<p><em>流程描述如下：</em></p>
<ol>
<li><p>用户请求被拦截、发送至前端控制器（DispatcherServlet）；</p>
</li>
<li><p>DispatcherServlet请求处理器映射器（HandlerMapping）查找相应的处理器（Handler），HandlerMapping将Handler、Intercepter（拦截器）返回给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet根据返回的Handler，请求处理器适配器（HandlerAdapter）执行Handler；</p>
</li>
<li><p>HandlerAdapter调用自己的Handler方法，利用 Java的<strong>反射机制</strong>执行具体的Controller方法，获得ModelAndView 视图对象；</p>
</li>
<li><p>HandlerAdapter将ModelAndView 视图对象发送给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet请求视图处理器（ViewResolver）解析，返回结果；</p>
</li>
<li><p>DispatcherServlet渲染视图，<strong>将Model中的模型数据填充到View视图的Request域</strong>，生成最终的View视图；</p>
</li>
<li><p>DispatcherServlet发送Response响应至用户界面。</p>
</li>
</ol>
<h4 id="2-DispatcherServlet"><a href="#2-DispatcherServlet" class="headerlink" title="2. DispatcherServlet"></a>2. DispatcherServlet</h4><p>DispatcherServlet是Spring MVC处理Http请求的核心组件：</p>
<p>（1）其顶级父类是HttpServlet，因此DispatcherServlet本质上是一个Servlet；</p>
<p>（2）其中的doService方法负责处理request请求；</p>
<p>（3）核心方法<strong>doDispatch</strong>负责处理拦截，转发请求，调用处理器获得结果，并得到结果视图。</p>
<p>web.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用配置的springmvc.xml文件对DispatcherServlet进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置拦截url符合".action"的请求至前端处理器DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-HandlerMapping"><a href="#3-HandlerMapping" class="headerlink" title="3. HandlerMapping"></a>3. HandlerMapping</h4><p>HandlerMapping常见有：BeanNameUrlHandlerMapping、SimpleUrlHandlerMapping、ControllerClassNameHandlerMapping。</p>
<p>Springmvc.xml配置如下</p>
<p>（1）BeanNameUrlHandlerMapping</p>
<p>映射规则：将bean的name作为url进行匹配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器BeanNameUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置被url映射的Handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/test.action"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）SimpleUrlHandlerMapping</p>
<p>通过<property>标签配置url与handler的映射关系</property></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器SimpleUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_A"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_B"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Handler --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA.action"</span>&gt;</span>ControllerTestA<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB.action"</span>&gt;</span>ControllerTestB<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）ControllerClassNameHandlerMapping</p>
<p>采用CoC惯例优先原则</p>
<ul>
<li><p>对普通的Controller类，将类名“xxxController”映射至“/xxx*”的请求url</p>
</li>
<li><p>对MultiActionController（多动作控制器）类，会将特定的方法“yyy”映射至“/xxx/yyy.action”的请求url</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerBeanNameHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-HandlerAdapter"><a href="#4-HandlerAdapter" class="headerlink" title="4. HandlerAdapter"></a>4. HandlerAdapter</h4><p>（1）SimpleControllerHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>SimpleControllerHandlerAdapter要求编写实现Controller接口的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	modelAndView.addObject();</span><br><span class="line">	modelAndView.setViewName();</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）HttpRequestHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>HttpRequestHandlerAdapter要求编写实现<strong>HttpRequestHandler接口</strong>的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.HttpRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">	request.setAttribute();</span><br><span class="line">	request.getRequestDispatcher();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpRequestHandlerAdapter与 SimpleControllerHandlerAdapter相比优点在于：</em></strong></p>
<ul>
<li>前者可以通过request获得http请求信息，及设置返回对象response的格式，如 JSON串！</li>
</ul>
<h4 id="5-注解方式使用HandlerMapping和HandlerAdapter"><a href="#5-注解方式使用HandlerMapping和HandlerAdapter" class="headerlink" title="5. 注解方式使用HandlerMapping和HandlerAdapter"></a>5. 注解方式使用HandlerMapping和HandlerAdapter</h4><p>“但是这种开发模式有一个缺点，<strong>一个Handler类中只能编写一个方法</strong>“”。</p>
<p>注：上面原话来自于《Spring MVC+Mybatis开发从入门到项目实战》p151。但是对这句话的理解产生了歧义！如MultiActionController类中就能编写多个处理方法。</p>
<p>改成：<strong>一个Handler类中一般只能编写一个处理方法</strong>。</p>
<blockquote>
<p>通过注解的方式，可以在单个Handler中通过@RequestMapping注解方式配置多个方法！</p>
</blockquote>
<p>（1）配置方式</p>
<p>使用默认的注解的映射器和适配器</p>
<blockquote>
<p>Spring MVC使用的默认注解的映射器和适配器是<strong>RequestMappingHandlerMapping</strong>和<strong>RequestMappingHandlerAdapter</strong></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者手动注明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）编写Handler类</p>
<p>此时，Handler不需要实现Controller接口或者HttpRequestHandler：</p>
<p><strong>@Controller</strong>：标明Handler控制器类</p>
<p><strong>@RequestMapping</strong>：将url请求映射至Handler类中特定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin.ssm.</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/queryMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/deleteMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）配置Handler类的bean</p>
<p>逐个Handler类配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或扫描指定包下所有@Controller注解的Handler类（推荐）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin.ssm.controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Handler"><a href="#6-Handler" class="headerlink" title="6. Handler"></a>6. Handler</h4><h5 id="6-1-请求映射-RequestMapping注解"><a href="#6-1-请求映射-RequestMapping注解" class="headerlink" title="6.1 请求映射@RequestMapping注解"></a>6.1 请求映射@RequestMapping注解</h5><p>（1）请求路径</p>
<ol>
<li><p>类上注解@RequestMapping：请求域，相对Web应用根目录，表示此Handler所有方法的请求路径均在此路径下；</p>
</li>
<li><p>方法上注解@RequestMapping：相对于请求域路径。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求URL为：http://localhost:8080/"WebProjectName"/RequestArea/test.action</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"RequestArea"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerDemo</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）限定请求</p>
<blockquote>
<p>只能在方法上@RequestMapping实现</p>
</blockquote>
<ol>
<li><p>限制请求方法：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</p>
<p>@RequestMapping(value=”/test”, method=RequestMethod.GET)  // 限制请求方法为GET</p>
</li>
<li><p>限制请求参数：</p>
<p>@RequestMapping(value=”/test”, params=”username”) // 限制请求参数中必须含参数“username”</p>
</li>
<li><p>限制请求头：</p>
<p>@RequestMapping(value=”/test”, headers=”Content-Type:text/html;charset=”utf-8”)</p>
</li>
</ol>
<h5 id="6-2-参数绑定"><a href="#6-2-参数绑定" class="headerlink" title="6.2 参数绑定"></a>6.2 参数绑定</h5><p>（1）可直接绑定的类型：HttpRequest、HttpResponse、HttpSession、Model、ModelMap</p>
<p>（2）简单参数</p>
<ul>
<li><p>value：查询结果字段名 user_id 与 Java实体类中成员变量名 userId 可以不一致；</p>
</li>
<li><p>defaultValue：默认值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=&#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryDemo</span><span class="params">(Model model,@RequestParam(value=<span class="string">"user_id"</span>,defaultValue=<span class="string">"1"</span>)</span> Integer userId)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）绑定包装类</p>
<p>Spring MVC会完成创建相应的实体类 Fruit 并使用set方法注入属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/queryFruitsByCondition"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryFruitsByCondition</span><span class="params">(Model model,Fruit fruit)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）绑定集合</p>
<h4 id="7-视图解析器"><a href="#7-视图解析器" class="headerlink" title="7. 视图解析器"></a>7. 视图解析器</h4><h5 id="7-1-Spring-MVC中的视图解析器"><a href="#7-1-Spring-MVC中的视图解析器" class="headerlink" title="7.1 Spring MVC中的视图解析器"></a>7.1 Spring MVC中的视图解析器</h5><p>（1）AbstractCachingViewResolver</p>
<p>抽象类，定义了视图解析器<strong>缓存</strong>已解析视图的方法。</p>
<p>（2）UrlBasedViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存功能；</p>
</li>
<li><p>前缀属性prefix指定视图资源所在路径的前缀，后缀属性suffix指定视图资源所在路径的后缀；</p>
</li>
<li><p>支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀prefix属性指定了视图资源所在路径的前缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀suffix属性指定了视图资源所在路径的后缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解析至指定的视图，此处用来展示jsp页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>InternalResourceView类在服务器端通过<em>跳转</em> 的方式访问不能直接访问的/WEB-INF/目录下的资源</p>
<p><strong>（3）InternalResourceViewResolver</strong></p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存功能 + 支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>viewClass指定为InternalResourceView，因此不支持解析为其它视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体实现实例如下：</p>
<p>对于UserController类，其实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	定义toLogin()方法，处理拦截器传来的重定向至登录</span></span><br><span class="line"><span class="comment">	 *	页面的请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/user/toLogin.action"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/login.jsp"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器返回一个ModelAndView对象，InternalResourceViewResolver将名为“login.jsp”的<strong>视图View</strong>解析成一个InternalResourceView对象后，并将返回的model模型属性信息存放到对应的HttpRequest属性中，最后利用<strong>RequestDispatcher</strong>将请求<strong>跳转</strong>至资源“/WEB-INF/pages/login.jsp”。</p>
<p>（4）BeanNameViewResolver</p>
<ol>
<li><p>不继承 AbstractCachingViewResolver，因而无缓存视图的能力；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>在springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将此视图解析器的优先级设为高 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"toLogin"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Controller层返回名为“toLogin”<strong>（即类型为InternalResourceView的bean的id）</strong>的逻辑视图时，类似的，视图解析器BeanNameViewResolver将该视图解析为<strong>InternalResourceView对象</strong>，并跳转至指定资源。</p>
<p>（5）XmlViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>类似于BeanNameViewResolver，只是InternalResourceView类型的bean的配置信息单独配置在views.xml文件中；</p>
</li>
<li><p><strong>对views.xml存放位置无要求</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.XmlViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定路径下的配置文件/WEB-INF/views.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;bean id="</span><span class="attr">toLogin</span>" <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（6）ResourceBundleViewResolver</strong></p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>视图资源文件为properties属性文件，且必须<strong>位于classpath根目录下</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ResourceBundleViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定视图资源文件名为viewResource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"viewResource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>视图视图资源文件为viewResource，路径必须为”classpath:viewResource.properties”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.(class)=org.springframework.web.servlet.view.InternalResourceView</span><br><span class="line">login.url=/WEB-INF/pages/login.jsp</span><br></pre></td></tr></table></figure>

<p>（7）FreeMarkerViewResolver</p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存；</p>
</li>
<li><p>指定解析后的视图类型为<strong>FreeMarkerView</strong>；</p>
</li>
<li><p>得到的模板文件，可输出为多种文本文档，如HTML、XML、RTF等。</p>
</li>
</ol>
<p>首先在springmvc.xml中配置该视图解析器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"fm_"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".html"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随后仍在springmvc.xml中配置FreeMarkerView类生成的最终视图模板的位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/freemarker/template"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置的视图模板路径下，新建 “fm_freemarker.html” 的模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarkerView<span class="tag">&lt;/<span class="name">title</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 取出数据放入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（8）VelocityViewResolver</p>
<ol>
<li><p>与FreeMarkerViewResolver相似</p>
</li>
<li><p>extends UrlBasedViewResolver；</p>
</li>
<li><p>指定解析后的视图类型为VelocityView。</p>
</li>
</ol>
<h5 id="7-2-视图解析器链-ViewResolverChain"><a href="#7-2-视图解析器链-ViewResolverChain" class="headerlink" title="7.2 视图解析器链 ViewResolverChain"></a>7.2 视图解析器链 ViewResolverChain</h5><p>（1）ViewResolver 实现 Ordered 接口，order属性明确了视图解析器链中不同视图解析器的优先级；</p>
<p>（2）<strong>order越小，优先级越高</strong>；</p>
<p>（3）解析视图时，先从优先级高的解析器开始，若不能解析，则找下一优先级的解析器，若均不能解析，则返回一个null的View对象，抛异常；</p>
<p>（4）<strong>InternalResourceViewResolver可解析任意视图</strong>。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1]《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架学习笔记</title>
    <url>/2019/08/22/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><em>一些概念：</em></p>
<ol>
<li><p>ORM：Object Relation Mapping，对象关系映射。通过操作 Java对象来操作关系型数据库。</p>
</li>
<li><p>POJO与 JavaBean</p>
<ul>
<li>POJO：只有private属性和get/set方法且没有其他继承、实现的 Java对象。</li>
<li>JavaBean：private成员变量、get/set方法、<strong>空参构造函数</strong>、<strong>可序列化</strong>。</li>
</ul>
</li>
</ol>
<h4 id="1-Mybatis框架运行流程示意图如下："><a href="#1-Mybatis框架运行流程示意图如下：" class="headerlink" title="1. Mybatis框架运行流程示意图如下："></a>1. Mybatis框架运行流程示意图如下：</h4><p><img src="/2019/08/22/Mybatis框架学习笔记/1.jpg" alt></p>
<h4 id="2-基本配置示例："><a href="#2-基本配置示例：" class="headerlink" title="2. 基本配置示例："></a>2. 基本配置示例：</h4><p>（1）日志输出环境配置文件 <em>log4j.properties</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志级别</span><br><span class="line"># 在开发环境下，日志级别设置为DEBUG，生产环境设置为INFO或ERROR</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># 配置将日志信息打印至控制台</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 定制打印界面格式</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>

<p>（2）数据库配置文件 <em>db.properties</em> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据库配置文件</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br><span class="line">#c3p0.pool.maxPoolSize=400</span><br><span class="line">#c3p0.pool.minPoolSize=50</span><br><span class="line">#c3p0.pool.initialPoolSize=50</span><br><span class="line">#c3p0.pool.acquireIncrement=100</span><br></pre></td></tr></table></figure>

<p>（3）Mybatis核心配置文件 <em>SqlMapConfig.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- properties标签，引入外部配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置日志输出模式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用延迟加载（懒加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用积极加载，false表示按需加载（即消极加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否开启二级缓存 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置数据类型的别名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 自动为cn.merlin.mybatis.po包下所有的Java类配置别名，类名称s首字母小写 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.merlin.mybatis.po"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"cn.merlin.mybatis.test.QueryPlugin"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置MyBatis环境信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每一个environment标签对应一个单独的数据库环境 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 事务管理 --&gt;</span>	</span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 数据库配置信息 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 映射器，配置SQL映射文件的位置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"UserMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"BankMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"cn/merlin/mybatis/mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）SQL映射文件 <em>UserMapper.xml</em></p>
<blockquote>
<p>加载时机：Mapper映射文件随会话工厂对象 SqlSessionFactory 时被加载。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span> &gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 根据id查询对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE id = #&#123;value&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 当user表中仅有部分字段名称与User类的属性名对应时</span></span><br><span class="line"><span class="comment">		如user_id和user_name字段不对应</span></span><br><span class="line"><span class="comment">		需要使用resultMap标签</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;resultMap type="user" id="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		&lt;id property="id" column="user_id"/&gt;</span></span><br><span class="line"><span class="comment">		&lt;result property="username" column="user_name"/&gt;</span></span><br><span class="line"><span class="comment">	&lt;/resultMap&gt;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&lt;select id="findUserById" parameterType="integer" resultMap="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		SELECT * FROM user WHERE user_id = #&#123;value&#125;</span></span><br><span class="line"><span class="comment">	&lt;/select&gt; --&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 模糊查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserListByUsername"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用"#&#123;&#125;"替代"$&#123;&#125;"可以有效避免SQL注入 --&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE username LIKE "%" #&#123;value&#125; "%"</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 插入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span> &gt;</span></span><br><span class="line">		INSERT INTO user (username,password,gender,province,city) </span><br><span class="line">		VALUE (#&#123;username&#125;,#&#123;password&#125;,#&#123;gender&#125;,#&#123;province&#125;,#&#123;city&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 演示自定义的查询包装类 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByUserQueryInfo"</span> <span class="attr">parameterType</span>=<span class="string">"userQueryInfo"</span> <span class="attr">resultType</span>=<span class="string">"userInstance"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE user.username = #&#123;userInstance.username&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:</p>
<ol>
<li>使用<strong>“#{}”</strong>替代”${}”可以有效<strong>避免SQL注入攻击</strong>；</li>
<li>当表中部分字段名与 Java类成员变量名不匹配时，需要使用<strong>resultMap</strong>完成列名转换。</li>
</ol>
</blockquote>
<h4 id="3-获取sqlSession会话对象的三种途径："><a href="#3-获取sqlSession会话对象的三种途径：" class="headerlink" title="3. 获取sqlSession会话对象的三种途径："></a>3. 获取sqlSession会话对象的三种途径：</h4><h5 id="3-1-XML配置文件中set属性注入"><a href="#3-1-XML配置文件中set属性注入" class="headerlink" title="3.1 XML配置文件中set属性注入"></a>3.1 XML配置文件中set属性注入</h5><p>spring配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserDaoImpl 需继承 <strong>SqlSessionDaoSupport 类</strong>，方能通过get方法获取sqlSession。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession(); <span class="comment">// 调用父类（SqlSessionDaoSupport）的getSqlSession()方法</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-注解方式"><a href="#3-2-注解方式" class="headerlink" title="3.2 注解方式"></a>3.2 注解方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span> <span class="comment">// 注入sqlSessionFactory对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-手动获取"><a href="#3-3-手动获取" class="headerlink" title="3.3 手动获取"></a>3.3 手动获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装配，获取SqlSessionFactory对象</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">// 调用SqlSessionFactory类的openSession()方法</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p><strong><em>SqlSessionDaoSupport原理</em></strong></p>
<p>抽象类SqlSessionDaoSupport中有成员变量SqlSession，并配置了get方法。通过setSqlSessionFactory方法可以获得sqlSession实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.externalSqlSession) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sqlSession = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Mapper输出映射类型"><a href="#4-Mapper输出映射类型" class="headerlink" title="4. Mapper输出映射类型"></a>4. Mapper输出映射类型</h4><h5 id="4-1-resultType"><a href="#4-1-resultType" class="headerlink" title="4.1 resultType"></a>4.1 resultType</h5><p>（1）支持基本数据类型、基本数据包装类、自定义包装类（如 JavaBean）；</p>
<p>（2）输出时创建自定义包装类的前提是：<strong>表字段名与包装类属性名完全一致</strong>；</p>
<p>（3）当（2）不满足时，还可以输出为<strong>HashMap</strong>结构、</p>
<h5 id="4-2-resultMap"><a href="#4-2-resultMap" class="headerlink" title="4.2 resultMap"></a>4.2 resultMap</h5><p>当表字段名与包装类属性名不完全一致时</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id="userResultMap"唯一地标识resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"cn.com.mybatis.po.User"</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- id标签：与主键相对应 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"_id"</span> <span class="attr">properties</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- result：普通列 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"_username"</span> <span class="attr">properties</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByResultMap"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	select id _id,username _username from user where id = #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意resultMap中的<strong>association</strong>、<strong>collection</strong>标签，在涉及 Java包装类属性含有其它包装类或 List集合时会用到。</p>
</blockquote>
<h4 id="5-延迟加载"><a href="#5-延迟加载" class="headerlink" title="5. 延迟加载"></a>5. 延迟加载</h4><p>（1）功能：对于有关联的表，先查询单表，有需要时才查询关联表，以节约资源</p>
<p>（2）设置：</p>
<ul>
<li><p>lazyLoadingEnabled:true 开启延迟加载</p>
</li>
<li><p>aggressiveLazyLoading:false 开启消极加载（即按需加载）</p>
</li>
</ul>
<h4 id="6-动态代理"><a href="#6-动态代理" class="headerlink" title="6. 动态代理"></a>6. 动态代理</h4><blockquote>
<p>不编写DAO层操作数据库代码，在符合一定规范的前提下，由Mapper代理自动完成数据交互。</p>
</blockquote>
<p>示例：</p>
<p>（1）编写名称与Mapper配置文件相同的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">findCustomerById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写CustomerMapper.xml文件</p>
<blockquote>
<p>namespace 设为 接口的全包名：cn.com.mybatis.mapper.CustomerMapper</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.com.mybatis.mapper.CustomerMapper"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findCustomerById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"customer"</span>&gt;</span></span><br><span class="line">		select * from customer where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用SqlSession类的getMapper()方法，获取代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    CustomerMapper customerMapper = sqlSession.getMapper(CustomerMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    Customer customer = customerMapper.findCustomerById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-缓存（HashMap结构）"><a href="#7-缓存（HashMap结构）" class="headerlink" title="7. 缓存（HashMap结构）"></a>7. 缓存（<strong>HashMap</strong>结构）</h4><h5 id="7-1-一级缓存"><a href="#7-1-一级缓存" class="headerlink" title="7.1 一级缓存"></a>7.1 一级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/2.jpg" alt></p>
<blockquote>
<p>一级缓存基于SqlSession会话对象实例，sqlSession级别独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/3.jpg" alt></p>
<blockquote>
<p>查询时，sqlSession首先查询一级缓存，若无，再查询数据库，并将结果存储至一级缓存</p>
</blockquote>
<h5 id="7-2-二级缓存"><a href="#7-2-二级缓存" class="headerlink" title="7.2 二级缓存"></a>7.2 二级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/4.jpg" alt></p>
<blockquote>
<p>二级缓存基于Mapper实例，namespace一致则共享，否则独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/5.jpg" alt></p>
<blockquote>
<p>不同的SqlSession实例，执行同一个Mapper文件中的SQL语句，共享二级缓存</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] 《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>

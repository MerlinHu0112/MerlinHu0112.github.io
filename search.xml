<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring学习之AOP</title>
    <url>/2020/06/11/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8BAOP/</url>
    <content><![CDATA[<p>软件开发就是为了解决各种需求包括<strong>业务需求</strong>和<strong>系统需求</strong>。使用面向对象编程（OOP，Object-Oriented Programming）可以很好地对业务需求等普通关注点进行抽象和封装，使之模块化。但对于散落在系统中各处的系统需求的实现，OOP 无法从容应对。于是，<strong>面向切面编程</strong>（<strong>AOP</strong>，Aspect-Oriented Programming）这一理念被提了出来。</p>
<p>AOP 是一种理念，而不是一种新的开发模式。它需要借助某种语言（不一定是 Java）以实现相应的概念实体，这些语言则被成为 AOL（Aspect-Oriented Language）。譬如，<strong>AspectJ</strong> 就是一种扩展自 Java 语言的 AOL。</p>
<a id="more"></a>

<h4 id="一、AOP-的分类"><a href="#一、AOP-的分类" class="headerlink" title="一、AOP 的分类"></a>一、AOP 的分类</h4><p>在 Java 语言范围内，常见的 AOP 框架有：<strong>AspectJ</strong>、<strong>Spring AOP</strong>、JBoss AOP 和 Nanning 等。AOP 可被划分为两种不同的类型：静态 AOP 和动态 AOP。</p>
<h5 id="1-1-静态-AOP"><a href="#1-1-静态-AOP" class="headerlink" title="1.1 静态 AOP"></a>1.1 静态 AOP</h5><p>第一代 AOP 被称为静态 AOP，AspectJ 是其中典型的代表。</p>
<p>早期的 AspectJ 框架使用 ajc 编译器<strong>将横切逻辑以 Java 字节码的形式编译到系统的对应模块中</strong>。</p>
<ul>
<li>优点：在编译时即将横切逻辑插入 Java 类中，因此运行时性能较高。</li>
<li>缺点：灵活性不够。</li>
</ul>
<h5 id="1-2-动态-AOP-之动态代理"><a href="#1-2-动态-AOP-之动态代理" class="headerlink" title="1.2 动态 AOP 之动态代理"></a>1.2 动态 AOP 之动态代理</h5><p>第二代 AOP 被称为动态 AOP。Spring AOP、JBoss AOP 以及 Nanning 等框架均为动态 AOP。此外，AspectJ 框架后来融合了 AspectWerkz 框架，开始支持动态 AOP。动态代理是动态 AOP 的实现方式之一。</p>
<p>动态代理实现 AOP：将横切逻辑封装到代理类的 InvocationHandler 方法中。在程序运行期间，利用<strong>反射技术动态地生成代理对象并将横切逻辑加入代理对象中</strong>。</p>
<ul>
<li>优点：灵活性高。</li>
<li>缺点：<ul>
<li>被织入横切逻辑的 Java 类必须实现接口；</li>
<li>运行时动态织入，性能不及静态织入。</li>
</ul>
</li>
</ul>
<h5 id="1-3-动态-AOP-之动态字节码增强"><a href="#1-3-动态-AOP-之动态字节码增强" class="headerlink" title="1.3 动态 AOP 之动态字节码增强"></a>1.3 动态 AOP 之动态字节码增强</h5><p>动态字节码技术也是动态 AOP 的实现方式之一。使用 ASM 或 CGLIB 等工具库，在程序运行期间，为需要织入横切逻辑的 Java 类<strong>动态地生成子类并将横切逻辑加入子类中</strong>。</p>
<ul>
<li>优点：灵活性高。当 Java 类未实现接口时，不能使用动态代理，转而可以借用动态字节码技术。</li>
<li>缺点：对 final 修饰的类，无法使用此技术。</li>
</ul>
<blockquote>
<p>Spring AOP 默认使用动态代理实现 AOP。当相应的 Java 类没有实现接口时，则采用 CGLIB 动态字节码技术实现 AOP。</p>
</blockquote>
<h4 id="二、Spring-AOP-的概念实体"><a href="#二、Spring-AOP-的概念实体" class="headerlink" title="二、Spring AOP 的概念实体"></a>二、Spring AOP 的概念实体</h4><p>AOP 的相关概念实体如下：</p>
<ul>
<li>Joinpoint（连接点）：目标对象中，允许增强的方法</li>
<li>Pointcut（切入点）：可以插入增强处理的连接点</li>
<li>Advice（通知）：增强代码</li>
<li>Aspect（切面）：Pointcut + Advice</li>
<li>Target（目标对象）：被代理对象</li>
<li>Weaving（织入）：将 Advice 织入 Pointcut 的过程，完成方法的增强</li>
</ul>
<blockquote>
<p>Spring AOP 中部分概念与上述概念存在差异，如 Spring 中无 Aspect，而是 Advisor。</p>
</blockquote>
<h5 id="2-1-Joinpoint"><a href="#2-1-Joinpoint" class="headerlink" title="2.1 Joinpoint"></a>2.1 Joinpoint</h5><p>AOP 的 Joinpoint 支持多种不同的类型，如方法调用、方法执行、字段设置和获取等，但 Spring AOP 仅支持<strong>方法执行类型</strong>的 Joinpoint。正是因为 Spring AOP 不支持构造器连接点，我们无法在创建 bean 的时候应用 AOP。</p>
<h5 id="2-2-Pointcut"><a href="#2-2-Pointcut" class="headerlink" title="2.2 Pointcut"></a>2.2 Pointcut</h5><p>Spring 提供 org.springframework.aop.Pointcut 接口作为切入点的顶级抽象，它定义了用于捕捉 Joinpoint 的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取切入点的ClassFilter对象，用于匹配将被织入的对象。</span></span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 获取切入点的MethodMatcher对象，用于匹配相应的Joinpoint。 </span></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 若Pointcut类型为TruePointcut，默认支持匹配所有对象上所有的Joinpoint。 </span></span><br><span class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.MethodMatcher 接口定义了方法级别的拦截！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line">	MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供两个重要的实现：Class StaticMethodMatcher 和 DynamicMethodMatcher。</p>
<ul>
<li>StaticMethodMatcher：isRuntime() 方法返回 false 时，调用两个参数的 matches 方法，表示不需要考虑 Joinpoint 的方法参数。方法的返回结果是可以缓存的。</li>
<li>DynamicMethodMatcher：isRuntime() 方法返回 true 时，只有当两个参数的 matches 方法返回 true 时，三个参数的 matches 方法才会被执行。匹配的结果是无法缓存的。</li>
</ul>
<p><img src="/2020/06/11/Spring学习之AOP/Pointcut%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB.jpg" alt></p>
<h5 id="2-3-Advice"><a href="#2-3-Advice" class="headerlink" title="2.3 Advice"></a>2.3 Advice</h5><p>Advice 实现了被织入到 Joinpoint 中的横切逻辑，即增强代码。根据位置，Advice 可被细分为：</p>
<ul>
<li>Before Advice（前置通知）：在 Joinpoint 指定位置之前执行，可完成系统的初始化工作。</li>
<li>After Advice（后置通知）：在 Joinpoint 指定位置之后执行，可继续细分<ul>
<li>After Returning Advice（后置返回通知）：Joinpoint 处执行流程正常完成后执行；</li>
<li>Throws Advice（异常通知）：Joinpoint 处执行过程中抛出异常时执行；</li>
<li>After Advice：必须执行（Spring AOP 未提供）。</li>
</ul>
</li>
<li>Around Advice（环绕通知）：在 Joinpoint 前后分别执行指定的横切逻辑。Spring 未提供相应的接口，而是直接使用 AOP Alliance 提供的 <strong>Interceptor（拦截器）</strong> 接口。</li>
<li>Introduction：无特定执行时机，用来为对象添加新的特性或行为。</li>
</ul>
<p>在 Spring 中，依照 Advice 实例能否被共享，分为 per-class 类型和 per-instance 类型：</p>
<ul>
<li>per-class：可在目标对象类的所有实例间共享，包括 Before Advice、After Advice 和 Interceptor。</li>
<li>per-instance：为不同的实例对象保存各自的状态和相关逻辑，Introduction。</li>
</ul>
<p><img src="/2020/06/11/Spring学习之AOP/Spring%E4%B8%ADAdvice%E8%B0%B1%E5%9B%BE.jpg" alt></p>
<p>（1）Before Advice</p>
<p>实现 org.springframework.aop.MethodBeforeAdvice 接口。此横切逻辑不能直接中断 Joinpoint 执行流程，除非 before 方法中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Throws Advice</p>
<p>通过 Throws Advice，可实现实时监控程序运行时产生的异常，并通过一定的机制（如发送邮件）告知管理者。</p>
<p>Spring 提供的 org.springframework.aop.ThrowsAdvice 接口没有定义任何方法，因为这些横切逻辑的调用依靠的是 <strong>Java 的反射机制</strong>。但在实现该接口的时候，所实现的方法应遵守一定的规则，常见三种形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通异常处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception ex)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 运行时异常处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(RuntimeException ex)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 程序运行时异常处理，可用于实时监控程序运行时产生的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method m, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">                              Object target, RuntimeException ex)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）After Returning Advice</p>
<p>Spring 提供的 org.springframework.aop.AfterReturningAdvice 接口定义的方法在 Joinpoint 执行完毕后，可访问 Joinpoint 处方法的返回值、方法参数、目标对象等，但<strong>不能修改方法的返回值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）Interceptor</strong></p>
<p>Spring 未直接定义 Around Advice，而是直接使用 AOP Alliance 提供的 MethodInterceptor 接口。MethodInterceptor 接口提供的功能更加强大，可以完全覆盖前三种 Advice 所提供的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 MethodInvocation 的 <strong>proceed() ** 方法，可让程序执行继续沿着调用链传播，即执行 Joinpoint 处原有的流程。</strong>在 proceed() 方法前后可分别插入横切逻辑**。</p>
<h5 id="2-4-Advisor"><a href="#2-4-Advisor" class="headerlink" title="2.4 Advisor"></a>2.4 Advisor</h5><p>Spring AOP 中无 Aspect 的概念，取而代之的是 Advisor。</p>
<blockquote>
<p>Aspect 可由多个 Pointcut 和多个 Advice 组成，而 Advisor 一般由一个 Pointcut 和一个 Advice 组成。</p>
</blockquote>
<p>org.springframework.aop.Advisor 接口有两个常见子接口：PointcutAdvisor 和 IntroductionAdvisor。</p>
<p>PointcutAdvisor 支持任何类型的 Pointcut 和除 Introduction 外的任何类型的 Advice。</p>
<ul>
<li>DefaultPointcutAdvisor：支持任何类型的 Pointcut 和除 Introduction 外的任何类型的 Advice。</li>
<li>NameMatchMethodPointcutAdvisor：支持 NameMatchMethodPointcut 类型的 Pointcut 和除 Introduction 外的任何类型的 Advice。</li>
<li>RegexpMethodPointcutAdvisor：限定通过正则表达式为其设置相应的 Pointcut。</li>
</ul>
<h5 id="2-5-织入"><a href="#2-5-织入" class="headerlink" title="2.5 织入"></a>2.5 织入</h5><p>AspectJ 使用 ajc 编译器作为织入器，Spring AOP 基于<strong>代理模式</strong>使用 <strong>ProxyFactory</strong> 作为最基本的织入器实现。</p>
<h4 id="三、使用-Spring-AOP-的两种方式"><a href="#三、使用-Spring-AOP-的两种方式" class="headerlink" title="三、使用 Spring AOP 的两种方式"></a>三、使用 Spring AOP 的两种方式</h4><p>Spring AOP 有两种常见的使用方式：</p>
<ul>
<li>基于 XML 的声明方式</li>
<li>基于 AspectJ 的注解方式</li>
</ul>
<h5 id="3-1-基于-XML-的声明方式"><a href="#3-1-基于-XML-的声明方式" class="headerlink" title="3.1 基于 XML 的声明方式"></a>3.1 基于 XML 的声明方式</h5><p>编写切面类，类中定义了不同的增强方法。在 Spring 的 XML 配置文件中，声明切面、切点和相应的通知。</p>
<p>（1）业务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）业务实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为用户提供服务！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">520</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>自定义切面类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myAspect"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===前置通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===后置通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置返回通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===后置返回通知==="</span>);</span><br><span class="line">        System.out.println(<span class="string">"后置返回通知###方法的返回结果为："</span> + result.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抛出异常！异常信息如下："</span>);</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"===异常通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint obj)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===环绕通知开始==="</span>);</span><br><span class="line">        Object result = obj.proceed(); <span class="comment">// 让程序执行继续沿着调用链传播</span></span><br><span class="line">        System.out.println(<span class="string">"环绕通知###方法的返回结果为："</span> + result);</span><br><span class="line">        System.out.println(<span class="string">"===环绕通知结束==="</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1314</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）Spring 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置自动包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明切面、切点和通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturningAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">returning</span>=<span class="string">"result"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"ApplicationContext.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = userService.service();</span><br><span class="line">        System.out.println(<span class="string">"返回值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">===前置通知===</span><br><span class="line">===环绕通知开始===</span><br><span class="line">为用户提供服务！</span><br><span class="line">环绕通知###方法的返回结果为：520</span><br><span class="line">===环绕通知结束===</span><br><span class="line">===后置通知===</span><br><span class="line">===后置返回通知===</span><br><span class="line">后置返回通知###方法的返回结果为：1314</span><br><span class="line">返回值为：<span class="number">1314</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>根据运行结果不难发现，在环绕通知中，方法的返回值由 <code>520</code> 被修改为 <code>1314</code> 。可见，<strong>环绕通知可以修改连接点方法的返回值</strong>。</li>
<li>在配置 <code>&lt;aop:config&gt;</code> 的时候，若切点元素 <code>&lt;aop:pointcut&gt;</code> 位于切面元素 <code>&lt;aop:aspect&gt;</code> 内，则该切点只对当前切面有效，对于 <code>&lt;aop:config&gt;</code> 中定义的其它切面是无效的。</li>
<li>接第 2 条。当切点元素 <code>&lt;aop:pointcut&gt;</code> 在切面元素 <code>&lt;aop:aspect&gt;</code> <strong>之前</strong>被定义时，则该切点对于 <code>&lt;aop:config&gt;</code> 中定义的所有切面均有效。</li>
</ol>
<h5 id="3-2-基于-AspectJ-的注解方式"><a href="#3-2-基于-AspectJ-的注解方式" class="headerlink" title="3.2 基于 AspectJ 的注解方式"></a>3.2 基于 AspectJ 的注解方式</h5><p>与前述基于 XML 的声明方式不同的是，注解方式是通过不同的注解符号标识切面、切点，如 <code>@Aspect</code>、<code>@Before</code>、<code>@Around</code> 等。</p>
<blockquote>
<p>业务接口、业务实现类、测试类同前</p>
</blockquote>
<p>（1）切面类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myAspect"</span>)</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 注解，标识切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===前置通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===后置通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置返回通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===后置返回通知==="</span>);</span><br><span class="line">        System.out.println(<span class="string">"后置返回通知###方法的返回结果为："</span> + result.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抛出异常！异常信息如下："</span>);</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"===异常通知==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* cn.merlin.UserServiceImpl.service(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint obj)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===环绕通知开始==="</span>);</span><br><span class="line">        Object result = obj.proceed(); <span class="comment">// 让程序执行继续沿着调用链传播</span></span><br><span class="line">        System.out.println(<span class="string">"环绕通知###方法的返回结果为："</span> + result);</span><br><span class="line">        System.out.println(<span class="string">"===环绕通知结束==="</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1314</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">===环绕通知开始===</span><br><span class="line">===前置通知===</span><br><span class="line">为用户提供服务！</span><br><span class="line">环绕通知###方法的返回结果为：520</span><br><span class="line">===环绕通知结束===</span><br><span class="line">===后置通知===</span><br><span class="line">===后置返回通知===</span><br><span class="line">后置返回通知###方法的返回结果为：1314</span><br><span class="line">返回值为：<span class="number">1314</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-切点表达式"><a href="#3-3-切点表达式" class="headerlink" title="3.3 切点表达式"></a>3.3 切点表达式</h5><p>基于 3.1 和 3.2 小节不难发现，在使用 Spring AOP 时，重点在于切面类和类中的增强方法，以及切点表达式 execution。</p>
<p>切点表达式的基本格式如下（<code>?</code> 表示当前项是非必须的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<ul>
<li>modifiers-pattern：表示方法的修饰符，如 public；</li>
<li>ret-type-pattern：方法的返回值类型，如 void；</li>
<li>declaring-type-pattern：方法所在的<strong>类的全路径名</strong>；</li>
<li>name-pattern：方法名；</li>
<li>param-pattern：方法的形参列表；</li>
<li>throws-pattern：方法抛出的异常类型。</li>
</ul>
<p>如前述代码所示，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* cn.merlin.UserServiceImpl.service(..))</span><br></pre></td></tr></table></figure>

<p>表示匹配 cn.merlin.UserServiceImpl 类的 service 方法，该方法返回值可为任意类型，形参列表也是任意的。</p>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>本文分别介绍了动态代理和动态字节码增强两种方式以实现 Spring AOP。动态代理是在程序运行期间，利用反射技术动态地生成代理对象并将横切逻辑加入代理对象中，因此要求被插入横切逻辑的 Java 类必须实现接口。否则，只能使用 CGLIB 动态代理技术生成子类并将横切逻辑放入子类中。</p>
<p>此外，本文还展示了基于 XML 的声明和基于 AspectJ 的注解两种使用 Spring AOP 的方式。需要注意的是，Spring 只支持方法级别的连接点，即切面的粒度是方法。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 《Spring 揭秘》</p>
<p>[2] <a href="https://www.cnblogs.com/xiaoxi/p/5981514.html" target="_blank" rel="noopener">Spring系列之AOP实现的两种方式</a></p>
<p>[3] <a href="https://www.cnblogs.com/hang-on/p/11383289.html" target="_blank" rel="noopener">(一)spring aop的两种配置方式。</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码阅读笔记</title>
    <url>/2020/05/23/ConcurrentHashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring学习之IoC</title>
    <url>/2020/05/22/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8BIoC/</url>
    <content><![CDATA[<p>Spring 是基于 POJO（Plain Old Java Object，简单 Java 对象）的轻量级开发框架，由多个模块组成。其中，Core 模块是 Spring 框架的基石，它提供了 IoC 容器的实现，以及以依赖注入的方式管理对象之间的依赖关系。</p>
<p>在传统的开发中，对其它对象的引用或依赖关系的管理由具体的类负责，导致代码高度耦合、难以测试。通过 IoC容器（如 Spring 中的 IoC 容器）可以主动完成对象创建和依赖关系的注入，使得 Java 的类与类之间解耦合。</p>
<p>本文基于 Spring 4.2.5 版本，从以下五个方面介绍 Spring 中的 IoC 容器：</p>
<ul>
<li>Spring 提供的两种 IoC 容器（BeanFactory 和 ApplicationContext）</li>
<li>IoC 容器启动与 bean 的实例化过程</li>
<li>bean 的生命周期</li>
<li>IoC 容器装配 bean 的方式</li>
<li>IoC 容器依赖注入方式</li>
</ul>
<a id="more"></a>

<p>Spring 框架如下图所示：</p>
<p><img src="/2020/05/22/Spring学习之IoC/Spring%E6%A1%86%E6%9E%B6%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6.jpg" alt></p>
<h4 id="一、控制反转和依赖注入"><a href="#一、控制反转和依赖注入" class="headerlink" title="一、控制反转和依赖注入"></a>一、控制反转和依赖注入</h4><p><strong>IoC（Inversion of Control，控制反转）</strong>：在 IoC 容器之前，对象的引用或依赖关系的管理由具体的类负责，主动权在该具体类。IoC 容器之后，这些功能由容器负责，不同的类之间只要专注于自身即可。由之前的主动行为变成被动行为，故称之为控制反转。</p>
<p><strong>DI（Dependency Injection，依赖注入）</strong>：所谓依赖注入，就是在 IoC 容器运行期间，动态地将依赖关系注入到对象之中。依赖注入是实现 IoC 的一种方式。</p>
<h4 id="二、BeanFactory"><a href="#二、BeanFactory" class="headerlink" title="二、BeanFactory"></a>二、BeanFactory</h4><p>Spring 实现了两种 IoC 容器，分别是基础的 BeanFactory 容器和基于 BeanFactory 的 ApplicationContext 容器。</p>
<p>Spring 提供两种 IoC 容器：</p>
<ul>
<li>BeanFactory：基础的 IoC 容器，默认懒加载策略，<strong>使用 bean 时才完成初始化及依赖注入</strong>，因此容器启动速度快、所需资源少。</li>
<li>ApplicationContext：基于 BeanFactory，额外实现 MessageSource（国际化）、ApplicationEvenPublisher（事件发布）、ResourcePatternResolver 接口。<strong>在容器启动后，完成所有 bean 的初始化和依赖注入</strong>。因此容器启动时间较长、所需资源较多。</li>
</ul>
<p><img src="/2020/05/22/Spring学习之IoC/IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD.jpg" alt></p>
<h5 id="2-1-BeanFactory-容器底层结构"><a href="#2-1-BeanFactory-容器底层结构" class="headerlink" title="2.1 BeanFactory 容器底层结构"></a>2.1 BeanFactory 容器底层结构</h5><p>实现 BeanFactory 容器，常见的接口关系图如下：</p>
<p><img src="/2020/05/22/Spring学习之IoC/BeanFactory%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3.jpg" alt></p>
<p>实现 BeanFactory 容器涉及四个重要接口：<strong>BeanFactory</strong>、<strong>BeanDefinitionRegistry</strong>、<strong>BeanDefinition</strong>、<strong>BeanDefinitionReader</strong>。</p>
<ul>
<li>BeanFactory 接口：定义管理 bean 的方法。</li>
<li>BeanDefinitionRegistry 接口：定义注册 bean 的方法。</li>
<li>BeanDefinition 接口：保存 bean 的信息，包括对象的 Class 类型、构造方法参数以及其它属性等。</li>
<li>BeanDefinitionReader 接口：读取配置文件内容、将其映射至 BeanDefinition，然后将映射后的 BeanDefinition 注册到 BeanDefinitionRegistry 中，由后者完成 bean 的注册和加载。常见实现类有两种：<ul>
<li>XmlBeanDefinitionReader：读取 XML 格式的配置文件；</li>
<li>PropertiesBeanDefinitionReader：读取 Properties 格式的配置文件。</li>
</ul>
</li>
</ul>
<p><em>BeanFactory 接口的源码如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于访问Spring Bean容器的根接口。使用此接口及其子接口可以实现Spring的依赖注入功能</span></span><br><span class="line"><span class="comment">// 通常，BeanFactory将加载存储在配置源中的bean的定义，并使用beans包来配置bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 区别FactoryBean。前缀为'&amp;'表示获取工厂本身，而非工厂返回的bean</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line">    <span class="comment">// 根据bean的名称获取bean</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">// 根据bean的名称和类型获取bean</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">// 根据类型获取bean，此类型可以是实现的接口或父类</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">// 判断给定名称的bean是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">// 判断给定名称的bean是否是单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 判断给定名称的bean是否是原型模式</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 返回给定bean名称的别名。若给定的是别名，则返回相应的规范bean名称和其它别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-启动-BeanFactory-容器"><a href="#2-2-启动-BeanFactory-容器" class="headerlink" title="2.2 启动 BeanFactory 容器"></a>2.2 启动 BeanFactory 容器</h5><p>Spring IoC 容器的启动过程主要包括：</p>
<ul>
<li>启动初始化与资源定位</li>
<li>载入并解析 BeanDefinition</li>
<li>注册 BeanDefinition</li>
</ul>
<p>（1）BeanFactory 容器使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建IoC配置文件的抽象资源</span></span><br><span class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"ApplicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">// 获取bean实例的注册表</span></span><br><span class="line">        DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 创建载入BeanDefinition的读取器</span></span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanRegistry);</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        reader.loadBeanDefinitions(resource);</span><br><span class="line">        <span class="comment">// 获取bean</span></span><br><span class="line">        UserService userService = (UserService) beanRegistry.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        <span class="comment">// 使用bean</span></span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）源码分析</p>
<ol>
<li>首先创建配置文件的抽象资源，规范资源路径，为加载资源文件做准备。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"ApplicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>ClassPathResource 类的继承图谱如下图所示，可看出其继承自 AbstractResource 类，而后者实现了资源描述符接口 Resource。</p>
<p><img src="/2020/05/22/Spring学习之IoC/ClassPathResource%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.jpg" alt></p>
<p>调用 ClassPathResource 类的构造函数，获取对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathResource</span> <span class="keyword">extends</span> <span class="title">AbstractFileResolvingResource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(path, (ClassLoader) <span class="keyword">null</span>); <span class="comment">// 调用重载的构造函数，类加载器为null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断资源路径是否为空</span></span><br><span class="line">        Assert.notNull(path, <span class="string">"Path must not be null"</span>);</span><br><span class="line">        <span class="comment">// 规范资源路径</span></span><br><span class="line">        String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line">        <span class="keyword">if</span> (pathToUse.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            pathToUse = pathToUse.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.path = pathToUse;</span><br><span class="line">        <span class="comment">// 当类加载器为null时，使用默认的类加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoader = (classLoader != <span class="keyword">null</span> ? classLoader : </span><br><span class="line">                            ClassUtils.getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 ClassUtils 类的 getDefaultClassLoader 方法，<strong>先后尝试获取当前线程上下文类加载器、ClassUtils 类加载器、启动类加载器。</strong>需要注意的是，尝试获取类加载器是按照一定顺序的。若已获得类加载器，就返回该类加载器，而不需要获取后续的类加载器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefaultClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取当前线程上下文类加载器。若有，则返回</span></span><br><span class="line">        cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若线程上下文类加载器为空，则尝试获取ClassUtils的类加载器。若有，则返回</span></span><br><span class="line">        cl = ClassUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 若前面均为空，则尝试获取启动类加载器并返回</span></span><br><span class="line">                cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>随后获取 bean 实例的注册表，用于注册 BeanDefinition 对象。bean 名称与 BeanDefinition 对象的映射表<code>beanDefinitionMap</code> 和单例 bean 的缓存 <code>singletonObjects</code> 底层结构均为 ConcurrentHashMap。</p>
<p>在创建 bean 时，默认采用 CGLIB 动态生成子类。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/22/Spring学习之IoC/DefaultListableBeanFactory%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt></p>
<p>DefaultListableBeanFactory 类是 Spring 的 ConfigurableListableBeanFactory 和 BeanDefinitionRegistry 接口的默认实现。它是基于 bean 定义元数据（bean definition metadata）的 bean 工厂，可通过后处理器进行扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用DefaultListableBeanFactory类的空参构造函数完成实例化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化过程中，部分 DefaultListableBeanFactory 类及其父类字段被初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** 初始化的来自DefaultListableBeanFactory类的部分字段 ***/</span></span><br><span class="line"><span class="comment">// 允许使用相同的bean名称重新注册不同的bean，即以后一个bean覆盖前一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> allowBeanDefinitionOverriding = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 允许预加载类，包括设置了懒加载的bean</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> allowEagerClassLoading = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// bean名称与BeanDefinition对象的映射表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = </span><br><span class="line">    							<span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 来自父类的部分字段 ***/</span></span><br><span class="line"><span class="comment">// 创建bean实例的策略，默认使用CGLIB动态生成子类</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = </span><br><span class="line">    							<span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br><span class="line"><span class="comment">// 获取类加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line"><span class="comment">// true表示缓存bean元数据，false表示每次使用时获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cacheBeanMetadata = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 由FactoryBeans创建的单例对象的缓存，映射关系为“FactoryBean名称--&gt;对象”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; factoryBeanObjectCache = </span><br><span class="line">    							<span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 单例bean缓存，映射关系为“bean名称--&gt;bean实例”，底层结构为ConcurrentHashMap，初始容量为256</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = </span><br><span class="line">    							<span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 单例工厂缓存，映射关系为“bean名称--&gt;工厂对象”，底层结构为HashMap，初始容量为16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = </span><br><span class="line">    							<span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 早期的单例bean缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = </span><br><span class="line">    							<span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 已注册的单例bean名称集合，按照注册顺序，底层结构为LinkedHashSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = </span><br><span class="line">    							<span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 当前正在创建的bean的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">   			 Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;String, Boolean&gt;(<span class="number">16</span>));</span><br><span class="line"><span class="comment">// bean的规范命名与别名的映射表，底层结构为ConcurrentHashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = </span><br><span class="line">    							<span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建载入BeanDefinition的读取器对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanRegistry);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/22/Spring学习之IoC/XmlBeanDefinitionReader%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt></p>
<p>首先看 XmlBeanDefinitionReader 类源码。此类用于读取 XML 格式的 bean 配置文件， 将实际的 XML 文档读取委托给 BeanDefinitionDocumentReader 接口的实现。 文档阅读器将向给定的 bean 工厂注册每个 bean 定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以给定的bean工厂创建阅读器对象</span></span><br><span class="line">    <span class="comment">// 给定的bean工厂以BeanDefinitionRegistry的形式注册bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(registry);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化字段（仅列举部分）</span></span><br><span class="line">    <span class="comment">// 使用Spring默认的DocumentLoader实现，它使用标准的JAXP配置的XML解析器加载文档</span></span><br><span class="line">    <span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</span><br><span class="line">    <span class="comment">// 检测XML文档是否基于DTD或XSD的验证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlValidationModeDetector validationModeDetector = <span class="keyword">new</span> XmlValidationModeDetector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 XmlBeanDefinitionReader 的抽象父类 AbstractBeanDefinitionReader 的源码。</p>
<p>AbstractBeanDefinitionReader 类为指定的 bean 工厂创建一个新的 AbstractBeanDefinitionReader 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果registry对象除BeanDefinitionRegistry外还实现了ResourceLoader接口，</span></span><br><span class="line">        <span class="comment">// 则将传入的registry对象作为默认的资源加载器，如ApplicationContext容器</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line">			<span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 传入的registry对象未实现ResourceLoader接口，</span></span><br><span class="line">            <span class="comment">// 则默认使用PathMatchingResourcePatternResolver作为资源加载器</span></span><br><span class="line">			<span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Inherit Environment if possible</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">			<span class="keyword">this</span>.environment = ((EnvironmentCapable) <span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加载bean的配置资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>

<p>调用 XmlBeanDefinitionReader 类的 loadBeanDefinitions 方法加载资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.调用loadBeanDefinitions方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.允许使用指定的编码格式解析资源文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">			logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// XmlBeanDefinitionReader内部维护的resourcesCurrentlyBeingLoaded对象保存</span></span><br><span class="line">        <span class="comment">// 最近被加载的资源</span></span><br><span class="line">		Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">		<span class="comment">// 若尚未加载资源，进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">			currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 添加EncodedResource对象</span></span><br><span class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取资源的输入流对象</span></span><br><span class="line">			InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将输入流对象封装成org.xml.sax包的InputSource对象</span></span><br><span class="line">				InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">				<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置编码方式</span></span><br><span class="line">					inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 3.调用doLoadBeanDefinitions方法加载输入流</span></span><br><span class="line">				<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			currentResources.remove(encodedResource);</span><br><span class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.调用doLoadBeanDefinitions方法加载输入流</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.使用默认的DocumentLoader加载资源文档</span></span><br><span class="line">			Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">            <span class="comment">// 5.注册BeanDefinition</span></span><br><span class="line">			<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.使用默认的DocumentLoader加载XML文档，返回获取的Document对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">				getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.注册BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		<span class="comment">// 默认获取DefaultBeanDefinitionDocumentReader实例</span></span><br><span class="line">        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">		<span class="comment">// 获取原注册表记录数</span></span><br><span class="line">        <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">		<span class="comment">// 返回新注册的记录数</span></span><br><span class="line">        <span class="keyword">return</span> getRegistry().DefinitionCount() - countBefore;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 4 步中，调用 DefaultDocumentLoader 类的 loadDocument 方法加载 XML 文档。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDocumentLoader</span> <span class="keyword">implements</span> <span class="title">DocumentLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> inputSource 输入源</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> entityResolver 实体解析器</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> errorHandler 错误处理器</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> validationMode XML文档验证类型，DTD或XSD</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> namespaceAware 是否支持XML命名空间</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">			ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建工厂实例，此工厂可根据XML文档获取解析器并生成DOM对象树</span></span><br><span class="line">		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 创建一个JAXP DocumentBuilder对象，用于解析XML文档</span></span><br><span class="line">		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">		<span class="comment">// 解析输入域，获取并返回Document对象</span></span><br><span class="line">        <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，完成了 IoC 容器 BeanFactory 的启动工作，由 Spring 管理的 bean 被注册进容器中。需要注意的是，此时bean 尚未实例化。在使用 bean 时才完成初始化及依赖注入。</p>
<h4 id="三、ApplicationContext"><a href="#三、ApplicationContext" class="headerlink" title="三、ApplicationContext"></a>三、ApplicationContext</h4><p>ApplicationContext 容器是基于 BeanFactory 的。在前面学习了 BeanFactory 容器的启动过程。与 BeanFactory 容器启动时仅注册 bean 不同，ApplicationContext 容器在启动时就要完成 bean 的注册及实例化。故 ApplicationContext 容器的启动程序比 BeanFactory 要复杂。</p>
<h5 id="3-1-启动-ApplicationContext-容器"><a href="#3-1-启动-ApplicationContext-容器" class="headerlink" title="3.1 启动 ApplicationContext 容器"></a>3.1 启动 ApplicationContext 容器</h5><p>ApplicationContext 容器提供以下三种常用实现：</p>
<ul>
<li>ClassPathXmlApplicationContext：从类路径（Classpath） 载入资源配置文件</li>
<li>FileSystemXmlApplicationContext：从文件系统载入资源配置文件</li>
<li>XmlWebApplicationContext：从 Web 容器载入资源配置文件</li>
</ul>
<p>与 BeanFactory 相似，使用 ApplicationContext 容器的简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:ApplicationContext.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>接下来对上述过程进行源码分析</em></strong></p>
<p>最重要的类是 ClassPathXmlApplicationContext ，它是独立 XML 应用程序上下文，可从类路径中获取上下文定义文件。</p>
<p><em>为便于阅读，对 ClassPathXmlApplicationContext 类的继承关系图进行了简化处理，主要删除 ApplicationContext 继承的接口。ApplicationContext 接口间接继承了 BeanFactory、ResourceLoader 接口，直接继承了 ApplicationEventPublisher、MessageSource、ResourcePatternResolver 等接口。</em></p>
<p><img src="/2020/05/22/Spring学习之IoC/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8BIoC%5CClassPathXmlApplicationContext%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.jpg" alt></p>
<ol>
<li>获取 ClassPathXmlApplicationContext 实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// 调用重载的构造方法，其中refresh参数设置为true</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(parent); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">		setConfigLocations(configLocations); <span class="comment">// 设置应用程序上下文配置位置</span></span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">			refresh(); <span class="comment">// 刷新</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取 ClassPathXmlApplicationContext 实例过程中，涉及的部分父类实例化过程如下。</p>
<p>在 AbstractApplicationContext 类中获取默认的 PathMatchingResourcePatternResolver 对象，用于解析资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用于刷新的beanFactoryPostProcessors</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors =</span><br><span class="line">			<span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="comment">// 记录当前上下文是否处于活跃状态        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean active = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="comment">// 记录当前上下文是否被关闭</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="comment">// 刷新和销毁操作的同步监视器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 静态、指定的监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = </span><br><span class="line">    		<span class="keyword">new</span> LinkedHashSet&lt;ApplicationListener&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取ResourcePatternResolver实例，默认PathMatchingResourcePatternResolver</span></span><br><span class="line">    	<span class="comment">// 用于将指定的资源解析为Resource实例</span></span><br><span class="line">		<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DefaultResourceLoader 类中获取类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先后尝试获取当前线程上下文类加载器、ClassUtils 类加载器、启动类加载器</span></span><br><span class="line">		<span class="keyword">this</span>.classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 AbstractApplicationContext 类的 refresh 方法，完成 bean 的加载与实例化工作</li>
</ol>
<p>refresh 方法是一种启动方法，在 ConfigurableApplicationContext 接口中被定义。在调用 refresh 方法之后应实例化所有的单例。如果失败，应销毁已创建的单例。</p>
<blockquote>
<p>本小节列出的所有方法，若无特别说明，均是 AbstractApplicationContext 类提供的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh(); <span class="comment">// 2.1 准备上下文，以进行刷新</span></span><br><span class="line">		<span class="comment">// 2.2 告知子类，刷新内部bean工厂，至此完成了bean的加载工作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        prepareBeanFactory(beanFactory); <span class="comment">// 2.3 为上一步获得的bean工厂设置属性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 允许在上下文子类中对bean工厂进行后处理，即在加载bean后、实例化bean前，修改</span></span><br><span class="line">            <span class="comment">// bean定义或者增加自定义的bean</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 调用上下文中注册的bean工厂处理器，后者已经注册为bean</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 注册bean处理器</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 初始化与国际化相关的属性</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// 初始化事件广播器对象</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 在特定的context子类中初始化其它特殊的bean，在SpringBoot中主要用于启动内嵌的web服务器</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 搜索监听器ApplicationListener对象并注册</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 实例化非延迟加载的单例bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 发布相应事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 启动过程中出现异常，则销毁所有已创建的bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">			<span class="comment">// 重置active字段</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches(); <span class="comment">// 清除缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>2.1 prepareRefresh 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis(); <span class="comment">// 设置上下文启动时间</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    initPropertySources(); <span class="comment">// 在上下文环境中初始化任何占位符属性源</span></span><br><span class="line">    <span class="comment">// 验证标记为必须的所有属性都是可解析的，使用默认的StandardEnvironment对象</span></span><br><span class="line">    getEnvironment().validateRequiredProperties(); </span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>2.2 obtainFreshBeanFactory 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    refreshBeanFactory(); <span class="comment">// 调用AbstractRefreshableApplicationContext类的相应方法</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>AbstractRefreshableApplicationContext 类的  refreshBeanFactory 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已存在bean工厂，则销毁之</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123; </span><br><span class="line">        destroyBeans(); <span class="comment">// 销毁已实例化的bean</span></span><br><span class="line">        closeBeanFactory(); <span class="comment">// 关闭bean工厂</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取bean工厂，默认为DefaultListableBeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 加载BeanDefinition</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 AbstractXmlApplicationContext 类的 loadBeanDefinitions 方法以加载 BeanDefinition</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取XmlBeanDefinitionReader读取器对象</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用此上下文的资源加载环境配置阅读器</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment()); <span class="comment">// StandardEnvironment</span></span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>); <span class="comment">// PathMatchingResourcePatternResolver</span></span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader); <span class="comment">// 加载bean定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>2.3 prepareBeanFactory 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 设置bean工厂的表达式语言处理器，默认使用EL表达式</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置bean工厂的上下文回调</span></span><br><span class="line">    <span class="comment">// 添加bean工厂后置处理器ApplicationContextAwareProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，完成了 ApplicationContext 容器的启动以及实例化非延迟加载的 bean。启动完成后，通过 ApplicationContext 对象的 getBean() 方法即可根据 beanName 获取相应的实例。</p>
<h4 id="四、bean-的生命周期"><a href="#四、bean-的生命周期" class="headerlink" title="四、bean 的生命周期"></a>四、bean 的生命周期</h4><p>在第二、三节分别分析了 BeanFactory 容器和 ApplicationContext 容器的启动流程。无论是 BeanFactory 容器在调用 getBean() 方法时才会实例化 bean，还是 ApplicationContext 容器在启动时就会实例化 bean，二者均涉及 bean 的实例化过程。接下来介绍 bean 由“生”至“死”的全过程。</p>
<p><img src="/2020/05/22/Spring学习之IoC/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt></p>
<h5 id="第一步：实例化-bean-对象"><a href="#第一步：实例化-bean-对象" class="headerlink" title="第一步：实例化 bean 对象"></a>第一步：实例化 bean 对象</h5><p>接口 org.springframework.beans.factory.support.InstantiationStrategy 定义了实例化策略，常见的策略有：</p>
<ul>
<li><strong>CglibSubclassingInstantiationStrategy</strong>：通过 CGLIB 动态字节码技术，动态生成子类，是默认的实现类。它支持方法注入。</li>
<li>SimpleInstantiationStrategy：基于反射技术，不支持方法注入。</li>
</ul>
<h5 id="第二步：设置对象属性"><a href="#第二步：设置对象属性" class="headerlink" title="第二步：设置对象属性"></a>第二步：设置对象属性</h5><p>第一步实例化得到的是 BeanWrapper 对象，而非相应的 bean。这是因为 BeanWrapper 对象可以方便地对 bean 进行操作，包括<strong>属性设置</strong>、<strong>类型转换</strong>等。</p>
<p>BeanWrapper 接口间接继承了下述接口：</p>
<ul>
<li>PropertyAccessor：定义了访问对象属性的方法</li>
<li>TypeConverter：定义了类型转换的方法</li>
<li>PropertyEditorRegistry：定义了注册 PropertyEditors 的方法</li>
</ul>
<h5 id="第三步：检查-bean-是否实现多种-Aware-接口"><a href="#第三步：检查-bean-是否实现多种-Aware-接口" class="headerlink" title="第三步：检查 bean 是否实现多种 Aware 接口"></a>第三步：检查 bean 是否实现多种 Aware 接口</h5><p>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring 容器会检查<strong>当前对象实例是否实现一系列以 Aware 命名结尾的接口</strong>。若有，则将相应的依赖注入到当前 bean 实例中。</p>
<ul>
<li>BeanNameAware：将该对象实例的 bean 定义对应的 beanName 设置到当前对象实例。</li>
<li>BeanClassLoaderAware：将对应加载当前 bean 的类加载器注入当前对象实例。</li>
<li>BeanFactoryAware：将 BeanFactory 容器注入当前对象实例。</li>
<li>ApplicationContextAware、ResourceLoaderAware、ApplicationEventPublisherAware 和 MessageSourceAware：将 ApplicationContext 容器注入当前对象实例。</li>
</ul>
<h5 id="第四步：BeanPostProcessor-前置处理"><a href="#第四步：BeanPostProcessor-前置处理" class="headerlink" title="第四步：BeanPostProcessor 前置处理"></a>第四步：BeanPostProcessor 前置处理</h5><p>BeanPostProcessor 接口定义了在 bean 实例化阶段进行扩展的方法，借此可“插手” bean 的实例化。</p>
<p>（1）编写实现此接口的处理类，重写 postProcessBeforeInitialization 和 postProcessAfterInitialization 方法，其中后者对应 BeanPostProcessor 的后置处理，稍后进行介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.merlin.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 扩展点：在bean实例化前调用此方法</span></span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> UserService)&#123;</span><br><span class="line">            System.out.println(<span class="string">"UserService实例化前"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在配置文件中添加 bean 定义， ApplicationContext 容器可以自动识别并加载注册到容器的 BeanPostProcessor 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"myBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.MyBeanPostProcessor"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="第五步：检查是否实现-InitializingBean-接口"><a href="#第五步：检查是否实现-InitializingBean-接口" class="headerlink" title="第五步：检查是否实现 InitializingBean 接口"></a>第五步：检查是否实现 InitializingBean 接口</h5><p>在 BeanPostProcessor 前置处理后，Spring 容器会检查当前对象实例是否实现了 InitializingBean 接口。若是，则调用 afterPropertiesSet() 方法进一步处理当前对象实例，譬如校验是否注入所有必须属性，或者在当前实例化进程的基础上添加额外的实例化方法。</p>
<p>（1）当前对象实例对应的类需要实现 InitializingBean 接口，重写其 afterPropertiesSet() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userDao!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"UserDao已注入"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第六步：检查是否配置-init-method"><a href="#第六步：检查是否配置-init-method" class="headerlink" title="第六步：检查是否配置 init-method"></a>第六步：检查是否配置 init-method</h5><p>检查 Spring 对应的 XML 配置文件中 <bean></bean> 定义是否设置了 <code>init-method</code> 属性。通过设置该属性值，可以自定义初始化操作方法名。其作用与 InitializingBean 接口的 afterPropertiesSet() 方法一致，只是后者方法名是固定的，前者则比较灵活。</p>
<h5 id="第七步：BeanPostProcessor-后置处理"><a href="#第七步：BeanPostProcessor-后置处理" class="headerlink" title="第七步：BeanPostProcessor 后置处理"></a>第七步：BeanPostProcessor 后置处理</h5><p>参考第四步。具体实现逻辑依靠重写 postProcessAfterInitialization 方法。</p>
<h5 id="第八步：检查是否实现-DisposableBean-接口"><a href="#第八步：检查是否实现-DisposableBean-接口" class="headerlink" title="第八步：检查是否实现 DisposableBean 接口"></a>第八步：检查是否实现 DisposableBean 接口</h5><p>Spring 容器将会检查<strong>单例 bean</strong> 是否实现 DisposableBean 接口。此接口定义了对象销毁的方法。常用来在关闭 Spring 容器时释放数据库连接池资源。</p>
<p>（1）实现 DisposableBean 接口，重写  方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 单例bean销毁前，执行销毁逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService被销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在 ApplicationContext 容器中注册并触发对象销毁逻辑回调行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.merlin.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.AbstractApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:ApplicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">// 在ApplicationContext容器中注册并触发对象销毁逻辑回调行为</span></span><br><span class="line">        ((AbstractApplicationContext) applicationContext).registerShutdownHook();</span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第九步：检查是否配置-destory"><a href="#第九步：检查是否配置-destory" class="headerlink" title="第九步：检查是否配置 destory"></a>第九步：检查是否配置 destory</h5><p>类似于第六步，检查 Spring 对应的 XML 配置文件中 <bean></bean> 定义是否设置了 <code>destory-method</code> 属性，即销毁方法，常用于关闭数据库连接池。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">destory-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至此，由 Spring 管理的某个 bean 走完了它的一生！</p>
<h4 id="五、容器装配-bean-的三种方式"><a href="#五、容器装配-bean-的三种方式" class="headerlink" title="五、容器装配 bean 的三种方式"></a>五、容器装配 bean 的三种方式</h4><p>Spring IoC 容器装配 bean 的三种常见方式如下：</p>
<ul>
<li><strong>注解方式</strong>【常用】</li>
<li>XML 文件配置</li>
<li>Java 类配置方式</li>
</ul>
<h5 id="5-1-注解方式"><a href="#5-1-注解方式" class="headerlink" title="5.1 注解方式"></a>5.1 注解方式</h5><p>使用注解方式，常用的几个注解如下：</p>
<ul>
<li>@Component  不识别 bean 所在的层次</li>
<li>@Controller  控制层</li>
<li>@Service  业务逻辑层（service 层）</li>
<li>@Repository  数据访问层（dao 层）</li>
<li>@Autowired  自动装配</li>
</ul>
<p>（1）DAO 层接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Service 层接口与实现类：<strong>不需要被注入 UserDao 对象的 setter 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自动装配</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在 Spring 的配置文件中配置自动扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置包扫描，使得Spring能扫描到相关包中对外暴露的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin.dao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin.service"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）使用时，加载 Spring 配置文件获取 ApplicationContext 对象，调用 getBean 方法获取相应的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载Spring配置文件</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"ApplicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">// 获取UserService对象</span></span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-XML-文件配置"><a href="#5-2-XML-文件配置" class="headerlink" title="5.2 XML 文件配置"></a>5.2 XML 文件配置</h5><p>（1）DAO 层接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Service 层接口与实现类：<strong>需要有相应的 setter 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao; <span class="comment">// setter方式注入依赖</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在 Spring 的 XML 配置文件中声明需要交由 Spring 管理的 bean 以及依赖关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明UserDao对象，交由Spring管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明UserService对象，交由Spring管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过setter方法注入UserDao对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）使用时，加载 Spring 配置文件获取 ApplicationContext 对象，调用 getBean 方法获取相应的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载Spring配置文件</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"ApplicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">// 获取UserService对象</span></span><br><span class="line">        UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-Java-类配置方式"><a href="#5-3-Java-类配置方式" class="headerlink" title="5.3 Java 类配置方式"></a>5.3 Java 类配置方式</h5><p>常用的注解：</p>
<ul>
<li>@Configuration  声明 BeanConfiguration类</li>
<li>@Bean  声明 bean</li>
</ul>
<p>（1）DAO 层接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">daoFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Service 层接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao; <span class="comment">// setter方式注入依赖</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>新建 Java 类：BeanConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userServiceImpl.setUserDao(userDao()); <span class="comment">// 注入UserDao对象</span></span><br><span class="line">        <span class="keyword">return</span> userServiceImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）使用 AnnotationConfigApplicationContext 类加载 BeanConfiguration 配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext config = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        UserService userService = (UserService) config.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.serviceFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、容器依赖注入的三种方式"><a href="#六、容器依赖注入的三种方式" class="headerlink" title="六、容器依赖注入的三种方式"></a>六、容器依赖注入的三种方式</h4><ul>
<li>构造方法注入</li>
<li>setter 方法注入</li>
<li><strong>注解方式</strong>【常用】</li>
</ul>
<blockquote>
<p>此部分代码与第五节基本相同，可参考之。</p>
</blockquote>
<h5 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h5><p>通过构造方法注入 bean 的依赖关系！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 待注入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserDao userDao)</span></span>&#123; <span class="comment">// 构造方法注入依赖关系</span></span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.daoFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 的 XML 配置文件中声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过构造方法注入UserDao对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-2-setter-方法注入"><a href="#6-2-setter-方法注入" class="headerlink" title="6.2 setter 方法注入"></a>6.2 setter 方法注入</h5><p>通过 setter 方法注入 bean 的依赖关系！</p>
<p>在 Spring 的 XML 配置文件中声明需要交由 Spring 管理的 bean 以及依赖关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过setter方法注入UserDao对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-3-注解方式"><a href="#6-3-注解方式" class="headerlink" title="6.3 注解方式"></a>6.3 注解方式</h5><p>@Autowired  自动装配</p>
<p>（代码参考 5.1 注解方式）</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 《Spring揭秘》</p>
<p>[2] <a href="https://www.cnblogs.com/javazhiyin/p/10905294.html" target="_blank" rel="noopener">深究Spring中Bean的生命周期</a></p>
<p>[3] <a href="https://blog.csdn.net/yzqingqing/article/details/84888911" target="_blank" rel="noopener">spring-bean 全生命周期时序图</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码六：Hashtable源码阅读笔记</title>
    <url>/2020/05/22/Hashtable%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的 <strong>Hashtable</strong> 类的源码阅读笔记，重点如下：</p>
<ul>
<li>Hashtable 底层结构及头插法和扩容原理。</li>
<li>获取键、值的枚举器或迭代器，以及获取键值对的迭代器。</li>
</ul>
<a id="more"></a>

<h4 id="1-Hashtable-的概述"><a href="#1-Hashtable-的概述" class="headerlink" title="1. Hashtable 的概述"></a>1. Hashtable 的概述</h4><p>Hashtable 类的类继承关系如下图，它继承自抽象类 Dictionary，实现了 Map、Cloneable 和 Serializable 接口。Hashtable 和 HashMap 都是散列表，被用来存储键值对。Hashtable 不允许键或值为 null ，而 HashMap 允许键或值为 null。</p>
<p><img src="/2020/05/22/Hashtable源码阅读笔记/Hashtable%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.jpg" alt></p>
<h4 id="2-字段与构造方法"><a href="#2-字段与构造方法" class="headerlink" title="2. 字段与构造方法"></a>2. 字段与构造方法</h4><h5 id="2-1-字段与构造方法"><a href="#2-1-字段与构造方法" class="headerlink" title="2.1 字段与构造方法"></a>2.1 字段与构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">// 数组，即桶</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count; <span class="comment">// 总记录数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// rehash操作的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// 结构化修改次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>; <span class="comment">// 最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举或迭代器类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet; <span class="comment">// 键的Set视图对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">// 键值对映射的Set视图对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values; <span class="comment">// 值的Collection视图对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> <span class="comment">// 创建一个空的哈希表，初始容量为11，负载因子为0.75</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> <span class="comment">// 指定初始容量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> <span class="comment">// 指定初始容量和负载因子</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K,? extends V&gt; t)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-底层数据结构"><a href="#2-2-底层数据结构" class="headerlink" title="2.2 底层数据结构"></a>2.2 底层数据结构</h5><p>Hashtable 的底层数据结构是：数组 + 链表，如下图所示：</p>
<p><img src="/2020/05/22/Hashtable源码阅读笔记/Hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt></p>
<p>保存键值对的 Entry 节点实现类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key =  key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Entry对象的哈希值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-初始化过程"><a href="#2-3-初始化过程" class="headerlink" title="2.3 初始化过程"></a>2.3 初始化过程</h5><p>一般地，通过调用空参构造函数以获取 Hashtable 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>); <span class="comment">// 默认的初始容量为11，负载因子为0.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量不能为负数</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    <span class="comment">// 负载因子必须为整数</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line">	<span class="comment">// 如果传入的初始容量为0，则将其设为1</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity]; <span class="comment">// 新建table数组</span></span><br><span class="line">    <span class="comment">// 计算rehash操作的阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> <span class="comment">// 将值映射至哈希表中指定的键</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> <span class="comment">// 判断哈希表中是否含有指定的键</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> <span class="comment">// 判断哈希表中是否含有指定的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> <span class="comment">// 从哈希表中移除指定的键（及值）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">// 清空</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> <span class="comment">// 获取哈希表中键的枚举</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> <span class="comment">// 获取哈希表中值的枚举</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> <span class="comment">// 返回键的Set视图</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> <span class="comment">// 返回键值对映射的Set视图</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> <span class="comment">// 返回值的Collection视图</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-put-K-key-V-value-方法"><a href="#3-1-put-K-key-V-value-方法" class="headerlink" title="3.1 put(K key, V value) 方法"></a>3.1 put(K key, V value) 方法</h5><p>覆盖旧值或以<strong>头插法</strong>插入新节点。</p>
<p>Hashtable 中计算索引的方式与 HashMap 有所不同。考虑到 <code>int hash = key.hashCode()</code> 计算得到的 <code>hash</code> 值可能为<strong>负数</strong>，首先将其与 <code>0x7FFFFFFF</code>（最高位为0、剩下31位为1）做<strong>与运算</strong>，随后对数组 <code>table</code> 长度取模。</p>
<p>在 HashMap 中，首先对计算得到的 <code>hash</code> 与其高 <code>16</code> 位做异或运算，随后通过 <code>( table.length - 1 ) &amp; hash</code> 计算索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 值不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 调用Object基类的本地hashCode方法计算哈希值。若key为null，则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 计算数组中索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 遍历链表，如果键已存在则更新值，并返回旧值</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果键不存在，调用私有的addEntry方法插入新的键值对</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用私有方法 addEntry</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        rehash(); <span class="comment">// 调用rehash方法扩容</span></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length; <span class="comment">// 计算索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 以头插法形式插入新节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-2-rehash-方法"><a href="#3-2-rehash-方法" class="headerlink" title="3.2 rehash() 方法"></a>3.2 rehash() 方法</h5><p>当哈希表总记录数达到 rehash 操作的阈值，即 <code>count &gt;= threshold</code> 时，执行 rehash 操作。</p>
<ul>
<li>首先根据 <code>newCapacity = (oldCapacity &lt;&lt; 1) + 1</code> 计算新数组长度。考虑到计算得到的 <code>newCapacity</code> 可能溢出或达到 <code>MAX_ARRAY_SIZE</code>，这时将 <code>newCapacity</code> 直接置为<code>MAX_ARRAY_SIZE</code>。</li>
<li>重新计算所有节点的索引，以<strong>头插法</strong>形式插入新数组中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length; <span class="comment">// 旧数组长度</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 新数组长度为旧数组长度的2倍再加1</span></span><br><span class="line">    <span class="comment">// 若newCapacity溢出，或不小于MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若旧数组长度已经等于MAX_ARRAY_SIZE，直接终止rehash操作并返回</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE; <span class="comment">// 否则，将MAX_ARRAY_SIZE赋予新数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算所有节点的索引，以头插法形式插入新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="comment">// 从旧数组链表头节点开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity; <span class="comment">// 重新计算索引</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index]; <span class="comment">// 头插法</span></span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-3-containsKey-Object-key-方法"><a href="#3-3-containsKey-Object-key-方法" class="headerlink" title="3.3 containsKey(Object key) 方法"></a>3.3 containsKey(Object key) 方法</h5><p>判断哈希表中是否含有指定的键，返回判断结果。若 <code>key == null</code>，抛出 NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 调用Object基类的本地hashCode方法计算哈希值。若key为null，则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 根据哈希值计算索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="comment">// 判断键是否相同</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-4-contains-Object-value-方法"><a href="#3-4-contains-Object-value-方法" class="headerlink" title="3.4 contains(Object value) 方法"></a>3.4 contains(Object value) 方法</h5><p>containsValue(Object value) 方法与 contains(Object value) 方法在功能实现上是等效的。</p>
<p>最坏情况下，contains 方法需要遍历所有节点。此方法时间复杂度高于 containsKey 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 从数组尾部开始，从链表头部开始，遍历查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-5-remove-Object-key-方法"><a href="#3-5-remove-Object-key-方法" class="headerlink" title="3.5 remove(Object key) 方法"></a>3.5 remove(Object key) 方法</h5><p>试图移除指定的键及其对应的值。若指定的键存在，则返回对应的值；否则返回 null。若 <code>key == null</code>，则抛出 NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="comment">// 借助前驱节点prev，快速移除指定节点</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>; <span class="comment">// 便于GC回收</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-6-clear-方法"><a href="#3-6-clear-方法" class="headerlink" title="3.6 clear() 方法"></a>3.6 clear() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">        tab[index] = <span class="keyword">null</span>; <span class="comment">// 清除所有桶中的头节点</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-7-keys-方法"><a href="#3-7-keys-方法" class="headerlink" title="3.7 keys() 方法"></a>3.7 keys() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用私有的 getEnumeration 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyEnumeration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>); <span class="comment">// 实例化枚举对象（此私有内部类源码见4.1节）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-8-elements-方法"><a href="#3-8-elements-方法" class="headerlink" title="3.8 elements() 方法"></a>3.8 elements() 方法</h5><p>类似于 Enumeration<k> keys() 方法，只是将形参由 <code>KEYS</code> 改为 <code>VALUES</code>。</k></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-9-keySet-方法"><a href="#3-9-keySet-方法" class="headerlink" title="3.9 keySet() 方法"></a>3.9 keySet() 方法</h5><p>若变量 <code>keySet</code> 为空，调用工具类 Collections 的 synchronizedSet() 方法获取<strong>线程安全的集合对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断变量keySet是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">        keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> keySet; <span class="comment">// 变量keySet不为空，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-10-entrySet-方法"><a href="#3-10-entrySet-方法" class="headerlink" title="3.10 entrySet() 方法"></a>3.10 entrySet() 方法</h5><p>若变量 <code>entrySet</code> 为空，调用工具类 Collections 的 synchronizedSet() 方法获取<strong>线程安全的集合对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">        entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-11-values-方法"><a href="#3-11-values-方法" class="headerlink" title="3.11 values() 方法"></a>3.11 values() 方法</h5><p>若变量 <code>values</code> 为空，调用工具类 Collections 的 synchronizedCollection 方法获取<strong>线程安全的集合对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h4><h5 id="4-1-Enumerator"><a href="#4-1-Enumerator" class="headerlink" title="4.1 Enumerator"></a>4.1 Enumerator</h5><p>Enumerator 是哈希表枚举器类，同时实现 Enumeration 和 Iterator 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt;[] table = Hashtable.<span class="keyword">this</span>.table; <span class="comment">// Hashtable.this.table表示当前Hashtable实例的table数组对象</span></span><br><span class="line">    <span class="keyword">int</span> index = table.length;</span><br><span class="line">    Entry&lt;?,?&gt; entry;</span><br><span class="line">    Entry&lt;?,?&gt; lastReturned;</span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">// 类型变量(T)，0--key, 1--value, 2--entry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识实例化枚举器还是迭代器，true表示迭代器，false表示枚举器</span></span><br><span class="line">    <span class="keyword">boolean</span> iterator;</span><br><span class="line">	<span class="comment">// 用于迭代器，不用于枚举器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.iterator = iterator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 Enumerator 类提供的方法</p>
<p>（1）hasMoreElements &amp; hasNext</p>
<p>实现 Enumeration 接口的 hasMoreElements 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; e = entry;</span><br><span class="line">    <span class="keyword">int</span> i = index;</span><br><span class="line">    Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">    <span class="comment">// 从索引高位开始向低位遍历，寻找首个非空的桶</span></span><br><span class="line">    <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        e = t[--i];</span><br><span class="line">    &#125;</span><br><span class="line">    entry = e;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">return</span> e != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器 Iterator 使用的 hasNext 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasMoreElements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）nextElement &amp; next</p>
<p>实现 Enumeration 接口的 nextElement 方法。需要注意的是，<strong>枚举器的 nextElement 方法在遍历过程中不需要判断</strong> <code>Hashtable</code> <strong>是否发生结构化修改，而迭代器的 next 方法需要先判断</strong> <code>modCount != expectedModCount</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; et = entry;</span><br><span class="line">    <span class="keyword">int</span> i = index;</span><br><span class="line">    Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">    <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">    <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        et = t[--i];</span><br><span class="line">    &#125;</span><br><span class="line">    entry = et;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将节点entry地址赋予变量e和lastReturned</span></span><br><span class="line">        Entry&lt;?,?&gt; e = lastReturned = entry;</span><br><span class="line">        entry = e.next;</span><br><span class="line">        <span class="comment">// 根据类型，判断返回是key还是value</span></span><br><span class="line">        <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器 Iterator 使用的 next 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">return</span> nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码验证</em></strong></p>
<p>获取枚举器后，在遍历过程中删除集合中的键值对，程序正常执行，成功删除指定键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            hashtable.put(i, (<span class="keyword">int</span>) Math.pow(i, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Enumeration&lt;Integer&gt; enumeration = hashtable.keys();</span><br><span class="line">        <span class="keyword">while</span>(enumeration.hasMoreElements())&#123;</span><br><span class="line">            System.out.print(hashtable.get(enumeration.nextElement()) + <span class="string">" "</span>);</span><br><span class="line">            hashtable.remove(Integer.valueOf(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取迭代器后，在遍历过程中删除集合中的键值对，抛出 <code>ConcurrentModificationException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            hashtable.put(i, (<span class="keyword">int</span>) Math.pow(i, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; itr = (Iterator&lt;Integer&gt;) hashtable.keys();</span><br><span class="line">        <span class="keyword">while</span>(itr.hasNext())&#123;</span><br><span class="line">            System.out.print(hashtable.get(itr.next()));</span><br><span class="line">            hashtable.remove(Integer.valueOf(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）remove</p>
<p>迭代器 Iterator 使用的 remove 方法，枚举器无此方法！</p>
<p>remove 方法通过 synchronized 关键字对删除节点的代码块进行加锁，锁对象是当前 <code>Hashtable</code> 实例。此方法删除的是<strong>刚访问过的节点</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是迭代器类型</span></span><br><span class="line">    <span class="keyword">if</span> (!iterator)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Enumerator"</span>);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">	<span class="comment">// 锁对象是当前Hashtable实例</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">        Entry&lt;?,?&gt;[] tab = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> index = (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == lastReturned) &#123; <span class="comment">// 定位至刚访问过的节点</span></span><br><span class="line">                modCount++;</span><br><span class="line">                expectedModCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                count--;</span><br><span class="line">                lastReturned = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-KeySet"><a href="#4-2-KeySet" class="headerlink" title="4.2 KeySet"></a>4.2 KeySet</h5><p>键的 Set 集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(KEYS); <span class="comment">// fast-fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-EntrySet"><a href="#4-3-EntrySet" class="headerlink" title="4.3 EntrySet"></a>4.3 EntrySet</h5><p>键值对映射的 Set 集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(ENTRIES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-ValueCollection"><a href="#4-4-ValueCollection" class="headerlink" title="4.4 ValueCollection"></a>4.4 ValueCollection</h5><p>值的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueCollection</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getIterator(VALUES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsValue(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul>
<li>Hashtable 不允许键或值为 null。</li>
<li>Hashtable 底层结构是<strong>数组 + 链表</strong>。</li>
<li>Hashtable 不保证有序。</li>
<li>Hashtable 以<strong>头插法</strong>插入新节点，HashMap 以尾插法插入新节点。</li>
<li>Hashtable 的扩容机制：新的 <code>table</code> 数组长度是原数组长度的 2 倍且加 1，并核算其是否溢出或大于 <code>Integer.MAX_VALUE - 8</code>，若是则将新数组长度设为 <code>Integer.MAX_VALUE - 8</code>。随后重新计算每一个节点的位置，以头插形式插入新的数组中。</li>
<li>Hashtable 是同步的，对外提供的方法均通过<strong>关键字 synchronized 加锁</strong>。如果不需要线程安全的实现，建议使用 HashMap 替代 Hashtable。如果需要线程安全的高度并发实现，建议使用 ConcurrentHashMap 替代 Hashtable。<strong>因为 Hashtable 类中的锁对象是当前实例对象，锁粒度大于 ConcurrentHashMap</strong>，显然后者的并发性要高于前者。</li>
<li>keys() 和 elements() 方法返回的枚举器 Enumeration 不是快速失败的，而 keySet()、entrySet() 和 values() 返回的集合的迭代器方法返回的迭代器都是快速失败的，且后三种方法均是调用工具类 Collections 的静态方法获取线程安全的集合对象。</li>
</ul>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>Hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>String源码阅读笔记</title>
    <url>/2020/05/22/String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的 String 类的源码阅读笔记，重点如下：</p>
<ul>
<li>String 类是不可变的，它不对外提供修改字符串的方法，但可以通过反射技术修改保存字符串的字符数组。</li>
<li>StringBuffer、StringBuilder 类支持可变字符串，前者还是线程安全的类。</li>
<li>计算哈希值时采用 31 作为乘子，是考虑到减少哈希冲突和便于计算。</li>
</ul>
<a id="more"></a>

<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>String 类用来存储字符串，由 final 修饰，因此不能被继承。在 String 内部通过字符数组对象 <code>value</code> 保存字符串，且该字符数组也是由 final 修饰的。需要注意的是，String 类对外提供的修改字符串的方法，均会生成一个新的字符串对象。此外，字符串缓存区（StringBuffer 类、StringBuilder 类）是支持可变字符串的。</p>
<p>String 类的常见方法有：检查序列中的各个字符，比较字符串，搜索字符串，字符大小写转换，提取子字符串并创建字符串的副本，等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Serializable 接口：序列化标志接口，无任何定义方法。</li>
<li>Comparable 接口：按序比较单个字符的 ASCII 码，以比较字符串的大小。</li>
<li>CharSequence 接口：字符值的可读序列。</li>
</ul>
<h4 id="2-字段与构造方法"><a href="#2-字段与构造方法" class="headerlink" title="2. 字段与构造方法"></a>2. 字段与构造方法</h4><h5 id="2-1-常量和成员变量"><a href="#2-1-常量和成员变量" class="headerlink" title="2.1 常量和成员变量"></a>2.1 常量和成员变量</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">// 字符数组，用于存储字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// 缓存字符串的哈希值</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h5><p>String 类的构造方法较多，以下仅介绍常用的几种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>; <span class="comment">// 新建original对象的副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>; <span class="comment">// 根据字符数组新建String对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span></span>; <span class="comment">// 根据StringBuffer对象新建String对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span></span>; <span class="comment">// 根据StringBuilder对象新建String对象</span></span><br></pre></td></tr></table></figure>

<p>（1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）调用工具类 Arrays 的 copyOf 方法拷贝原字符数组，得到副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）因 StringBuffer 是同步的，故对对象 <code>buffer</code> 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 获取String对象的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;&#125; <span class="comment">// 比较两个字符串是否相等，区分大小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;&#125; <span class="comment">// 将字符串转换成字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;&#125; <span class="comment">// 根据首尾索引截断字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 删除字符串中前部和尾部空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">// 将字符串str拼接到当前字符串尾部</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-hashCode-方法"><a href="#3-1-hashCode-方法" class="headerlink" title="3.1 hashCode() 方法"></a>3.1 hashCode() 方法</h5><p>String 类重写基类 Object 的 hashCode 方法，计算哈希值的公式为：<br>$$<br>s[0]<em>31^{(n-1)} + s[1]</em>31^{(n-2)} + … + s[n-1]<br>$$<br>其中 <code>n</code> 为字符串长度，<code>s[n]</code> 为相应字符的 ASCII 码值。</p>
<p><strong>为什么选择 31 作为乘子？</strong></p>
<ul>
<li>使用 31 作为乘子得到的哈希值分布较为均匀，减少了哈希冲突。</li>
<li>当然，使用常数 31, 33, 37, 39 或 41 作为乘子，哈希冲突情况都比较理想。此时涉及的 31 的另一个重要特性：<code>31 * i = (i&lt;&lt;5) - i</code>。现代的 JVM 能自动将 <code>31 * i</code> 乘法运算优化为移位和减法运算，提高了计算性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash; <span class="comment">// hash默认为0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-2-equals-object-anObject-方法"><a href="#3-2-equals-object-anObject-方法" class="headerlink" title="3.2 equals(object anObject) 方法"></a>3.2 equals(object anObject) 方法</h5><p>重写基类 Object 的 equals 方法，将引用比较（地址比较）改为值比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两个对象的内存地址相同，即同一个对象，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 比较两个字符的ASCII码</span></span><br><span class="line">                <span class="comment">// 注意：大小写字母是不等的</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 只有所有字符一一对应，才返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-3-toCharArray-方法"><a href="#3-3-toCharArray-方法" class="headerlink" title="3.3 toCharArray() 方法"></a>3.3 toCharArray() 方法</h5><p>此方法可以将字符串转换成字符数组。使用此方法需要注意两点：</p>
<ul>
<li>不能直接返回 <code>value</code> 对象，必须返回副本。虽然 <code>value</code> 数组是被 final 修饰的，这仅仅意味着<strong>它指向的内存地址是不可改变的</strong>，但是该地址保存的内容仍是可以被修改的，最终导致 String 的不变性被破坏。</li>
<li>获取副本必须使用 System 类的 arrayCopy 方法。根据源码注释，这是因为类的初始化顺序问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">    <span class="comment">// 必须使用System类的arrayCopy方法</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-4-subString-int-beginIndex-int-endIndex-方法"><a href="#3-4-subString-int-beginIndex-int-endIndex-方法" class="headerlink" title="3.4 subString(int beginIndex, int endIndex) 方法"></a>3.4 subString(int beginIndex, int endIndex) 方法</h5><p>此方法用来截断字符串。在合法的参数范围内，子串应从原字符串的索引 <code>beginIndex</code> 处开始，直至索引 <code>endIndex - 1</code> 处，子串长度为 <code>endIndex - beginIndex</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若恰好截取整个原字符串，直接返回原字符串对象</span></span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">        : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-5-trim-方法"><a href="#3-5-trim-方法" class="headerlink" title="3.5 trim() 方法"></a>3.5 trim() 方法</h5><p>此方法用于消除字符串首、尾部的空格。若原字符串为空，或首字符和尾字符均非空格，则直接返回原字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">	<span class="comment">// 循环寻找头部的空格</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环寻找尾部的空格</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-6-compareTo-String-anotherString-方法"><a href="#3-6-compareTo-String-anotherString-方法" class="headerlink" title="3.6 compareTo(String anotherString) 方法"></a>3.6 compareTo(String anotherString) 方法</h5><p>与 equals 方法有点相似，但不完全相同。当字符串相同时，返回 <code>0</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-7-concat-String-str-方法"><a href="#3-7-concat-String-str-方法" class="headerlink" title="3.7 concat(String str) 方法"></a>3.7 concat(String str) 方法</h5><p>将字符串 <code>str</code> 拼接至当前字符串的尾部，底层实现基于字符数组的拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len); <span class="comment">// 拼接至字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 getChars(char dst[], int dstBegin) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引dstBegin开始，将当前字符串对象放入进dst字符数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h4><h5 id="String-类是不可变的，那么一定是完全不会被修改的吗？"><a href="#String-类是不可变的，那么一定是完全不会被修改的吗？" class="headerlink" title="String 类是不可变的，那么一定是完全不会被修改的吗？"></a>String 类是不可变的，那么一定是完全不会被修改的吗？</h5><p>（1）使用 String 类提供的方法尝试修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        String oldStr = <span class="string">"Hello World"</span>;</span><br><span class="line">        String newStr = oldStr.replace(<span class="string">' '</span>, <span class="string">'-'</span>);</span><br><span class="line">        System.out.println(<span class="string">"old string: "</span>+oldStr.toString());</span><br><span class="line">        System.out.println(<span class="string">"new string: "</span>+newStr.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">old string: Hello World</span><br><span class="line">new string: Hello-World</span><br></pre></td></tr></table></figure>

<p>调用 String 类提供的方法修改字符串，<strong>返回的是一个新的字符串，原字符串并未改变</strong>。</p>
<p>（2）使用反射技术尝试修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">        				<span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        String oldStr = <span class="string">"Hello World"</span>;</span><br><span class="line">        Class clazz = oldStr.getClass();</span><br><span class="line">        <span class="comment">// 反射获取字段对象</span></span><br><span class="line">        Field field = clazz.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">// 获取私有属性的访问权限</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">char</span>[] arr = (<span class="keyword">char</span>[]) field.get(oldStr);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="string">'-'</span>;</span><br><span class="line">        System.out.println(oldStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello-World</span><br></pre></td></tr></table></figure>

<p>在反射前后 <code>oldStr</code> 对象的 hashCode 也保持不变。String 类不对外提供修改原字符串的方法，但通过反射技术仍能够修改原字符串。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">科普：为什么 String hashCode 方法选择数字31作为乘子</a></p>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码五：LinkedList源码阅读笔记</title>
    <url>/2020/05/17/LinkedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的 LinkedList 类的源码阅读笔记，包括如下内容：</p>
<ul>
<li>LinkedList 类提供的常见方法。</li>
<li>分别比较 LinkedList 类提供的多种添加或获取元素的方法。</li>
<li>内部迭代器类 ListItr 。</li>
<li>for 循环、forEach 和迭代器遍历 LinkedList 的性能比较。</li>
</ul>
<a id="more"></a>

<h4 id="1-LinkedList的概述"><a href="#1-LinkedList的概述" class="headerlink" title="1. LinkedList的概述"></a>1. LinkedList的概述</h4><p><img src="/2020/05/17/LinkedList源码阅读笔记/LinkedList%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.jpg" alt></p>
<p>LinkedList 类继承自抽象类 AbstractSequentialList，实现了 List、Deque（双端队列）、Cloneable、和 Serializable 接口。</p>
<ul>
<li>底层结构双向链表，支持 null 元素。</li>
<li>插入和删除元素的时间复杂度为 O(1)；不支持随机访问，查找操作的时间复杂度为 O(N)。</li>
<li>未实现同步，可通过 Collections 类的 synchronizedList 方法获得线程安全的类。</li>
<li>迭代器是 fail-fast 的。迭代过程中，除使用迭代器的 add 或 remove 方法，任何对集合的结构修改均会抛出 ConcurrentModificationException。</li>
<li>LinkedList 可用来实现队列（Queue）和栈（Stack）。</li>
</ul>
<h4 id="2-字段和构造方法"><a href="#2-字段和构造方法" class="headerlink" title="2. 字段和构造方法"></a>2. 字段和构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 头节点指针</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 尾节点指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 空参构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造一个包含指定集合c的LinkedList对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 是没有默认初始容量的，或者说其默认大小为 0。调用空参构造方法时，会初始化两个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// 继承自抽象类AbstractList</span></span><br></pre></td></tr></table></figure>

<h4 id="3-内部节点结构"><a href="#3-内部节点结构" class="headerlink" title="3. 内部节点结构"></a>3. 内部节点结构</h4><p>LinkedList 内部的节点结构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 元素值</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 前驱节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 后继节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h4><p>LinkedList 对外提供的常用方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">// 在链表尾部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 在指定位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">// 在链表头部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">// 获取并返回链表头部元素，且在链表中删除该元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 返回并移除指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">// 移除首次出现的对象o，o可以是null。移除成 功返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 从指定位置开始返回迭代器</span></span><br></pre></td></tr></table></figure>

<p><strong>LinkedList 提供的添加元素的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">添加元素位置</th>
<th align="center">返回值</th>
<th align="center">内部实现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(E e)</td>
<td align="center">尾部</td>
<td align="center">true</td>
<td align="center">linkLast</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">尾部</td>
<td align="center">void</td>
<td align="center">linkLast</td>
</tr>
<tr>
<td align="center">offer(E e)</td>
<td align="center">尾部</td>
<td align="center">true</td>
<td align="center">add + linkLast</td>
</tr>
<tr>
<td align="center">offerLast(E e)</td>
<td align="center">尾部</td>
<td align="center">true</td>
<td align="center">addLast + linkLast</td>
</tr>
<tr>
<td align="center">add(int index, E element)</td>
<td align="center">指定位置</td>
<td align="center">void</td>
<td align="center">linkLast 或 linkBefore</td>
</tr>
<tr>
<td align="center">addFirst(E e)</td>
<td align="center">头部</td>
<td align="center">void</td>
<td align="center">linkFirst</td>
</tr>
<tr>
<td align="center">offerFirst(E e)</td>
<td align="center">头部</td>
<td align="center">true</td>
<td align="center">addFirst + linkFirst</td>
</tr>
<tr>
<td align="center">push(E e)</td>
<td align="center">头部、栈顶</td>
<td align="center">void</td>
<td align="center">addFirst + linkFirst</td>
</tr>
</tbody></table>
<h5 id="（1）add-E-e-方法"><a href="#（1）add-E-e-方法" class="headerlink" title="（1）add(E e) 方法"></a>（1）add(E e) 方法</h5><p>在链表尾部添加元素 <code>e</code> ，等效于 addLast(E e) 方法。add 方法成功添加元素后，返回 <code>true</code>；addLast 方法内部同样是调用 linkLast 方法，但它没有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e); <span class="comment">// 新建并插入节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用默认的 linkLast方法，新建并插入节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>); <span class="comment">// 新建节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode; <span class="comment">// 插入的是第一个节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（2）add-int-index-E-element-方法"><a href="#（2）add-int-index-E-element-方法" class="headerlink" title="（2）add(int index, E element) 方法"></a>（2）add(int index, E element) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element); <span class="comment">// 在链表尾部插入新元素，调用linkLast方法</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index)); <span class="comment">// 在链表非尾部插入新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向指定位置插入元素时，首先调用私有方法 checkPositionIndex，检查指定索引是否合法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="comment">// 待插入位置不合法，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用私有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size; <span class="comment">// 判断待插入位置是否合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看在链表非尾部插入新元素的方法 linkBefore(E e, Node<e> succ)。</e></p>
<p>首先，在明确索引 <code>index</code> 是合法位置的前提下，调用 node 方法获得该位置处的节点。node 方法的巧妙之处在于，它需要先明确指定索引属于链表前半段还是后半段，据此决定是从链表头节点还是尾节点开始遍历寻找，以缩短查找时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 指定位置在链表前半段，从头节点开始向后遍历、寻找</span></span><br><span class="line">   <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定位置在链表后半段，从尾节点开始向前遍历、寻找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在链表非尾部位置插入新元素，只需要修改节点的前驱、后继节点指针即可，速度快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode; <span class="comment">// 插入位置是头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（3）addFirst-E-e-方法"><a href="#（3）addFirst-E-e-方法" class="headerlink" title="（3）addFirst(E e) 方法"></a>（3）addFirst(E e) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用私有方法 linkFirst(E e)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode; <span class="comment">// 插入链表头部</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>LinkedList 提供的获取元素的方法</strong></p>
<p>对于不可返回 null 的方法：</p>
<ul>
<li>get(int index) 方法：索引越界时，抛出 IndexOutOfBoundsException。</li>
<li>其它三种方法：链表为空时，抛出 NoSuchElementException。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">获取元素的位置</th>
<th align="center">内部实现</th>
<th align="center">是否删除元素</th>
<th align="center">速度</th>
<th align="center">是否可返回null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get(int index)</td>
<td align="center">指定位置</td>
<td align="center">node(int index)</td>
<td align="center"></td>
<td align="center">慢</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">getFirst()</td>
<td align="center">头部</td>
<td align="center">first 节点</td>
<td align="center">否</td>
<td align="center">快</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">peek()</td>
<td align="center">头部</td>
<td align="center">first 节点</td>
<td align="center">否</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">peekFirst()</td>
<td align="center">头部</td>
<td align="center">first 节点</td>
<td align="center">否</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">poll()</td>
<td align="center">头部</td>
<td align="center">unlinkFirst 方法</td>
<td align="center">是</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">pollFirst()</td>
<td align="center">头部</td>
<td align="center">unlinkFirst 方法</td>
<td align="center">是</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">头部、栈顶</td>
<td align="center">unlinkFirst 方法</td>
<td align="center">是</td>
<td align="center">快</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">getLast()</td>
<td align="center">尾部</td>
<td align="center">last 节点</td>
<td align="center">否</td>
<td align="center">快</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">peekLast()</td>
<td align="center">尾部</td>
<td align="center">last 节点</td>
<td align="center">否</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">pollLast()</td>
<td align="center">尾部</td>
<td align="center">unlinkLast 方法</td>
<td align="center">是</td>
<td align="center">快</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h5 id="（4）get-int-index-方法"><a href="#（4）get-int-index-方法" class="headerlink" title="（4）get(int index) 方法"></a>（4）get(int index) 方法</h5><p>获取元素时调用的检查索引的 checkElementIndex 方法，与插入元素时调用的 checkPositionIndex 方法是不同的。前者需要满足 <code>index &lt; size</code>，而后者需要满足 <code>index &lt;= size</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查索引位置是否合法</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item; <span class="comment">// 查找节点，获取并返回节点元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（5）E-poll-方法"><a href="#（5）E-poll-方法" class="headerlink" title="（5）E poll() 方法"></a>（5）E poll() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 unlinkFirst 方法，返回头节点元素值并删除头节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（6）remove-int-index-方法"><a href="#（6）remove-int-index-方法" class="headerlink" title="（6）remove(int index) 方法"></a>（6）remove(int index) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 检查索引是否合法</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index)); <span class="comment">// 删除节点，返回元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 unlink 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item; <span class="comment">// 待删除元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next; <span class="comment">// 待删除节点是头节点时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev; <span class="comment">// 待删除节点是尾节点时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（7）remove-Object-o-方法"><a href="#（7）remove-Object-o-方法" class="headerlink" title="（7）remove(Object o) 方法"></a>（7）remove(Object o) 方法</h5><blockquote>
<p>由于 LinkedList 可以存储 null，所以待删除对象可以为 null。若链表中存有 null，则删除 null 的操作是成功的，返回 true。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除null时</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从头节点开始向后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从头节点开始向后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（8）listIterator-int-index-方法"><a href="#（8）listIterator-int-index-方法" class="headerlink" title="（8）listIterator(int index) 方法"></a>（8）listIterator(int index) 方法</h5><p>关于 LinkedList 类的迭代器，需要知道以下几点：</p>
<ul>
<li>虽然 listIterator 方法返回从指定位置 <code>index</code> 开始的迭代器，但只要 <code>index &gt; 0</code>，仍可调用 previous 方法向前遍历！</li>
<li>LinkedList 类继承了抽象类 AbstractList 的 listIterator() 方法，使用该方法获取迭代器时，内部调用的是 listIterator(int index) 方法以获取 <code>ListItr</code> 对象，其中 <code>index == 0</code> 。</li>
<li>LinedList 类继承了抽象类 AbstractSequentialList 的 iterator() 方法，其本质仍是调用 LinkedList 类的 listIterator(int index) 方法以获取 <code>ListItr</code> 对象，其中 <code>index == 0</code> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">// 检查索引的合法性，允许index==size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-内部迭代器类-ListItr"><a href="#5-内部迭代器类-ListItr" class="headerlink" title="5. 内部迭代器类 ListItr"></a>5. 内部迭代器类 ListItr</h4><p>内部类 ListItr 的字段及构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned; <span class="comment">// 最近被访问的节点指针</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next; <span class="comment">// 下一待访问节点的指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex; <span class="comment">// 下一待访问节点的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// 当index==size时，next变量置为null</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看内部类 ListItr 的部分方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size; <span class="comment">// 判断是否有后继节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    lastReturned = next; <span class="comment">// 更新最近访问过的节点</span></span><br><span class="line">    next = next.next; <span class="comment">// 更新下一待访问节点的指针</span></span><br><span class="line">    nextIndex++; <span class="comment">// 更新下一待访问节点的索引值</span></span><br><span class="line">    <span class="keyword">return</span> lastReturned.item; <span class="comment">// 返回最近被访问的节点元素值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>; <span class="comment">// 判断是否有前驱节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">	<span class="comment">// nextIndex==size时，next==null，此时已到达链表尾部，已无后继节点</span></span><br><span class="line">    lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-三种遍历方式的比较"><a href="#6-三种遍历方式的比较" class="headerlink" title="6. 三种遍历方式的比较"></a>6. 三种遍历方式的比较</h4><p>常见的 for 循环、forEach 循环和迭代器分别遍历 LinkedList 集合，性能表现如何？</p>
<ul>
<li>forEach 循环和迭代器遍历速度快；</li>
<li>for 循环遍历速度慢。</li>
</ul>
<p>forEach 循环底层实现正是迭代器。比较迭代器和 for 循环。迭代器在遍历过程中，会<strong>保存下一个待访问节点的内存地址</strong>。for 循环在遍历过程中，每一次获取元素都要调用 node(int index) 方法查找。虽然 LinkedList 类提供的 node(int index) 方法进行了优化，最坏只需要查找一半的集合，但其性能显然不比迭代器。</p>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><ul>
<li>LinkedList 底层结构是双向链表，初始容量为0。</li>
<li>在查找指定索引 <code>index</code> 处的节点时，需要先明确指定该索引属于链表前半段还是后半段，据此决定是从链表头节点还是尾节点开始遍历寻找，以缩短查找时间。</li>
<li>由于 LinkedList 可以存储 null，所以待删除对象可以为 null。</li>
<li>LinkedList 类继承的 iterator() 和 listIterator() 方法，本质上均是调用 LinkedList 类的 listIterator(int index) 方法，其中 <code>index == 0</code>，得到的均是 <code>ListItr</code> 对象。</li>
<li>迭代器的 remove 方法的本质是<strong>调用集合的 remove 方法并更新迭代器的 expectedModCount 的值。</strong> </li>
<li>继承抽象类 AbstractList 中的 modCount 字段，记录集合发生结构化修改（<strong>删除、添加元素，更新已存在的元素不是结构化修改</strong>）的次数。迭代器中维护 expectedModCount 字段，在初始化迭代器时，将集合的 modCount 赋予迭代器的 expectedModCount。在执行迭代器的方法时，首先判断二者是否相等，否的话抛出 ConcurrentModificationException 异常。</li>
</ul>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程题总结</title>
    <url>/2020/05/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>经典的多线程打印及力扣官网多线程题库题目总结。</p>
<a id="more"></a>

<h4 id="1-花式打印-“a1b2c3d4e5”"><a href="#1-花式打印-“a1b2c3d4e5”" class="headerlink" title="1. 花式打印 “a1b2c3d4e5”"></a>1. 花式打印 “a1b2c3d4e5”</h4><p>RT</p>
<h5 id="1-1-Synchronized-实现"><a href="#1-1-Synchronized-实现" class="headerlink" title="1.1 Synchronized 实现"></a>1.1 Synchronized 实现</h5><p>当前线程打印字符后，调用 notify 方法唤醒另一等待的线程，并调用 wait 方法使自己进入等待唤醒状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志位，用于首次打印时，确保打印字母</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// 锁对象</span></span><br><span class="line">        <span class="keyword">char</span>[] numArray = <span class="string">"12345"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : charArray) &#123;</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.notify(); <span class="comment">// 唤醒另一等待线程</span></span><br><span class="line">                        lock.wait(); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify(); <span class="comment">// 确保最后的操作线程被唤醒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"charThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 判断标志是否为true。若为true，说明字符已先打印；否则，线程进入等待状态</span></span><br><span class="line">                <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : numArray) &#123;</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.notify(); <span class="comment">// 唤醒另一等待线程</span></span><br><span class="line">                        lock.wait(); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"numThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-Lock-锁和条件对象-Condition-实现"><a href="#1-2-Lock-锁和条件对象-Condition-实现" class="headerlink" title="1.2 Lock 锁和条件对象 Condition 实现"></a>1.2 Lock 锁和条件对象 Condition 实现</h5><p>当前线程打印字符后，调用 signal方法唤醒另一等待的线程，并调用 await 方法使自己进入等待唤醒状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志位，用于首次打印时，确保打印字母</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] numArray = <span class="string">"12345"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 获取锁</span></span><br><span class="line">        Condition numCondition = lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line">        Condition charCondition = lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : charArray) &#123;</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>; <span class="comment">// 重置标志</span></span><br><span class="line">                    numCondition.signal(); <span class="comment">// 唤醒另一线程</span></span><br><span class="line">                    charCondition.await(); <span class="comment">// 当前线程进入等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                numCondition.signal(); <span class="comment">// 确保最后的操作线程被唤醒</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"charThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 判断标志是否为true。若为true，说明字符已先打印；否则，线程进入等待状态</span></span><br><span class="line">                <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                    numCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : numArray) &#123;</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    charCondition.signal(); <span class="comment">// 唤醒另一线程</span></span><br><span class="line">                    numCondition.await(); <span class="comment">// 当前线程进入等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                charCondition.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"numThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-AtomicInteger-类实现"><a href="#1-3-AtomicInteger-类实现" class="headerlink" title="1.3 AtomicInteger 类实现"></a>1.3 AtomicInteger 类实现</h5><p>借助 Java 提供的原子类 AtomicInteger。设置打印字符的标志位，通过 AtomicInteger 提供的原子操作获取、设置标志位的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标志位：1-打印字母，0-打印数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger flag = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] numArray = <span class="string">"12345"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : charArray) &#123;</span><br><span class="line">                <span class="comment">// 标志位不为1，不打印，自旋等待</span></span><br><span class="line">                <span class="keyword">while</span>(flag.get()!=<span class="number">1</span>) &#123;&#125;</span><br><span class="line">                System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 将标志位设为0，即待运行线程变为打印数字的线程</span></span><br><span class="line">                flag.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"charThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : numArray) &#123;</span><br><span class="line">                <span class="comment">// 标志位不为0，不打印，自旋等待</span></span><br><span class="line">                <span class="keyword">while</span>(flag.get()!=<span class="number">0</span>) &#123;&#125;</span><br><span class="line">                System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 将标志位设为1，即待运行线程变为打印字母的线程</span></span><br><span class="line">                flag.set(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"numThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-LockSupport-类实现"><a href="#1-4-LockSupport-类实现" class="headerlink" title="1.4 LockSupport 类实现"></a>1.4 LockSupport 类实现</h5><p>使用 LockSupport 类提供的 part 和 unpark 方法交替阻塞线程和解除阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread numThread = <span class="keyword">null</span>; <span class="comment">// 打印数字的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread charThread = <span class="keyword">null</span>; <span class="comment">// 打印字符的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] numArray = <span class="string">"12345"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        charThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : charArray) &#123;</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    <span class="comment">// 解除打印数字线程的阻塞状态</span></span><br><span class="line">                    LockSupport.unpark(numThread);</span><br><span class="line">                    <span class="comment">// 打印字符线程阻塞</span></span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        numThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : numArray) &#123;</span><br><span class="line">                    <span class="comment">// 打印数字线程阻塞，确保字符先打印</span></span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                    System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">                    <span class="comment">// 解除打印字符线程的阻塞状态</span></span><br><span class="line">                    LockSupport.unpark(charThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        charThread.start();</span><br><span class="line">        numThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-自旋锁实现"><a href="#1-5-自旋锁实现" class="headerlink" title="1.5 自旋锁实现"></a>1.5 自旋锁实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spin</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 枚举，限定待运行线程</span></span><br><span class="line">	<span class="keyword">enum</span> ReadyToRun &#123;charThread, numThread&#125;;</span><br><span class="line">	<span class="comment">// 使用volatile修饰待运行线程变量，确保当前线程修改此值，对另一线程可见</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">volatile</span> ReadyToRun thread = ReadyToRun.charThread;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] numArray = <span class="string">"12345"</span>.toCharArray();</span><br><span class="line">		<span class="keyword">char</span>[] charArray = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread( ()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">char</span> ch : charArray) &#123;</span><br><span class="line">				<span class="comment">// 当前线程不是打印字符的线程，自旋，占用cpu资源但无任何操作</span></span><br><span class="line">				<span class="keyword">while</span>(thread!=ReadyToRun.charThread) &#123;&#125;</span><br><span class="line">				System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">				<span class="comment">// 将打印数字的线程设置为待运行线程</span></span><br><span class="line">				thread = ReadyToRun.numThread;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"charThread"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread( ()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">char</span> ch : numArray) &#123;</span><br><span class="line">				<span class="comment">// 当前线程不是打印数字的线程，自旋，占用cpu资源但无任何操作</span></span><br><span class="line">				<span class="keyword">while</span>(thread!=ReadyToRun.numThread) &#123;&#125;</span><br><span class="line">				System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">				<span class="comment">// 将打印字符的线程设置为待运行线程</span></span><br><span class="line">				thread = ReadyToRun.charThread;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"numThread"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-交替打印-a、b、c-各十次"><a href="#2-交替打印-a、b、c-各十次" class="headerlink" title="2. 交替打印 a、b、c 各十次"></a>2. 交替打印 a、b、c 各十次</h4><p>在第1节介绍了几种轮流打印字母和数字的方式，现尝试交替打印字母 a、b、c，且指定打印次数。</p>
<h5 id="2-1-AtomicInteger-类实现"><a href="#2-1-AtomicInteger-类实现" class="headerlink" title="2.1 AtomicInteger 类实现"></a>2.1 AtomicInteger 类实现</h5><p>与 1.3 不同的是，此次需要交替打印三种字符。类似地，标志位有三种状态值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印开关，1-打印A，2-打印B，3-打印C</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger flag = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                <span class="comment">// 自旋等待</span></span><br><span class="line">                <span class="keyword">while</span>(flag.get()!=<span class="number">1</span>) &#123;&#125;</span><br><span class="line">                System.out.print(<span class="string">"A "</span>);</span><br><span class="line">                <span class="comment">// 开启打印下一字符的开关</span></span><br><span class="line">                flag.set(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"aThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag.get()!=<span class="number">2</span>) &#123;&#125;</span><br><span class="line">                System.out.print(<span class="string">"B "</span>);</span><br><span class="line">                flag.set(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"bThread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag.get()!=<span class="number">3</span>) &#123;&#125;</span><br><span class="line">                System.out.print(<span class="string">"C "</span>);</span><br><span class="line">                flag.set(<span class="number">1</span>); <span class="comment">// 打印C之后，打印A，标志位重设为1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"cThread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-Lock-锁和条件对象-Condition-实现"><a href="#2-2-Lock-锁和条件对象-Condition-实现" class="headerlink" title="2.2 Lock 锁和条件对象 Condition 实现"></a>2.2 Lock 锁和条件对象 Condition 实现</h5><p>类似地，设置三个条件对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> bFlag = <span class="keyword">false</span>; <span class="comment">// 开始打印B的开关</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> cFlag = <span class="keyword">false</span>; <span class="comment">// 开始打印C的开关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition printA = lock.newCondition();</span><br><span class="line">        Condition printB = lock.newCondition();</span><br><span class="line">        Condition printC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"A "</span>);</span><br><span class="line">                    bFlag = <span class="keyword">true</span>;</span><br><span class="line">                    printB.signal(); <span class="comment">// 指定唤醒打印B的线程</span></span><br><span class="line">                    printA.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printB.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"printA_Thread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 检查是否打印B的开关</span></span><br><span class="line">                <span class="keyword">while</span>(!bFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        printB.await();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"B "</span>);</span><br><span class="line">                    cFlag = <span class="keyword">true</span>;</span><br><span class="line">                    printC.signal(); <span class="comment">// 指定唤醒打印C的线程</span></span><br><span class="line">                    printB.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printC.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"printB_Thread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 检查是否打印C的开关</span></span><br><span class="line">                <span class="keyword">while</span>(!cFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        printC.await();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"C "</span>);</span><br><span class="line">                    printA.signal(); <span class="comment">// 指定唤醒打印A的线程</span></span><br><span class="line">                    printC.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printA.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"printC_Thread"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码四：SynchronizedList源码阅读笔记</title>
    <url>/2020/05/13/SynchronizedList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>JDK 除提供 Vector、ConcurrentHashMap 等同步容器外，通过工具类 <strong>Collections</strong> 的静态工具方法可获取一些同步的集合，如 synchronizedList、synchronizedMap、synchronizedSet 等。</p>
<p>本文主要内容有：</p>
<ul>
<li>分析 Collections 类的内部类 SynchronizedList 的源码。</li>
<li>对同步的集合对象的复合操作不一定是线程安全的。</li>
<li>比较 Vector 类与 SynchronizedList 类。</li>
</ul>
<a id="more"></a>

<h4 id="1-SynchronizedList-源码"><a href="#1-SynchronizedList-源码" class="headerlink" title="1. SynchronizedList 源码"></a>1. SynchronizedList 源码</h4><blockquote>
<p>本小节涉及的 SynchronizedCollection、SynchronizedList、SynchronizedRandomAccessList，均为 Collections 类的内部类。</p>
</blockquote>
<p>工具类 Collections 中常见的获取同步的集合的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure>

<p>以 synchronizedList 为例，通过调用静态方法可获取同步的 List 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h5 id="1-1-初始化过程"><a href="#1-1-初始化过程" class="headerlink" title="1.1 初始化过程"></a>1.1 初始化过程</h5><p><em>静态方法 synchronizedList 的源码如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ? <span class="comment">// 判读list是否支持随机访问（LinkedList不支持）</span></span><br><span class="line">            <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> SynchronizedList&lt;&gt;(list)); <span class="comment">// 调用SynchronizedList类的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>继续看静态内部类 SynchronizedList，其继承 SynchronizedCollection 类、实现 List 接口</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">								 <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7754090372962971524L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line">	</span><br><span class="line">    SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>继续看静态内部类 SynchronizedCollection，其实现了 Collection 和 Serializable 接口</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3053995032091335093L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;</span><br><span class="line">    <span class="keyword">final</span> Object mutex; <span class="comment">// 锁对象</span></span><br><span class="line"></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = Objects.requireNonNull(c); <span class="comment">// 调用requireNonull方法，判断集合c是否为null</span></span><br><span class="line">        mutex = <span class="keyword">this</span>; <span class="comment">// 指定锁对象为当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，通过工具类 Collections 的静态方法 synchronizedList 获取到了 SynchronizedList 对象，即同步的 List 对象。</p>
<h5 id="1-2-同步方法"><a href="#1-2-同步方法" class="headerlink" title="1.2 同步方法"></a>1.2 同步方法</h5><p>以静态内部类 SynchronizedList 为例，通过 synchronized 为方法的调用者加锁，实现同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add(E e)方法继承自SynchronizedCollection类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123; <span class="comment">// 锁对象为方法的调用者</span></span><br><span class="line">        <span class="keyword">return</span> c.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-获取迭代器的方法"><a href="#1-3-获取迭代器的方法" class="headerlink" title="1.3 获取迭代器的方法"></a>1.3 获取迭代器的方法</h5><p>特别地，静态内部类 SynchronizedCollection、SynchronizedList、SynchronizedMap 及 SynchronizedSet 中的 <strong>获取迭代器的方法是未同步的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.listIterator(); <span class="comment">// 必须手动加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>使用时需要手动为其加锁</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">    Iterator itr = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">        System.out.println(itr.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h4><p>在 Vector 类和 Collections 的内部类 SynchronizedCollection、SynchronizedList 中，均是通过<strong>关键字 synchronized</strong> 对类提供的方法（获取迭代器除外）进行加锁，以实现同步。</p>
<p>与 Vector 类相似，SynchronizedCollection、SynchronizedList 等对外提供的、synchronized 修饰的方法是线程安全的，<strong>但多线程复合操作容器不一定是线程安全的！</strong>具体分析见 <a href="https://merlinhu0112.github.io/2020/05/06/Vector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Vector 源码笔记</a>。</p>
<h4 id="3-SynchronizedList-与-Vector"><a href="#3-SynchronizedList-与-Vector" class="headerlink" title="3. SynchronizedList 与 Vector"></a>3. SynchronizedList 与 Vector</h4><p>Vector 是 java.util 包中的一个类， SynchronizedList 是 java.util.Collections 中的一个静态内部类。</p>
<ul>
<li>Vector 内部使用同步方法，SynchronizedList 内部使用同步代码块。</li>
<li>SynchronizedList 具有很好的扩展性，可以将底层结构是链表的 LinkedList 类转换成线程安全的类，而Vector 的底层结构固定是数组。</li>
<li>Vector 类获取迭代器的方法是同步的，而 SynchronizedList 类获取迭代器的方法未实现同步，在使用时需要自行加锁。</li>
<li>SynchronizedList 可以使用默认的锁对象（集合本身），也可以在构造方法中指定锁对象。Vector 类的锁对象只能是 Vector 实例。</li>
</ul>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>对于工具类 Collections 中获取同步的集合对象的静态方法，其本质是在内部维护一个锁对象（mutex），在方法（除获取迭代器的方法）中使用同步代码块以实现同步。锁对象为方法的调用者。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://blog.csdn.net/weixin_38575051/article/details/94000044" target="_blank" rel="noopener">Java 中 Collections.synchronizedList(List list) 原理分析</a></p>
<p>[2] <a href="https://www.cnblogs.com/hujingnb/p/10181577.html" target="_blank" rel="noopener">Java集合之Vector源码分析</a></p>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>SynchronizedList</tag>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码三：Vector源码阅读笔记</title>
    <url>/2020/05/06/Vector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的 Vector 类的源码阅读笔记。</p>
<p>除去 Vector 类是同步、ArrayList 类是非同步，以及二者在扩容机制的微小差异，Vector 类和 ArrayList 是非常相似的。</p>
<a id="more"></a>

<h4 id="1-Vector的概述"><a href="#1-Vector的概述" class="headerlink" title="1. Vector的概述"></a>1. Vector的概述</h4><p>Vector 类继承自抽象类 AbstractList，实现了 List、Cloneable、Serializable 和 RandomAccess（标识支持随机访问）接口。</p>
<ul>
<li>底层结构是 Object 类型的数组，可以存放任意元素；</li>
<li>支持随机访问，查找操作的时间复杂度为 O(1)。</li>
<li>线程安全，这是 Vector 与 ArrayList 的区别之一。</li>
<li>迭代器是 fail-fast 的。构造迭代器后，除使用迭代器的 add 或 remove 方法，任何对集合的结构修改均会抛出 ConcurrentModificationException。</li>
</ul>
<h4 id="2-字段"><a href="#2-字段" class="headerlink" title="2. 字段"></a>2. 字段</h4><h5 id="2-1-静态常量"><a href="#2-1-静态常量" class="headerlink" title="2.1 静态常量"></a>2.1 静态常量</h5><p>（1）最大容量</p>
<blockquote>
<p>在部分虚拟机上保留 8 个字节。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-实例变量"><a href="#2-2-实例变量" class="headerlink" title="2.2 实例变量"></a>2.2 实例变量</h5><p>（1）数组缓冲区：存放 Vector 数组元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>（2）容量增量：每次扩容时数组增加的容量。<strong>当 capacityIncrement 小于或等于 0 时，数组双倍扩容，而不是增加 0</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>

<p>（3）数组大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br></pre></td></tr></table></figure>

<h4 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h4><p>Vector类的构造方法有以下四种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector() <span class="comment">// 构造一个Vector实例，初始容量为10，容量增量为0，即扩容时双倍扩容。</span></span><br><span class="line">Vector(<span class="keyword">int</span> initialCapacity) <span class="comment">// 构造一个Vector实例，指定初始容量，容量增量为0，即扩容时双倍扩容。</span></span><br><span class="line">Vector(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement) <span class="comment">// 构造一个Vector实例，指定初始容量和容量增量。</span></span><br><span class="line">Vector(Collection&lt;? extends E&gt; c) <span class="comment">// 构造一个包含集合c所有元素的Vector实例。</span></span><br></pre></td></tr></table></figure>

<p><strong><em>Vector 类空参构造函数执行过程</em></strong></p>
<blockquote>
<p>Vector 默认的初始容量为 10，容量增量为 0，即执行双倍扩容策略。</p>
</blockquote>
<p>（1）首先执行空参构造方法 Vector() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>); <span class="comment">// 默认初始容量为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）调用构造方法 Vector(int initialCapacity)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>); <span class="comment">// 初始容量为10，容量增量为0。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）调用构造方法 Vector(int initialCapacity, int capacityIncrement)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 调用父类的空参构造方法，将父类的modCount字段初始为0。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> <span class="comment">// 在尾部添加元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">// 在指定位置插入元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 删除指定位置元素，返回被删除的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> <span class="comment">// 删除首次出现的元素o</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">// 使用新元素e覆盖指定位置的元素，并返回旧元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回指定位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> <span class="comment">// 查找指定的元素是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span> <span class="comment">// 转换为数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> <span class="comment">// 返回枚举对象</span></span></span><br></pre></td></tr></table></figure>

<h5 id="（1）add-E-e-方法"><a href="#（1）add-E-e-方法" class="headerlink" title="（1）add(E e) 方法"></a>（1）add(E e) 方法</h5><blockquote>
<p>同步的 add 方法内部需要调用一系列辅助<strong>非同步方法</strong>，好处在于避免大量的额外同步开销。</p>
</blockquote>
<p>在尾部添加元素 <code>e</code> 。Vector 类的 <code>add(E e)</code> 方法与 <code>addElement(E obj)</code> 功能相同，但前者返回值类型为 <code>boolean</code> 、后者无返回值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用非同步的 ensureCapacityHelper 方法，确保内部容量能满足添加新元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector类的同步方法调用此方法，在避免额外的同步开销的前提下，检查底层数组容量是否足够。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity); <span class="comment">// 容量不足，扩容。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>容量不足，调用 grow 方法扩容</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 当容量增量不大于0时，双倍扩容；否则按容量增量增加。</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity; <span class="comment">// 扩容后的容量仍不足，直接更新为所需的最小容量。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); <span class="comment">// 若新容量超过最大值</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>若新容量超过最大值，调用 hugeCapacity 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若允许的最小容量发生溢出、变为负数，抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 若允许的最小容量大于数组容量限制，返回int整数最大值，即Integer.MAX_VALUE；</span></span><br><span class="line">    <span class="comment">// 否则返回Integer.MAX_VALUE - 8。</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（2）add-int-index-E-element-方法"><a href="#（2）add-int-index-E-element-方法" class="headerlink" title="（2）add(int index, E element) 方法"></a>（2）add(int index, E element) 方法</h5><p>此方法是非同步，但它内部调用同步的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用同步方法 insertElementAt，插入元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>); <span class="comment">// 检查容量</span></span><br><span class="line">    <span class="comment">// 移动元素，空出index索引处。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++; <span class="comment">// 数组大小加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（3）remove-int-index-方法"><a href="#（3）remove-int-index-方法" class="headerlink" title="（3）remove(int index) 方法"></a>（3）remove(int index) 方法</h5><blockquote>
<p>与 ArrayList 类相似，remove 方法仅检查索引是否越过右端边界，若成立则抛出异常。<strong>此方法不检查索引是否为负数，如果索引为负数则在访问数组时抛出 ArrayIndexOutOfBoundsException。</strong></p>
<p>不同的是，ArrayList 中抛出两个不同的异常（IndexOutOfBoundsException + ArrayIndexOutOfBoundsException），而 Vector 中均抛出 ArrayIndexOutOfBoundsException。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) <span class="comment">// 仅判断数组右端是否越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index); <span class="comment">// elementData方法返回指定元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">// 返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（4）remove-Object-o-方法"><a href="#（4）remove-Object-o-方法" class="headerlink" title="（4）remove(Object o) 方法"></a>（4）remove(Object o) 方法</h5><p>注意，当指定元素 <code>o</code> 为 <code>null</code> 且 Vector 集合中存在 <code>null</code> 元素，返回 <code>true</code> 。</p>
<blockquote>
<p>在 Vector 类的 remove 方法中，removeElement 和 removeElementAt 方法分别执行一次 <code>modCount++</code>，即 remove 方法中 <code>modCount++</code> 操作被执行两次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>方法内部调用同步的 removeElement 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj); <span class="comment">// 经多层调用，底层调用同步的indexOf方法，获取指定元素索引。</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123; <span class="comment">// i不为-1，即指定元素存在。</span></span><br><span class="line">        removeElementAt(i); <span class="comment">// 删除元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用同步的 indexOf 方法，查找指定元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123; <span class="comment">// 对象o为null时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对象o不为null时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 指定对象o不存在，返回-1。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>被 remove 方法调用，删除指定索引位置的元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断索引的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 移动待删除元素后的全部元素</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（5）set-int-index-E-element-方法"><a href="#（5）set-int-index-E-element-方法" class="headerlink" title="（5）set(int index, E element) 方法"></a>（5）set(int index, E element) 方法</h5><blockquote>
<p>setElementAt(E obj, int index) 方法仅更新索引 index 处的元素、不返回旧元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) <span class="comment">// 检查索引合法性</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">// 获取旧元素</span></span><br><span class="line">    elementData[index] = element; <span class="comment">// 新元素覆盖</span></span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（6）get-int-index-方法"><a href="#（6）get-int-index-方法" class="headerlink" title="（6）get(int index) 方法"></a>（6）get(int index) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index); <span class="comment">// 获取并返回索引index处的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（7）contains-Object-o-方法"><a href="#（7）contains-Object-o-方法" class="headerlink" title="（7）contains(Object o) 方法"></a>（7）contains(Object o) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>; <span class="comment">// 调用同步的indexOf方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（8）toArray-方法"><a href="#（8）toArray-方法" class="headerlink" title="（8）toArray() 方法"></a>（8）toArray() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用工具类 Arrays 的静态方法 copyOf</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝原数组，副本长度指定为newLength，以null截断或填充副本。</span></span><br><span class="line"><span class="comment">// 当newLength大于原数组的长度时，以null填充副本中多余的部分。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>继续调用工具类 Arrays 的静态方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, </span><br><span class="line">                               Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取副本数组的类型</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// 调用native方法完成复制，其中待复制长度为原数组长度和指定值中的最小值。</span></span><br><span class="line">    <span class="comment">// original.length == newLength，完全相同；</span></span><br><span class="line">    <span class="comment">// original.length &gt; newLength，发生截断；</span></span><br><span class="line">    <span class="comment">// original.length &lt; newLength，以null填充副本中多余的位置。</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（9）elements-方法"><a href="#（9）elements-方法" class="headerlink" title="（9）elements() 方法"></a>（9）elements() 方法</h5><blockquote>
<p>此方法返回枚举类型对象。ArrayList 类不提供此方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>Vector 类与 ArrayList 类的比较如下表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Vector</th>
<th align="center">ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否线程安全</td>
<td align="center">线程不一定安全（参考第6节）</td>
<td align="center">线程不安全</td>
</tr>
<tr>
<td align="center">扩容机制</td>
<td align="center">按增量增加 或 2倍扩容</td>
<td align="center">1.5倍扩容</td>
</tr>
<tr>
<td align="center">空参构造方法</td>
<td align="center">默认初始容量为10、2倍扩容，构造时分配内存</td>
<td align="center">默认初始容量为10，构造空数组，首次添加元素扩容至默认容量、完成内存分配</td>
</tr>
<tr>
<td align="center">迭代器</td>
<td align="center">Iterator + ListIterator + Enumeration</td>
<td align="center">Iterator + ListIterator</td>
</tr>
</tbody></table>
<blockquote>
<p>注：详细扩容过程参考 ArrayList 源码解析。</p>
</blockquote>
<h4 id="6-问题"><a href="#6-问题" class="headerlink" title="6. 问题"></a>6. 问题</h4><p>1、对 Vector 类的操作一定是线程安全的吗？</p>
<p> 答：Vector 类通过 synchronized 对外提供线程安全的操作方法，但对 Vector 容器的<strong>复合操作</strong>不一定是线程安全的！</p>
<p><em>示例</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorThreadUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread aThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vector.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    vector.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程aThread的remove方法被执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread bThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vector.isEmpty())&#123;</span><br><span class="line">                    vector.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程bThread的remove方法被执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        aThread.start();</span><br><span class="line">        bThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程bThread的remove方法被执行</span><br><span class="line">Exception in thread <span class="string">"Thread-0"</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">0</span></span><br><span class="line">	at java.util.Vector.remove(Vector.java:<span class="number">834</span>)</span><br><span class="line">	at cn.merlin.test.concurrency.VectorThreadUnsafe$<span class="number">1</span>.run(VectorThreadUnsafe.java:<span class="number">20</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>根据报错信息可知，线程 <code>aThread</code> 在执行 remove 方法时出现异常！</p>
<p><strong>具体细节：</strong>线程 <code>aThread</code> 执行判空操作后让出执行权，线程 <code>bThread</code> 执行判空操作且删除了 <code>vector</code> 实例中的唯一一个元素。随后线程 <code>aThread</code> 恢复执行，试图删除已经被线程 <code>bThread</code> 删除的元素，故抛出异常！</p>
<p><strong><em>额外加锁以保证复合操作的安全</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorThreadSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread aThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vector.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        vector.remove(<span class="number">0</span>);</span><br><span class="line">                        System.out.println(<span class="string">"线程aThread的remove方法被执行"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread bThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vector.isEmpty())&#123;</span><br><span class="line">                    vector.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程bThread的remove方法被执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        aThread.start();</span><br><span class="line">        bThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> Vector 类是同步的，仅意味着其对外提供的简单操作是线程安全的。但这些操作复合后，多个线程交叉访问容器可能导致并发异常！</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://blog.csdn.net/u011676300/article/details/81102259" target="_blank" rel="noopener">Vector并非是绝对的线程安全类</a></p>
<p>[2] <a href="https://blog.csdn.net/xdonx/article/details/9465489" target="_blank" rel="noopener">Vector 是线程安全的？</a></p>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码二：ArrayList源码阅读笔记</title>
    <url>/2020/05/06/ArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的 ArrayList 类的源码阅读笔记，重点如下：</p>
<ul>
<li>ArrayList 的底层结构及扩容机制。</li>
<li>如何安全地对集合的结构进行修改。</li>
<li>迭代器的 remove 方法的本质。</li>
<li>Iterator 和 ListIterator 两种迭代器的区别。</li>
</ul>
<a id="more"></a>

<h4 id="1-ArrayList的概述"><a href="#1-ArrayList的概述" class="headerlink" title="1. ArrayList的概述"></a>1. ArrayList的概述</h4><p>ArrayList 类继承自抽象类 AbstractList，实现了 List、Cloneable、Serializable 和 RandomAccess（标识支持随机访问）接口。</p>
<ul>
<li>底层结构是 Object 类型的数组，可以存放任意元素；</li>
<li>支持随机访问，查找操作的时间复杂度为 O(1)。</li>
<li>未实现同步，可通过 Collections 类的 synchronizedList 方法获得线程安全的类。</li>
<li>迭代器是 fail-fast 的。构造迭代器后，除使用迭代器的 add 或 remove 方法，任何对集合的结构修改均会抛出 ConcurrentModificationException。</li>
</ul>
<h4 id="2-字段"><a href="#2-字段" class="headerlink" title="2. 字段"></a>2. 字段</h4><h5 id="2-1-静态常量"><a href="#2-1-静态常量" class="headerlink" title="2.1 静态常量"></a>2.1 静态常量</h5><p>（1）默认初始容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>（2）共享空数组实例之一：用于空的 ArrayList 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）共享空数组实例之二：用于默认大小的空的 ArrayList 实例（看空参构造函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）数组最大容量</p>
<blockquote>
<p>在部分虚拟机上保留 8 个字节，但 <strong>ArrayList 数组的最大容量可取到 Integer.MAX_VALUE</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-实例变量"><a href="#2-2-实例变量" class="headerlink" title="2.2 实例变量"></a>2.2 实例变量</h5><p>（1）数组缓冲区：存放 ArrayList 数组元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>对于 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 实例，添加第一个元素时，数组自动扩充为 <code>DEFAULT_CAPACITY</code> 大小。</p>
<h4 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h4><p>ArrayList类的构造方法有以下三种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList() <span class="comment">// 构造一个初始容量为10的空列表。</span></span><br><span class="line">ArrayList(<span class="keyword">int</span> initialCapacity) <span class="comment">// 构造一个指定初始容量的空列表。</span></span><br><span class="line">ArrayList(Collection&lt;? extends E&gt; c) <span class="comment">// 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。</span></span><br></pre></td></tr></table></figure>

<p>（1）ArrayList()</p>
<blockquote>
<p><strong>首次添加元素时，完成内存分配</strong>。由空数组扩容至默认大小，即 10。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）ArrayList(int initialCapacity)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 新建Object数组，内存分配。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">// 空数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）ArrayList(Collection&lt;? extends E&gt; c)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 判断传入的集合c是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断引用的数组类型。若不是Object类型数组，将其转换。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传入的集合c为空</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> <span class="comment">// 在数组尾部添加元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">// 在指定位置插入元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">// 添加指定集合c的全部元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> <span class="comment">// 从List指定位置开始，插入集合c全部元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 移除指定位置元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> <span class="comment">// 删除首次出现的元素o</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">// 使用新元素e覆盖指定位置的元素，并返回旧元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回指定位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> <span class="comment">// 查找指定的元素是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span> <span class="comment">// 将列表转换为数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> <span class="comment">// 返回迭代器对象，只能向后遍历</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> <span class="comment">// 返回迭代器对象，可双向访问</span></span></span><br></pre></td></tr></table></figure>

<h5 id="（1）add-E-e-方法"><a href="#（1）add-E-e-方法" class="headerlink" title="（1）add(E e) 方法"></a>（1）add(E e) 方法</h5><p>在数组尾部添加元素 <code>e</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 确保内部容量</span></span><br><span class="line">    elementData[size++] = e; <span class="comment">// 存入元素值e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 ensureCapacityInternal 方法，确保内部容量能满足添加新元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 calculateCapacity 方法，计算本次操作所需要的最小容量</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断数组是否是用默认构造函数初始化的</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 若实例由空参函数构造，在首次添加元素时，数组扩容至默认大小，即10。</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">// Math.max(10, 1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 ensureExplicitCapacity 方法，检查旧数组是否需要扩容</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity); <span class="comment">// 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>旧数组容量不足，调用 grow 方法扩容</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// （近似）1.5倍扩容机制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity; <span class="comment">// 1.5倍扩容后的容量仍不足，直接更新为所需的最小容量。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); <span class="comment">// 若新数组容量超过最大值</span></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 拷贝数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>若新数组容量超过最大值，调用 hugeCapacity 方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若允许的最小容量发生溢出、变为负数，抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 若允许的最小容量大于数组容量限制，返回int整数最大值，即Integer.MAX_VALUE；</span></span><br><span class="line">    <span class="comment">// 否则返回Integer.MAX_VALUE - 8。</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（2）add-int-index-E-element-方法"><a href="#（2）add-int-index-E-element-方法" class="headerlink" title="（2）add(int index, E element) 方法"></a>（2）add(int index, E element) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">// 检查指定索引是否合法</span></span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// 检查数组容量是否足够</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index); <span class="comment">// 从旧数组的index索引至结束，拷贝至新数组。</span></span><br><span class="line">    elementData[index] = element; <span class="comment">// 插入指定元素</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>向指定位置插入元素时，首先调用 rangeCheckForAdd 方法，检查指定索引是否合法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) <span class="comment">// 判断索引是否越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（3）addAll-Collection-lt-extends-E-gt-c-方法"><a href="#（3）addAll-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="（3）addAll(Collection&lt;? extends E&gt; c) 方法"></a>（3）addAll(Collection&lt;? extends E&gt; c) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// 检查数组容量</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（4）addAll-int-index-Collection-lt-extends-E-gt-c-方法"><a href="#（4）addAll-int-index-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="（4）addAll(int index, Collection&lt;? extends E&gt; c) 方法"></a>（4）addAll(int index, Collection&lt;? extends E&gt; c) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">// 首先判断index是否合法。index是List的索引，而不是集合c。</span></span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved); <span class="comment">// 移动原数组中的部分元素，空出位置以插入集合c中的元素。</span></span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew); <span class="comment">// 插入集合c中的元素</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（5）remove-int-index-方法"><a href="#（5）remove-int-index-方法" class="headerlink" title="（5）remove(int index) 方法"></a>（5）remove(int index) 方法</h5><blockquote>
<p>rangeCheck 方法仅检查索引是否越过右端边界，若成立则抛出 IndexOutOfBoundsException。<strong>此方法不检查索引是否为负数，如果索引为负数则在访问数组时抛出 ArrayIndexOutOfBoundsException。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查索引合法性</span></span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">// 删除操作也要更新modCount</span></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">// 获取指定位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved); <span class="comment">// 移动数组，覆盖被删除元素的位置</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>检查索引是否越过右端边界，即索引是否大于最大索引值</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（6）remove-Object-o-方法"><a href="#（6）remove-Object-o-方法" class="headerlink" title="（6）remove(Object o) 方法"></a>（6）remove(Object o) 方法</h5><p>注意，当指定元素 <code>o</code> 为 <code>null</code> 且 ArrayList 集合中存在 <code>null</code> 元素，返回 <code>true</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>方法内部调用 fastRemove 方法：</em></p>
<ul>
<li>不检查边界</li>
<li>不返回被删除元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（7）set-int-index-E-element-方法"><a href="#（7）set-int-index-E-element-方法" class="headerlink" title="（7）set(int index, E element) 方法"></a>（7）set(int index, E element) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查边界</span></span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">// 获取旧元素</span></span><br><span class="line">    elementData[index] = element; <span class="comment">// 新元素覆盖</span></span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（8）get-int-index-方法"><a href="#（8）get-int-index-方法" class="headerlink" title="（8）get(int index) 方法"></a>（8）get(int index) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index); <span class="comment">// 返回指定位置元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（9）contains-Object-o-方法"><a href="#（9）contains-Object-o-方法" class="headerlink" title="（9）contains(Object o) 方法"></a>（9）contains(Object o) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 indexOf 方法，返回指定元素的首次出现的索引</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（10）toArray-方法"><a href="#（10）toArray-方法" class="headerlink" title="（10）toArray() 方法"></a>（10）toArray() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size); <span class="comment">// 拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用工具类 Arrays 的静态方法 copyOf</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝原数组，副本长度指定为newLength，以null截断或填充副本。</span></span><br><span class="line"><span class="comment">// 当newLength大于原数组的长度时，以null填充副本中多余的部分。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>继续调用工具类 Arrays 的静态方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, </span><br><span class="line">                               Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取副本数组的类型</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// 调用native方法完成复制，其中待复制长度为原数组长度和指定值中的最小值。</span></span><br><span class="line">    <span class="comment">// original.length == newLength，完全相同；</span></span><br><span class="line">    <span class="comment">// original.length &gt; newLength，发生截断；</span></span><br><span class="line">    <span class="comment">// original.length &lt; newLength，以null填充副本中多余的位置。</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（11）iterator-方法"><a href="#（11）iterator-方法" class="headerlink" title="（11）iterator() 方法"></a>（11）iterator() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr(); <span class="comment">// Itr是ArrayList的内部类，对它的介绍见第5小节。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（12）listIterator-方法"><a href="#（12）listIterator-方法" class="headerlink" title="（12）listIterator() 方法"></a>（12）listIterator() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>); <span class="comment">// ListItr是ArrayList的内部类，对它的介绍见第6小节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-内部类Itr"><a href="#5-内部类Itr" class="headerlink" title="5. 内部类Itr"></a>5. 内部类Itr</h4><p>内部类Itr是一种优化后的迭代器，它只支持向后访问列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 游标</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上次返回的元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（1）迭代器的next方法"><a href="#（1）迭代器的next方法" class="headerlink" title="（1）迭代器的next方法"></a>（1）迭代器的next方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification(); <span class="comment">// 检查是否在迭代过程中使用非迭代器的方法对集合进行结构化修改</span></span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(); <span class="comment">// 数组越界，不存在下一元素。</span></span><br><span class="line">    <span class="comment">// ArrayList.this.elementData表示ArrayList中的Object数组</span></span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length) <span class="comment">// 再一次判断是否越界，防止其它线程修改了集合结构。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i]; <span class="comment">// 使用lastRet标识此次返回的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>调用 checkForComodification 方法，检查是否在迭代过程中使用非迭代器的方法对集合进行结构化修改</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单地判断迭代器的expectedModCount参数与集合的modCount参数是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="（2）remove-方法"><a href="#（2）remove-方法" class="headerlink" title="（2）remove() 方法"></a>（2）remove() 方法</h5><p>删除上一次执行 next 方法的元素。</p>
<blockquote>
<p>迭代过程中，使用迭代器的 remove 方法才能安全地移除集合元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否执行过next方法</span></span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification(); <span class="comment">// 检查是否发生结构化修改的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet); <span class="comment">// 调用集合的remove方法</span></span><br><span class="line">        cursor = lastRet; <span class="comment">// 集合的remove方法删除元素后，返回原被删除元素的索引</span></span><br><span class="line">        lastRet = -<span class="number">1</span>; <span class="comment">// 重置lastRet</span></span><br><span class="line">        expectedModCount = modCount; <span class="comment">// 修改迭代器的expectedModCount参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-内部类ListItr"><a href="#6-内部类ListItr" class="headerlink" title="6. 内部类ListItr"></a>6. 内部类ListItr</h4><p>ListItr 也是一种内部迭代器类，它与 Itr 的区别在于，ListItr 可以<strong>向前</strong>和<strong>向后</strong>遍历列表，而 Itr 只能向后遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承Itr类，实现ListIterator接口。</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断是否有前驱元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回前驱元素索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回前驱元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><ul>
<li>ArrayList 的底层结构是数组，当数组长度不足时，通过扩容（1.5 倍）机制扩容，扩容的本质是复制数组。</li>
<li>ArrayList 常用的构造函数是空参构造函数。空参构造函数得到的是<strong>空数组</strong>，首次添加元素时<strong>扩容至默认值，即 10 。</strong></li>
<li><strong>扩容机制：</strong> grow(int minCapacity) 传入最小容量参数，首先执行 1.5 倍扩容方法，当扩容后的容量仍不满足最小容量时，将其直接置为最小容量。随后对得到的新容量进行校验，若其大于 Integer.MAX_VALUE - 8，执行 hugeCapacity(int minCapacity) 方法。在这一方法中，若最小容量发生溢出，直接抛出异常；否则判断最小容量是否大于 Integer.MAX_VALUE - 8。若是，将新容量更新为 Integer.MAX_VALUE；否则新容量为 Integer.MAX_VALUE - 8。</li>
<li>ArrayList 的源码中，规定最大容量是 <strong>Integer.MAX-VALUE - 8</strong>，这是因为部分虚拟机上会保留 8 个字节。但是根据 <strong>hugeCapacity</strong> 方法可发现，实际上最大可取 <strong>Integer.MAX_VALUE</strong>。在这种情况下，部分虚拟机（保留 8 个字节的）会报 OOM。</li>
<li>ArrayList 继承父类的 AbstractList 中的 modCount 字段，记录集合发生结构化修改（<strong>删除、添加元素，更新已存在的元素不是结构化修改</strong>）的次数。迭代器中维护 expectedModCount 字段，在初始化迭代器时，将集合的 modCount 赋予迭代器的 expectedModCount。在执行迭代器的方法时，首先判断二者是否相等，否的话抛出 ConcurrentModificationException 异常。</li>
<li>迭代器的 remove 方法的本质是<strong>调用集合的 remove 方法并更新迭代器的 expectedModCount 的值。</strong></li>
<li>迭代器 Iterator 和 ListIterator 都可以遍历集合，只是后者可以额外地向前遍历，其实现是将当前游标减1。</li>
<li>迭代器的 next 方法，首先调用 checkForComodification 方法检查是否对集合进行了修改，在获取元素值前判断索引是否越界，防止其它线程修改集合结构。</li>
</ul>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/2020/04/29/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式属于23种设计模式中的一种。代理提供了对<strong>被代理对象</strong>的间接访问方式，即通过<strong>代理对象</strong>访问被代理对象，并在被代理对象现有功能的基础上添加额外的功能，如<strong>日志</strong>、<strong>事务管理</strong>、<strong>权限控制</strong>等。</p>
<p>本文主要包括如下内容：</p>
<ul>
<li>静态代理与动态代理的比较。</li>
<li>JDK 动态代理过程及原理。</li>
<li>WeakCache 缓存机制。</li>
<li>CGLIB 动态代理过程。</li>
</ul>
<a id="more"></a>

<p>实现代理模式的方法有以下五种：</p>
<ul>
<li>静态代理：将增强的方法编写在代理类中，在编译期就明确了代理类。</li>
<li>JDK 动态代理：通过 JDK 提供的 Proxy 类中的 newProxyInstance 方法<strong>动态地创建代理类</strong>，基于<strong>反射</strong>实例化代理对象。（只能代理接口）</li>
<li>CGLIB 动态代理：CGLIB（Code Generation Library）基于 asm 字节码技术，<strong>生成被代理类的子类并覆盖其中的方法</strong>以实现增强。（代理非 final 修饰的类或接口）</li>
<li>Aspectj 动态代理：暂略</li>
<li>Instrumentation 动态代理：暂略</li>
</ul>
<blockquote>
<p>备注：JDK 动态代理的底层原理涉及 WeakCache 缓存机制，在学习过程中遇到一些不理解的内容，待后续学习中逐步完善本篇笔记。</p>
</blockquote>
<h4 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h4><blockquote>
<p>静态代理的特点在于编译期就确定了委托类和代理类，其本质是<strong>代理类持有被代理类的实例</strong>，在间接地执行被代理对象的具体方法前先执行新增的公共逻辑。</p>
</blockquote>
<p>（1）委托类和代理类之间的约束接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态代理类接口，是委托类和代理类都需要实现的接口规范</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）委托类（被代理类）实现该接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 委托类，实现约束接口Animal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lion</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" eat "</span> + foodName +<span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）代理类，编写增强方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal animal; <span class="comment">// 被代理对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxy</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== 这里可以编写增强方法 ==="</span>);</span><br><span class="line">        animal.eatfood(foodName);</span><br><span class="line">        System.out.println(<span class="string">"=== 这里可以编写增强方法 ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Lion(<span class="string">"Lion Herry"</span>);</span><br><span class="line">        MyProxy proxyInstance = <span class="keyword">new</span> MyProxy(animal); <span class="comment">// 传入被代理对象，获取代理对象</span></span><br><span class="line">        proxyInstance.eatfood(<span class="string">"mutton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、JDK-动态代理"><a href="#二、JDK-动态代理" class="headerlink" title="二、JDK 动态代理"></a>二、JDK 动态代理</h4><h5 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h5><p>（1）委托类和代理类之间的约束接口</p>
<blockquote>
<p>JDK 动态代理只能代理接口中声明的方法！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 定义委托类和代理类之间的约束行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）委托类实现该接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 委托类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lion</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" eat "</span> + foodName +<span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）实现 InvocationHandler 接口，<strong>定义横切逻辑，通过反射机制调用委托类的接口方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> LionInvocationHandler类实现InvocationHandler接口</span></span><br><span class="line"><span class="comment"> * 此类持有委托类的对象引用</span></span><br><span class="line"><span class="comment"> * 此类被Proxy类回调处理</span></span><br><span class="line"><span class="comment"> * 重写接口的invoke方法，添加公共逻辑代码并调用委托类的接口方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LionInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T target; <span class="comment">// 委托类的对象引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LionInvocationHandler</span><span class="params">(T target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理实例调用的接口方法对应的Method实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 形参数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 利用反射调用委托类中的相应方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回调用委托类中相应方法得到的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== 调用被代理对象的方法前执行本方法 ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== 调用被代理对象的方法后执行本方法 ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Lion(<span class="string">"Lion Herry"</span>); <span class="comment">// 目标对象，即被代理对象</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> LionInvocationHandler(animal);</span><br><span class="line">        Animal animalProxy = (Animal) Proxy.newProxyInstance(animal.getClass().getClassLoader(),</span><br><span class="line">                animal.getClass().getInterfaces(), handler); <span class="comment">// 生成代理对象</span></span><br><span class="line">        animalProxy.eatfood(<span class="string">"mutton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h5><p>改写上述（4）中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception  </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Lion(<span class="string">"Lion Herry"</span>); <span class="comment">// 1</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> LionInvocationHandler(animal); <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Animal<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">Animal</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        Constructor&lt;?&gt; proxyConstructor = proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        Animal animalProxy = (Animal) proxyConstructor.newInstance(handler);</span><br><span class="line">        <span class="comment">// 6</span></span><br><span class="line">        animalProxy.eatfood(<span class="string">"beaf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>JDK 动态代理的详细流程如下：</em></strong></p>
<ol>
<li>创建被代理的对象 <code>animal</code> 。</li>
<li>创建调用处理器对象 <code>handler</code> 。</li>
<li>根据指定的 ClassLoader 对象和委托类实现的接口，动态地创建代理类 <code>proxyClass</code>，此类<strong>继承 Proxy</strong> 。</li>
<li>利用<strong>反射</strong>获取动态代理类的构造器 <code>proxyConstructor</code>，其构造函数形参类型是调用处理器接口类型。</li>
<li>创建动态代理类实例 <code>animalProxy</code>，传入调用处理器对象 <code>handler</code> 。</li>
<li>调用委托类的接口方法。</li>
</ol>
<h5 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h5><p>在测试类中添加保存生成的代理类字节码文件的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存生成的代理类字节码文件</span></span><br><span class="line">        System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Lion(<span class="string">"Lion Herry"</span>); <span class="comment">// 目标对象，即被代理对象</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> LionInvocationHandler(animal);</span><br><span class="line">        Animal animalProxy = (Animal) Proxy.newProxyInstance(animal.getClass().getClassLoader(),</span><br><span class="line">                animal.getClass().getInterfaces(), handler); <span class="comment">// 生成代理对象</span></span><br><span class="line">        animalProxy.eatfood(<span class="string">"mutton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）首先看 InvocationHandler 接口源码</p>
<p>java.lang.reflect 包中的 InvocationHandler 是由代理实例的调用处理程序实现的接口。<strong>每个代理实例都有一个关联的调用处理程序对象。</strong>在代理实例上调用接口方法时，该方法调用将被编码并分派至其调用处理程序对象的 invoke 方法。</p>
<p>接口中仅声明了一个 invoke 方法。此方法用于处理代理实例上的方法调用，并返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理实例调用的接口方法对应的Method实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 形参数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回代理实例调用接口方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）实现 InvocationHandler 接口，重写 invoke 方法并织入横切逻辑。（代码同前）</p>
<p>（3）调用 java.lang.reflect.Proxy 的静态 newProxyInstance 方法获取代理类的实例，该实例将方法调用分派到指定的调用处理程序。</p>
<p>接下来关注 newProxyInstance 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                              InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验与代理实例关联的调用处理程序对象是否为null。若为null，抛NullPointerException。    </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">	<span class="comment">// 克隆委托类实现的接口</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="comment">// 获取系统安全性接口。若已为当前应用程序建立安全管理器，则返回该安全管理器。否则返回null。</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若系统安全性接口不为null，调用Proxy类的私有方法checkProxyAccess，检查创建代理类所需的权限。</span></span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用Proxy类的私有方法getProxyClass0，获取代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs); <span class="comment">// 此方法源码分析见详情[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>详情 [1]：Proxy 类的私有方法 getProxyClass0 源码</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 委托类类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces 委托类实现的接口组成的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 限制委托类实现的接口最多为65535个</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试从代理类的缓存中获取相应的代理类，否则通过ProxyClassFactory生成代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces); <span class="comment">// 此方法的源码分析见详情[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>详情 [2]：查找或生成代理类</em></p>
<p>Proxy 类内部使用 <strong>WeakCache 来缓存代理类</strong>。</p>
<p>Proxy 类加载时，静态常量 <code>proxyClassCache</code> 被初始化，其中二级缓存 key 的生成器（subKeyFactory）是 Proxy 类的 <strong>KeyFactory</strong>，二级缓存 value 的生成器（valueFactory）是 Proxy 类的 <strong>ProxyClassFactory</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy类的静态字段proxyClassCache，表示代理类的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure>

<p><em>final 修饰的 java.lang.reflect.WeakCache 类源码（常量字段 &amp; 构造方法）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakCache</span>&lt;<span class="title">K</span>, <span class="title">P</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用队列，存放被回收的WeakReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;K&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 缓存容器，由一、二级缓存组成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">        = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录所有代理类生成器是否可用，实现缓存的过期机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap</span><br><span class="line">        = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// BiFunction接口表示方法接收两个参数并返回一个结果</span></span><br><span class="line">    <span class="comment">// 二级缓存的key的生成器，(key, parameter) -&gt; sub-key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line">    <span class="comment">// 二级缓存的value的生成器，(key, parameter) -&gt; value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入二级缓存的key和value的生成器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">        <span class="keyword">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 WeakCache 类中获取代理类的 get 方法的源码。</p>
<p>WeakCache 类的缓存容器底层结构是 ConcurrentHashMap，因而实现线程安全。在 get 方法中，根据给定的类加载器和接口数组得到二级缓存的值，即 <strong>Factory 实例</strong>，最终代理类是通过这个 Factory 实例生成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 传入的是委托类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter 传入的是接口数组（委托类实现的接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验接口数组是否为null。若为null，抛NullPointerException。</span></span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line">	<span class="comment">// 清除过期缓存</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">	<span class="comment">// 将类加载器包装成CacheKey。CacheKey包含key的弱引用，在refQueue中注册。</span></span><br><span class="line">    <span class="comment">// 此对象作为一级缓存的key</span></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line">	<span class="comment">// 获取二级缓存容器</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="comment">// 当二级缓存容器为null时</span></span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以CAS操作的方式，新建二级缓存容器并存入一级缓存容器map中</span></span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 根据类加载器和接口数组生成二级缓存的key，即subKey</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    <span class="comment">// 尝试通过subKey获取二级缓存的value</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 若二级缓存的value不为null</span></span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用WeakCache的内部类Factory的get方法，尝试获取Factory实例</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个Factory实例</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 若上述获取的二级缓存的value为null</span></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 存入新建的Factory实例</span></span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 成功将Factory实例放入缓存</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 期间可能有其他线程修改了值，则将旧值替换</span></span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// 替换成功</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 替换失败，继续使用旧值</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 WeakCache 的内部类 Factory 的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 一级缓存key，根据类加载器生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 接口数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> P parameter;</span><br><span class="line">    <span class="comment">// 二级缓存key，根据接口数组生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;</span><br><span class="line">    <span class="comment">// 二级缓存容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class="line"></span><br><span class="line">    Factory(K key, P parameter, Object subKey,</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">        <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">        <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">            <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">            <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">            <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">            <span class="comment">// the loop</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// create new value</span></span><br><span class="line">        V value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">        <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">        CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put into reverseMap</span></span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">        <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">        <span class="comment">// wrapped by it</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【未完待续<del>~</del>】</p>
<hr>
<h4 id="三、CGLIB-动态代理"><a href="#三、CGLIB-动态代理" class="headerlink" title="三、CGLIB 动态代理"></a>三、CGLIB 动态代理</h4><p>CGLIB 动态代理的特点如下：</p>
<ul>
<li>CGLIB 可代理接口和类，其中接口使用实现的方式，类使用的是继承的方式。</li>
<li>final 修饰的类是不能被代理的。final、private、static 修饰的方法是不能被代理的。</li>
</ul>
<p>（1）委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 委托类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatfood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The lion is eating "</span> + foodName +<span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）实现方法拦截器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Cglib动态代理类的工具方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 委托类的Class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class target)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); <span class="comment">// 创建加强器，用于创建动态代理类。</span></span><br><span class="line">        enhancer.setSuperclass(target); <span class="comment">// 指定委托类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>); <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦截。</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create(); <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">                            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== 调用被代理对象的方法前执行本方法 ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== 调用被代理对象的方法后执行本方法 ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        Lion proxyInstance = (Lion) proxy.getProxy(Lion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        proxyInstance.eatfood(<span class="string">"mutton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>静态代理在编译期就确定了代理类，而动态代理是在程序运行期间动态地创建代理类。</li>
<li>JDK 动态代理生成的动态代理类继承 Proxy 类。Java 不允许多继承，因此 JDK 动态代理<strong>只能代理接口！</strong></li>
<li>JDK 动态代理只能代理接口方法！若接口的实现类中定义了接口中未声明的方法，该方法不能被代理。</li>
<li>JDK 动态代理创建动态代理对象的过程快，但调用委托类的接口方法慢；CGLIB 动态代理创建动态代理对象的过程慢，但调用委托类的接口方法快。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://cloud.tencent.com/developer/article/1461796" target="_blank" rel="noopener">太好了！总算有人把动态代理、CGlib、AOP都说清楚了！</a></p>
<p>[2] <a href="https://www.cnblogs.com/zuidongfeng/p/8735241.html" target="_blank" rel="noopener">JDK动态代理实现原理</a></p>
<p>[3] <a href="https://www.cnblogs.com/liuyun1995/p/8157098.html" target="_blank" rel="noopener">JDK动态代理[2]—-JDK动态代理的底层实现之Proxy源码分析</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题集（四）：矩阵搜索问题</title>
    <url>/2020/04/09/%E5%89%91%E6%8C%87Offer%E9%A2%98%E9%9B%86%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>矩阵搜索问题通常可通过深度优先搜索（DFS）或广度优先搜索（BFS）解决。本文总结了在刷题过程中遇见的可采用 <strong>DFS + 回溯</strong> 解决的矩阵搜索问题。</p>
<p>核心：由当前位置向指定方向搜索（递归过程），若搜索结果不满足要求，则回溯至原位置。</p>
<a id="more"></a>

<h4 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12. 矩阵中的路径"></a>面试题12. 矩阵中的路径</h4><h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
<p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题12. 矩阵中的路径</a></p>
<p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">力扣-79. 单词搜索</a></p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>DFS+回溯：类似于<a href="https://merlinhu0112.github.io/2020/01/13/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">八皇后</a>问题，由二维数组的每一个位置开始搜索。若当前位置字符符合要求，则<strong>递归搜索</strong>当前位置的<strong>上下左右</strong>位置，观察其是否依然符合。在搜索过程中，对于已访问过的位置，需要将其<strong>特殊标记</strong>。若发生回溯，则在回溯过程中取消已标记的位置。</p>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(board, arr, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 字符串word的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] arr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 索引越界或字符不匹配，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;board.length-<span class="number">1</span> || j&lt;<span class="number">0</span> || j&gt;board[<span class="number">0</span>].length-<span class="number">1</span></span><br><span class="line">                || arr[k]!=board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以完成全部字符串的匹配，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(k==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">'+'</span>; <span class="comment">// 占位，标识此位置字符已经被访问过</span></span><br><span class="line">        <span class="comment">// 若索引为k的字符是匹配的，则继续匹配索引为k+1的字符</span></span><br><span class="line">        <span class="comment">// 左,右,上,下</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = helper(board, arr, i, j-<span class="number">1</span>, k+<span class="number">1</span>) || helper(board, arr, i, j+<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">                || helper(board, arr, i-<span class="number">1</span>, j, k+<span class="number">1</span>) || helper(board, arr, i+<span class="number">1</span>, j, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = temp; <span class="comment">// 还原</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a>面试题13. 机器人的运动范围</h4><h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>地上有一个 <code>m</code> 行 <code>n</code> 列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入<strong>行坐标和列坐标的数位之和大于k的格子</strong>。请问该机器人最多能够到达多少个格子？</p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题13. 机器人的运动范围</a></p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>DFS+回溯：类似于第12题的搜索过程。机器人从当前位置出发，探索相邻的位置。特别地，若当前位置是符合要求的，那么当前位置的<strong>左邻位</strong>和<strong>上邻位</strong>一定是符合要求的！因此在本题中，机器人的搜索策略可以简化为：若当前位置可行，仅<strong>向右</strong>和<strong>向下</strong>搜索。</p>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// count是全局变量，每次调用movingCount方法时都要将其初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] visted = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">// 二维数组用来标识指定位置是否已被使用过</span></span><br><span class="line">        put(visted, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置机器人</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span>[][]visted, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 索引越界或当前位置已被访问过，无效，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=visted.length || j&lt;<span class="number">0</span> || j&gt;=visted[<span class="number">0</span>].length || visted[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果索引i和j确定的位置可以放置机器人</span></span><br><span class="line">        <span class="keyword">if</span>(check(i, j, k) &amp;&amp; visted[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">            visted[i][j] = <span class="number">1</span>; <span class="comment">// 表示此位置已被统计过</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 只需要向右或向下搜索，向上或向左一定是满足的</span></span><br><span class="line">            <span class="comment">//put(visted, i-1, j, k);</span></span><br><span class="line">            put(visted, i+<span class="number">1</span>,j,k);</span><br><span class="line">            <span class="comment">//put(visted, i, j-1, k);</span></span><br><span class="line">            put(visted, i, j+<span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断索引i和j确定的位置，能否放置机器人</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = sum(i) + sum(j);</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i = i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(MN)。最差情况下，机器人需要访问所有位置。</li>
<li>空间复杂度：O(MN)。最坏情况下，机器人需要访问所有位置，辅助数组 <code>visted</code> 为 <code>m</code> 行、<code>n</code> 列。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题集（三）：二分查找与有序数组查找元素</title>
    <url>/2020/04/06/%E5%89%91%E6%8C%87Offer%E9%A2%98%E9%9B%86%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>在无序的数组中查找目标值是否存在，只能通过遍历数组的方式，其时间复杂度为O(N)。</p>
<p>在<strong>有序</strong>的数组中查找目标值是否存在，可以通过遍历数组的方式，时间复杂度为O(N)。考虑到有序这一特性，还可以通过<strong>二分查找</strong>，使时间复杂度降至<strong>O(log N)</strong>。</p>
<a id="more"></a>

<h4 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11. 旋转数组的最小数字"></a>面试题11. 旋转数组的最小数字</h4><h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 <code>[0, 1, 2, 4, 5, 6, 7]</code> 可能变为 <code>[4, 5, 6, 7, 0, 1, 2]</code> ，最小的数字是 <code>0</code> 。</p>
<p>注意数组中<strong>可能存在重复的元素</strong>。</p>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题11. 旋转数组的最小数字</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">力扣-154. 寻找旋转排序数组中的最小值 II</a></p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>（1）遍历数组，时间复杂度为O(N)。</p>
<p>（2）利用<strong>数组部分有序</strong>的特性，采用二分法，时间复杂度为O(log N)。</p>
<p>设置数组的左边界 <code>left</code> 和右边界 <code>right</code> 指针，及中间元素 <code>mid</code> 指针。将 <code>numbers[mid]</code> 与 <code>numbers[right]</code> 比较，会有如下三种情况：</p>
<ul>
<li><code>numbers[mid] &gt; numbers[right]</code> 。当前数组的中间元素和右边界不在同一侧，即最小元素值应该在 <code>mid</code> 和 <code>right</code> 之间，故令 <code>left = mid + 1</code>，继续二分查找。</li>
<li><code>numbers[mid] &lt; numbers[right]</code> 。当前数组的中间元素和右边界在同一侧，即最小元素值应该在 <strong>mid之前（含mid）</strong>，故令 <code>right = mid</code>，继续二分查找。</li>
<li><code>numbers[mid] = numbers[right]</code> 。此时无法断定最小元素值是在 <code>mid</code> 的哪一侧，故令 <code>right = right - 1</code>，继续二分查找。若数组所有元素均相同，则时间复杂度恶化为O(N)。</li>
</ul>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="comment">// 循环，直至left==right</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">// 目标元素在右边</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">// 目标元素在左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：平均为O(log N)，最坏为O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h5 id="4-数组不含重复值的情况"><a href="#4-数组不含重复值的情况" class="headerlink" title="4. 数组不含重复值的情况"></a>4. 数组不含重复值的情况</h5><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p>
<p><strong>数组不含重复值</strong>：此时不存在上述 <code>numbers[mid] = numbers[right]</code> 的情形，算法的时间复杂度稳定为O(log N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>; <span class="comment">// 防加和溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="comment">// 目标元素在右边</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 目标元素在左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            不同于154题的元素可重复，本题元素不可重复，即</span></span><br><span class="line"><span class="comment">            不存在"nums[mid]==nums[right]"的情况，因此使得</span></span><br><span class="line"><span class="comment">            算法的时间复杂度稳定为O(logN)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面试题53-I-在排序数组中查找数字-I"><a href="#面试题53-I-在排序数组中查找数字-I" class="headerlink" title="面试题53-I. 在排序数组中查找数字 I"></a>面试题53-I. 在排序数组中查找数字 I</h4><h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>在有序的数组中找出指定值的左右边界，指定值可有多个，也可不存在。要求算法的时间复杂度为O(log N)。</p>
<p> <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题53-I. 在排序数组中查找数字 I</a></p>
<p>  <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">力扣-34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><p><strong>有序数组 + O(log N)的时间复杂度 == 二分法</strong></p>
<p>不同于普通的二分法查找目标值是否存在，此类题不仅需要明确目标值是否存在，还要确定存在的目标值的左右索引。</p>
<p>设 <code>left</code>、<code>right</code>、<code>mid</code> 指针。显然，有如下三种情况：</p>
<p>（1）<code>nums[mid] &lt; target</code>，目标值可能位于数组右侧，令 <code>left = mid + 1</code>，继续二分查找。</p>
<p>（2）<code>nums[mid] &gt; target</code>，目标值可能位于数组左侧，令 <code>right = mid - 1</code>，继续二分查找。</p>
<p>（3）<code>nums[mid] = target</code>，匹配到目标值。此时，需要进一步确定目标值的左右边界。</p>
<ul>
<li>对于左边界：若 <code>mid &gt; 0 &amp;&amp; nums[mid] == nums[mid-1]</code> 成立，令 <code>right = mid - 1</code>，继续二分查找；否则，<code>mid</code> 为左边界，直接返回。</li>
<li>对于右边界：若 <code>mid &lt; nums.length - 1 &amp;&amp; nums[mid] == nums[mid+1]</code> 成立，令 <code>right = mid - 1</code>，继续二分查找；否则，<code>mid</code> 为右边界，直接返回。</li>
</ul>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分法，使得时间复杂度为O(logN)以达到题目要求。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span> || target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftIndex = binarySearch(nums, target, <span class="keyword">true</span>);</span><br><span class="line">        res[<span class="number">0</span>] = leftIndex;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = binarySearch(nums, target, <span class="keyword">false</span>);</span><br><span class="line">        res[<span class="number">1</span>] = rightIndex;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag标志位：flag为true时表示，当匹配到目标值时，进入左边寻找左边界；</span></span><br><span class="line">    <span class="comment">// flag为false时表示，当匹配到目标值时，进入右边寻找右边界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target, <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]==target)&#123;</span><br><span class="line">                <span class="comment">// 匹配到目标值</span></span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="comment">// 寻找左边界</span></span><br><span class="line">                    <span class="keyword">if</span>(mid &gt; <span class="number">0</span> &amp;&amp; arr[mid]==arr[mid-<span class="number">1</span>])&#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> mid; <span class="comment">// mid即为左边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 寻找右边界</span></span><br><span class="line">                    <span class="keyword">if</span>(mid &lt; arr.length - <span class="number">1</span> &amp;&amp; arr[mid]==arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> mid; <span class="comment">// mid即为右边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">                <span class="comment">// 目标值可能在当前数组的左边</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 目标值可能在当前数组的右边</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(log N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
        <tag>Sorted Array</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题集（二）：二叉树问题集合</title>
    <url>/2020/04/06/%E5%89%91%E6%8C%87Offer%E9%A2%98%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>《剑指Offer》中涉及的二叉树问题集合。</p>
<p>总结：</p>
<ul>
<li>涉及二叉树的问题，离不开 DFS 和 BFS，即深度优先搜索和广度优先搜索。</li>
<li>常用的解题方法是递归和迭代，其中递归法更加直观，迭代法往往需要栈或队列的辅助。</li>
<li>要求处理一棵二叉树的遍历序列时，可先找出二叉树的根节点，再根据根节点将二叉树划分为左右子树并递归地处理左右子树。</li>
</ul>
<a id="more"></a>

<h4 id="面试题-07-重建二叉树"><a href="#面试题-07-重建二叉树" class="headerlink" title="面试题 07. 重建二叉树"></a>面试题 07. 重建二叉树</h4><h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题07. 重建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">力扣-105. 从前序与中序遍历序列构造二叉树</a></p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>递归：易知，先序遍历得到的首个值是 root 节点的值，即可根据该元素值在中序遍历得到的数组中的位置，将其分为左右子树的节点，并分别递归地拼接左右子树。</li>
</ul>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现：</p>
<blockquote>
<p>需要注意的是，在递归建立左右子树的过程中，对左子树，注意 <code>preHi</code>；对右子树，注意 <code>preLo</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] preAux = <span class="keyword">null</span>; <span class="comment">// 辅助数组，先序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] inAux = <span class="keyword">null</span>; <span class="comment">// 辅助数组，中序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span> || inorder==<span class="keyword">null</span> || preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preAux = preorder;</span><br><span class="line">        inAux = inorder;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, preAux.length-<span class="number">1</span>, <span class="number">0</span>, inAux.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preLo 先序遍历得到的数组的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preHi 先序遍历得到的数组的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inLo 中序遍历得到的数组的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inHi 中遍历得到的数组的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 建树完成，返回根节点内存地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preLo, <span class="keyword">int</span> preHi, <span class="keyword">int</span> inLo, <span class="keyword">int</span> inHi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLo &gt; preHi || inLo &gt; inHi)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preAux[preLo]; <span class="comment">// 当前子树的根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> index = inLo; <span class="comment">// 根结点在中序遍历数组中的索引</span></span><br><span class="line">        <span class="keyword">while</span>(inAux[index]!=rootVal)&#123;</span><br><span class="line">            <span class="comment">// 结点元素值是唯一的，且一定存在</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在递归建立左右子树的过程中：对左子树，注意preHi的值；对右子树，注意preLo的值</span></span><br><span class="line">        root.left = helper(preLo+<span class="number">1</span>, preLo+(index-inLo), inLo, index-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(preLo+(index-inLo)+<span class="number">1</span>, preHi, index+<span class="number">1</span>, inHi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)，对于每个节点都有创建过程以及根据左右子树重建过程。</li>
<li>空间复杂度：O(N)，存储整棵树的开销。</li>
</ul>
<p>（2）迭代实现</p>
<p>暂无，可参考<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">官方题解</a>。</p>
<hr>
<h4 id="面试题-26-树的子结构"><a href="#面试题-26-树的子结构" class="headerlink" title="面试题 26. 树的子结构"></a>面试题 26. 树的子结构</h4><h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题26. 树的子结构</a></p>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。约定空树不是任意一个树的子结构。</p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-04-15</span></span><br><span class="line"><span class="comment"> * 基于深度优先搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || B==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 约定空树不是任意一个树的子结构</span></span><br><span class="line">    <span class="keyword">return</span> (dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索，判断树B是否是树A的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.val!=B.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(B.left!=<span class="keyword">null</span> &amp;&amp; !dfs(A.left, B.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(B.right!=<span class="keyword">null</span> &amp;&amp; !dfs(A.right, B.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(MN)，其中 M 和 N 分别是树 A 和 B 的节点数。先序遍历树 A，时间复杂度为 O(M)。在先序遍历树 A 的过程中调用 DFS 方法，时间复杂度为 O(N)。故算法的时间复杂度为 O(MN)。</li>
<li>空间复杂度：O(M)。当树 A 和 B 都退化为链表时，递归深度最大为 M，故空间复杂度为 O(M)。</li>
</ul>
<hr>
<h4 id="面试题-27-二叉树的镜像"><a href="#面试题-27-二叉树的镜像" class="headerlink" title="面试题 27. 二叉树的镜像"></a>面试题 27. 二叉树的镜像</h4><h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。即翻转二叉树。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题27. 二叉树的镜像</a></p>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">力扣-226. 翻转二叉树</a></p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>递归：根据二叉树镜像的定义，通过<strong>递归先序遍历</strong>二叉树，互相交换左右子树，即可实现翻转二叉树。</li>
</ul>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换root节点的左右子树</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        <span class="comment">// 递归修改左子树为镜像</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归修改右子树为镜像</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)，需要遍历每一个节点。</li>
<li>空间复杂度：最坏的情况下，二叉树退化为链表，递归将被调用 N 次，故空间复杂度为 O(N)；在最好的情况下，二叉树是完全平衡的，高度为 O(logN)，故空间复杂度为 O(logN)。</li>
</ul>
<p>（2）迭代实现</p>
<p>暂无，可参考<a href="https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<hr>
<h4 id="面试题-28-对称的二叉树"><a href="#面试题-28-对称的二叉树" class="headerlink" title="面试题 28. 对称的二叉树"></a>面试题 28. 对称的二叉树</h4><h5 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h5 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>对于对称二叉树上的任意两个对称的非叶子节点 <code>left</code> 和 <code>right</code>，必然有如下关系成立：</p>
<ul>
<li><code>left.val == right.val</code>；</li>
<li><code>left.left.val == right.right.val</code>；</li>
<li><code>left.right.val == right.left.val</code>。</li>
</ul>
<p>对于任意两个对称的叶子节点，只有第一条关系式成立。</p>
<p>因此，递归地判断二叉树的左右子节点即可判断其是否为镜像对称的。</p>
<h5 id="3-实现-2"><a href="#3-实现-2" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> recursive(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recursive</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span> || left.val!=right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 只有一个子节点或左右子节点值不同时，一定不是镜像</span></span><br><span class="line">        <span class="keyword">return</span> (recursive(left.left, right.right) &amp;&amp;</span><br><span class="line">                recursive(left.right, right.left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）迭代实现</p>
<p>迭代实现基于深度优先搜索，但插入队列顺序与 BFS 有差异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始时，根结点只有一个，将其存入两次</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">// 当队列不为空时，每次取出两个连续的结点。</span></span><br><span class="line">        <span class="comment">// 当且仅当每次取出的两个结点值相等，才满足镜像对称</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode left = queue.poll();</span><br><span class="line">            TreeNode right = queue.poll();</span><br><span class="line">            <span class="comment">// 结点A、B均为null，满足镜像对称，且需要跳过此次循环</span></span><br><span class="line">            <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有一个子节点或左右子节点值不同时，一定不是镜像</span></span><br><span class="line">            <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span> || left.val!=right.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(left.left);</span><br><span class="line">            queue.add(right.right);</span><br><span class="line">            queue.add(left.right);</span><br><span class="line">            queue.add(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a>面试题33. 二叉搜索树的后序遍历序列</h4><h5 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题33.二叉搜索树的后序遍历序列</a></p>
<h5 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>二叉搜索树：左子树所有节点元素值小于根节点元素值，右子树所有节点元素值大于根节点元素值。</li>
<li>给定数组的最后一个元素就是根节点，因此可根据根节点将数组划分为左右子树序列，再递归地判断左右子树。</li>
</ul>
<h5 id="3-实现-3"><a href="#3-实现-3" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 测试用例中，空数组返回true</span></span><br><span class="line"><span class="comment">        if(postorder == null || postorder.length &lt;= 0)&#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从索引start开始，寻找首个大于根节点元素值的元素</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[end])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 索引i将数组分为左右子树两部分</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; end; j++)&#123;</span><br><span class="line">            <span class="comment">// 若右子树中存在小于根节点元素值的节点，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[end])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归地判断左右子树</span></span><br><span class="line">        <span class="keyword">return</span> (helper(arr, start, i-<span class="number">1</span>) &amp;&amp; helper(arr, i, end-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（有<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">资料</a>认为此算法的时间复杂度为 O(N^2)，空间复杂度为 O(N)，但我不是很理解。）</p>
<hr>
<h4 id="面试题-55-I-二叉树的深度"><a href="#面试题-55-I-二叉树的深度" class="headerlink" title="面试题 55-I. 二叉树的深度"></a>面试题 55-I. 二叉树的深度</h4><h5 id="1-题目-5"><a href="#1-题目-5" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题55-I. 二叉树的深度</a></p>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">力扣-104. 二叉树的最大深度</a></p>
<h5 id="2-思路-4"><a href="#2-思路-4" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>递归：递归求解左右子树的最大深度，并选取较大者。</li>
<li>迭代：层序遍历，辅助队列每次存入当前层级所有节点，深度计数器加1。</li>
</ul>
<h5 id="3-实现-4"><a href="#3-实现-4" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(helper(root.left), helper(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)，需要遍历每一个节点。</li>
<li>空间复杂度：最坏的情况下，二叉树退化为链表，递归将被调用 N 次，故空间复杂度为 O(N)；在最好的情况下，二叉树是完全平衡的，高度为 O(logN)，故空间复杂度为 O(logN)。</li>
</ul>
<p>（2）迭代实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// BFS 广度优先搜索实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root); <span class="comment">// 存入根结点</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">// 根结点所在层级为0</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> levelSize = queue.size(); <span class="comment">// 当前层结点数</span></span><br><span class="line">            <span class="comment">// 循环，取出当前层结点，并存入下一层结点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;levelSize; i++)&#123;</span><br><span class="line">                TreeNode node = queue.remove();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)，需要遍历每一个节点。</li>
<li>空间复杂度：O(N)，队列存储遍历的每一个节点。</li>
</ul>
<hr>
<h4 id="面试题-68-I-二叉树的最近公共祖先"><a href="#面试题-68-I-二叉树的最近公共祖先" class="headerlink" title="面试题 68-I. 二叉树的最近公共祖先"></a>面试题 68-I. 二叉树的最近公共祖先</h4><h5 id="1-题目-6"><a href="#1-题目-6" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<blockquote>
<p>最近公共祖先：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题68-I. 二叉树的最近公共祖先</a></p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">力扣-236. 二叉树的最近公共祖先</a></p>
<h5 id="2-思路-5"><a href="#2-思路-5" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>递归实现</li>
</ul>
<h5 id="3-实现-5"><a href="#3-实现-5" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root == p || root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode leftAncestor = lowestCommonAncestor(root.left, p, q); <span class="comment">// 递归进入左子树查找</span></span><br><span class="line">        TreeNode rightAncestor = lowestCommonAncestor(root.right, p, q); <span class="comment">// 递归进入右子树查找</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftAncestor==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightAncestor; <span class="comment">// 左子树没有，返回右子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rightAncestor==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftAncestor; <span class="comment">// 右子树没有，返回左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 都没有，返回根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)，最坏情况下需要遍历所有节点。</li>
<li>空间复杂度：O(N)，最坏情况下需要遍历所有节点。</li>
</ul>
<hr>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h4><h5 id="1-题目-7"><a href="#1-题目-7" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<blockquote>
<p>二叉搜索树的特性：左子树所有节点元素值不大于根节点元素值，右子树所有节点元素值不小于根节点元素值。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">力扣-235. 二叉搜索树的最近公共祖先</a></p>
<h5 id="2-思路-6"><a href="#2-思路-6" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>递归：类似于上面的<strong>二叉树的最近公共祖先</strong>问题，且二叉搜索树的特性使问题得到简化。</li>
</ul>
<h5 id="3-实现-6"><a href="#3-实现-6" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p和q节点在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p和q节点在右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都没有，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题集（一）：链表问题集合</title>
    <url>/2020/03/24/%E5%89%91%E6%8C%87Offer%E9%A2%98%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>《剑指Offer》中涉及的链表问题集合。</p>
<p>总结：</p>
<ul>
<li>对单链表的操作，善用两个指针！</li>
<li>对单链表的逆序操作，优先考虑递归或栈辅助。</li>
<li>对单链表的删除操作，常常要考虑设置 dummyNode，以便操作头节点。</li>
<li>对单链表倒数第 K 个元素的操作，可用双指针，其中 first 指针要先行 K 步。</li>
<li>对循环单链表的操作，可用快慢指针。</li>
</ul>
<hr>
<a id="more"></a>

<blockquote>
<p>题目来源于《剑指Offer》第二版。同样的题目，在牛客网和 LeetCode《剑指Offer》专区的表示和要求或许稍有差异，但算法实现是相同的。</p>
</blockquote>
<hr>
<h4 id="面试题06-从尾到头打印链表【递归-or-栈】"><a href="#面试题06-从尾到头打印链表【递归-or-栈】" class="headerlink" title="面试题06. 从尾到头打印链表【递归 or 栈】"></a>面试题06. 从尾到头打印链表【递归 or 栈】</h4><h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题06. 从尾到头打印链表</a></p>
<h5 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h5><ul>
<li>递归实现</li>
<li>栈辅助</li>
</ul>
<h5 id="3-实现："><a href="#3-实现：" class="headerlink" title="3. 实现："></a>3. 实现：</h5><p>（1）递归实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        recursion(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recursion(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）栈辅助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 借助栈先进后出的特点，实现单链表逆序打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode current = head; <span class="comment">// 当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 统计节点个数</span></span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(current); <span class="comment">// 压入节点指针</span></span><br><span class="line">            current = current.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            res[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>递归和栈辅助算法，时间复杂度均为：O(N)。</li>
<li>递归和栈辅助算法，空间复杂度均为：O(N)。</li>
</ul>
<hr>
<h4 id="面试题18-1-删除链表的节点"><a href="#面试题18-1-删除链表的节点" class="headerlink" title="面试题18(1). 删除链表的节点"></a>面试题18(1). 删除链表的节点</h4><h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。</p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>与<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">LeetCode上的改进版</a>和<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">LeetCode第237题-删除链表中的节点</a>不同，此题给定头指针和目标节点指针，且要求平均时间复杂度为O(1)。</p>
<p>此题分为三种情形：</p>
<ul>
<li>链表仅有一个节点，且目标节点和头节点为该节点：直接置null。</li>
<li>目标节点是中间节点：类似LeetCode第237题的实现，用目标节点的下一节点元素值覆盖目标节点，并移除目标节点的下一节点即可。</li>
<li>目标节点是尾节点：遍历链表。</li>
</ul>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode deleteNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="keyword">null</span> || deleteNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表仅有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head==deleteNode)&#123;</span><br><span class="line">        head = <span class="keyword">null</span>; <span class="comment">// 他人在此处写的是"head.next==null"。既然只有一个节点，其next比如为null，认为将head置null即可实现删除。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标节点是中间节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(deleteNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode nextNode = deleteNode.next;</span><br><span class="line">        deleteNode.val = nextNode.val;</span><br><span class="line">        deleteNode.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标节点是尾节点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=deleteNode)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：平均为O(1)，坏情况下为O(N)；</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h5 id="另：LeetCode第237题-删除链表中的节点"><a href="#另：LeetCode第237题-删除链表中的节点" class="headerlink" title="另：LeetCode第237题-删除链表中的节点"></a>另：LeetCode第237题-删除链表中的节点</h5><p>题目限定：链表至少有两个节点，目标节点一定有效且不为尾节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode deleteNode)</span> </span>&#123;</span><br><span class="line">    ListNode pNext = deleteNode.next;</span><br><span class="line">    deleteNode.val = pNext.val; </span><br><span class="line">    deleteNode.next = pNext.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面试题18-2-删除链表中的重复节点【双指针】"><a href="#面试题18-2-删除链表中的重复节点【双指针】" class="headerlink" title="面试题18(2). 删除链表中的重复节点【双指针】"></a>面试题18(2). 删除链表中的重复节点【双指针】</h4><h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">力扣-82. 删除排序链表中的重复元素 II</a></p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>注意需要删除全部重复节点。可采用双指针分别标识重复节点的起始节点的上一节点和重复节点的结束节点。注意，被标识的重复节点仅仅是当前最靠近链表头部的重复节点区域，其后可能还要其它值的重复节点，需要依次删除每一个重复的节点区域。</p>
<p>如 <code>1-2-2-2-3-3-4-5</code>，先标识出<code>2-2-2</code>并删除，再标识出<code>3-3</code>并删除，最终结果为<code>1-4-5</code>。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = pHead; <span class="comment">// 便于删除头结点</span></span><br><span class="line">    ListNode p = dummyNode; <span class="comment">// p标识重复节点的起始节点的上一节点</span></span><br><span class="line">    ListNode q; <span class="comment">// q标识重复节点的结束节点</span></span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q = p.next;</span><br><span class="line">        <span class="keyword">while</span>(q.next!=<span class="keyword">null</span> &amp;&amp; q.next.val==q.val)&#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=q)&#123;</span><br><span class="line">            <span class="comment">// 有重复结点</span></span><br><span class="line">            p.next = q.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：O(N)；</li>
<li>空间复杂度：O(1)。</li>
</ul>
<hr>
<h4 id="面试题22-链表中倒数第k个节点【双指针】"><a href="#面试题22-链表中倒数第k个节点【双指针】" class="headerlink" title="面试题22. 链表中倒数第k个节点【双指针】"></a>面试题22. 链表中倒数第k个节点【双指针】</h4><h5 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入一个链表，输出该链表中倒数第k个节点。</p>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题22. 链表中倒数第k个节点</a></p>
<h5 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>双指针，first指针比second指针先走k步；随后一起走，直至first指针为null，返回second指针指向的结点即可。</p>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = head;</span><br><span class="line">        <span class="comment">// first指针先行k步</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=k &amp;&amp; first!=<span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// k已超过链表长度，不合法</span></span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span> &amp;&amp; (i&lt;=k))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// first指针往后直至为null，second指针指向目标结点</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度为：O(N)；</li>
<li>空间复杂度为：O(1)。</li>
</ul>
<hr>
<h4 id="面试题24-反转链表【双指针】"><a href="#面试题24-反转链表【双指针】" class="headerlink" title="面试题24. 反转链表【双指针】"></a>面试题24. 反转链表【双指针】</h4><h5 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>反转链表。</p>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题24. 反转链表</a></p>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">力扣-206. 反转链表</a></p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>, q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p.next = q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度为：O(N)。</li>
<li>空间复杂度为：O(1)。</li>
</ul>
<hr>
<h4 id="面试题25-合并两个排序的链表"><a href="#面试题25-合并两个排序的链表" class="headerlink" title="面试题25. 合并两个排序的链表"></a>面试题25. 合并两个排序的链表</h4><h5 id="1-题目-5"><a href="#1-题目-5" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题25. 合并两个排序的链表</a></p>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">力扣-21. 合并两个有序链表</a></p>
<h5 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li>迭代 or 递归</li>
</ul>
<h5 id="3-实现-2"><a href="#3-实现-2" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>（1）迭代法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode sentinel = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 哨兵结点，为合并后链表头结点的前驱结点</span></span><br><span class="line">    ListNode curr = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr.next = l1 == <span class="keyword">null</span> ? l2 : l1; <span class="comment">// 某一链表已全部遍历时，直接插入尾部</span></span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>时间复杂度：迭代法和递归法均为 O(M+N)，其中 M 和 N 分别为链表长度。</li>
<li>空间复杂度：迭代法为 O(1)，递归法为 O(M+N)。</li>
</ul>
<hr>
<h4 id="面试题35-复杂链表的辅助"><a href="#面试题35-复杂链表的辅助" class="headerlink" title="面试题35. 复杂链表的辅助"></a>面试题35. 复杂链表的辅助</h4><h5 id="1-题目-6"><a href="#1-题目-6" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针<strong>指向链表中的任意节点或者 null</strong> 。</p>
<p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题35. 复杂链表的辅助</a></p>
<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">力扣-138. 复制带随机指针的链表</a></p>
<h5 id="2-思路-4"><a href="#2-思路-4" class="headerlink" title="2. 思路"></a>2. 思路</h5><ul>
<li><p>HashMap 辅助，<strong>O(N)</strong> 空间复杂度。</p>
<p>两次遍历链表。第一遍遍历时，复制所有节点，但不考虑 next 域和 random 域。第二次遍历时，填充新链表的 next 域和 random 域的值即可。</p>
</li>
<li><p>两次遍历，不使用 HashMap 辅助，<strong>O(1)</strong> 空间复杂度。</p>
<p>首次遍历时，逐个拷贝节点，<strong>新节点插入原节点后</strong>。再次遍历时，填充新节点的random域。最后，分离链表。</p>
</li>
</ul>
<h5 id="3-实现-3"><a href="#3-实现-3" class="headerlink" title="3. 实现"></a>3. 实现</h5><p>(1) HashMap 辅助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 记录新旧节点地址</span></span><br><span class="line">        <span class="comment">// 首次循环，复制所有节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node curr = head; curr!=<span class="keyword">null</span>; curr = curr.next)</span><br><span class="line">            map.put(curr, <span class="keyword">new</span> Node(curr.val));</span><br><span class="line">        <span class="comment">// 第二次循环，填充新链表的next域和random域</span></span><br><span class="line">        <span class="keyword">for</span>(Node curr = head; curr!=<span class="keyword">null</span>; curr = curr.next)&#123;</span><br><span class="line">            map.get(curr).next = map.get(curr.next);</span><br><span class="line">            map.get(curr).random = map.get(curr.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）原地实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拷贝节点，如 1-&gt;2-&gt;3-&gt;null 变成 1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null。</span></span><br><span class="line">        <span class="keyword">for</span>(Node curr = head; curr!=<span class="keyword">null</span>; curr = curr.next.next)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(curr.val);</span><br><span class="line">            newNode.next = curr.next;</span><br><span class="line">            curr.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改新节点的random域</span></span><br><span class="line">        <span class="keyword">for</span>(Node curr = head; curr!=<span class="keyword">null</span>; curr = curr.next.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.random!=<span class="keyword">null</span>)</span><br><span class="line">                curr.next.random = curr.random.next; <span class="comment">// 关键步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分离链表</span></span><br><span class="line">        Node newHead = head.next;</span><br><span class="line">        <span class="keyword">for</span>(Node curr = head; curr!=<span class="keyword">null</span> &amp;&amp; curr.next!=<span class="keyword">null</span>;)&#123;</span><br><span class="line">            Node p = curr.next;</span><br><span class="line">            curr.next = p.next;</span><br><span class="line">            curr = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<ul>
<li>两种算法的时间复杂度都是 O(N)。</li>
<li>空间复杂度：使用 HashMap 辅助，O(N)；原地方法，O(1)。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复习（一）：常用排序算法与单链表排序</title>
    <url>/2020/03/23/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>复习常用的排序算法，如冒泡排序、选择排序、插入排序、希尔排序、归并排序、堆排序、快速排序等。结合《剑指Offer》、LeetCode和面试题中涉及的单链表排序问题，使用多种排序算法分别实现单链表排序。</p>
<a id="more"></a>

<p>本文中，常见排序算法的分类之部分参考自<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a>，单链表排序算法为自行实现。</p>
<hr>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><h5 id="1-1-常用排序算法分类"><a href="#1-1-常用排序算法分类" class="headerlink" title="1.1 常用排序算法分类"></a>1.1 常用排序算法分类</h5><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<strong>O(N logN)</strong>，因此也称为<strong>非线性时间</strong>比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，<strong>以线性时间运行</strong>，因此也称为线性时间非比较类排序。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt></p>
<h5 id="1-2-算法性能总结"><a href="#1-2-算法性能总结" class="headerlink" title="1.2 算法性能总结"></a>1.2 算法性能总结</h5><p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" alt></p>
<blockquote>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p>
<p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面。</p>
<p>注：修改了原图中“希尔排序”的时间复杂度。</p>
</blockquote>
<h5 id="1-3-单链表排序总结"><a href="#1-3-单链表排序总结" class="headerlink" title="1.3 单链表排序总结"></a>1.3 单链表排序总结</h5><ul>
<li>对于冒泡、选择和插入排序，设置 <code>tail</code> 或 <code>start</code> 指针，标识<strong>内循环</strong>的终点或起点。</li>
</ul>
<hr>
<h4 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2 算法实现"></a>2 算法实现</h4><h5 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h5><p>重复地遍历数组，每次循环结束，当前最大值会“浮动”至数组尾部（或当前最小值“浮动”至数组头部），称之为冒泡。</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">               exch(arr, j, j+<span class="number">1</span>); <span class="comment">// 交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h5><blockquote>
<p>运行时间与输入数据无关，即使数组已有序，时间复杂度仍为O(N^2)。</p>
</blockquote>
<p>核心：寻找剩余元素的最小者，并将其放置在数组前端对应位置。</p>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i; <span class="comment">// 当前内循环最小值索引</span></span><br><span class="line">        <span class="comment">// 内循环从i开始，即[0,i-1]区间已有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h5><ul>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，<strong>在已经排序的元素序列中从后向前扫描</strong>。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个元素开始，该元素可以认为已经被排序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; (arr[j] &lt; arr[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：在内循环中，较大的元素向右移动，而不是频繁交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个元素开始，该元素可以认为已经被排序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描。</span></span><br><span class="line">        <span class="comment">// 通过内循环找到temp插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(; j&gt;<span class="number">0</span> &amp;&amp; temp &lt; arr[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h5><blockquote>
<p>基于插入排序，分为间隔为h的小序列，通过使小序列依次有序从而实现排序。</p>
</blockquote>
<ul>
<li><p>选择一个增量序列h，如1, 4, 13, 40, … 。</p>
</li>
<li><p>按增量序列个数k，对序列进行k趟排序。</p>
</li>
<li><p>每趟排序，根据对应的增量值h，将待排序列分割成若干长度为m的子序列，分别对各子表进行<strong>直接插入排序</strong>。当h=1时，完成排序。</p>
</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; len/<span class="number">3</span>)</span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 设置间隔h的递增序列为1，4，13，40，121，...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 在内循环中，较大的元素向右移动，而不是频繁交换。</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= h &amp;&amp; temp &lt; arr[j-h]; j-=h)</span><br><span class="line">                arr[j] = arr[j-h]; <span class="comment">// 较大元素向右移动，减少交换次数</span></span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a>2.5 快速排序</h5><blockquote>
<p>快速排序是一种采用<strong>递归、分治</strong>思想的、<strong>近似原地</strong>的、不稳定的排序方法，时间复杂度为O(NlgN)。</p>
</blockquote>
<p>基本思想：<strong>通过一趟排序将待排记录分隔成独立的两部分</strong>，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li>选取一个基准值（pivot），双指针分别从尾至左、从头至右遍历数组，直至找出首个<strong>大于基准值</strong> / <strong>小于基准值</strong>的元素，交换二者。循环至双指针相遇。</li>
<li>一次循环后，数组被分为两个部分，称之为分区（partition）。依靠选定的基准值一分为二。</li>
<li>递归地排序左右两个子数组。</li>
</ul>
<p><img src="/2020/03/23/算法复习（一）：常用排序算法与单链表排序/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt;= pivot &amp;&amp; j &gt; i)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= pivot &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[lo] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, lo, i-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h4 id="3-单链表排序"><a href="#3-单链表排序" class="headerlink" title="3. 单链表排序"></a>3. 单链表排序</h4><p><em>单链表的节点结构为</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	ListNode next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-单链表冒泡排序"><a href="#3-1-单链表冒泡排序" class="headerlink" title="3.1 单链表冒泡排序"></a>3.1 单链表冒泡排序</h5><p>使用辅助的 <code>tail</code> 指针标定每一次内循环的结束位置，且在内循环结束后将其置为前驱节点的索引，直至<code>tail==head</code> 时完成排序。</p>
<p>考虑到在最后一定次数的内循环中，链表已经有序。通过 <code>count</code> 交换次数计数器来判断是否链表是否已有序，以提高算法性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode tail = <span class="keyword">null</span>; <span class="comment">// 标记内循环的结束位置</span></span><br><span class="line">    <span class="keyword">while</span>(tail!=head) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录每次内循环时交换元素的次数</span></span><br><span class="line">        ListNode p = head; <span class="comment">// 内循环总是从头节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(p.next!=tail) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; p.next.val) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p.val;</span><br><span class="line">                p.val = p.next.val;</span><br><span class="line">                p.next.val = temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">// 内循环结束时，p指针位置是下一轮内循环tail指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) &#123; <span class="comment">// 经过一次内循环，count仍为0，说明未发生交换，即链表已有序。</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-2-单链表选择排序"><a href="#3-2-单链表选择排序" class="headerlink" title="3.2 单链表选择排序"></a>3.2 单链表选择排序</h5><p>使用辅助指针 <code>start</code> 标识内循环的起始节点，即 <code>head</code> 节点和 <code>start</code> 前驱节点之间的链表部分是有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode start = head;</span><br><span class="line">    <span class="keyword">while</span>(start.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode minNode = start; <span class="comment">// 当前内循环最小值节点</span></span><br><span class="line">        ListNode p = start.next; <span class="comment">// 内循环起始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; minNode.val) &#123;</span><br><span class="line">                minNode = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束内循环，交换元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = start.val;</span><br><span class="line">        start.val = minNode.val;</span><br><span class="line">        minNode.val = temp;</span><br><span class="line">        start = start.next; <span class="comment">// 每结束一次内循环，起始节点变为后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-3-单链表插入排序"><a href="#3-3-单链表插入排序" class="headerlink" title="3.3 单链表插入排序"></a>3.3 单链表插入排序</h5><p><code>tail</code> 指针标志着每一轮内循环的结束位置。如果 <code>tail</code> 指针指向的节点元素可以向前插入，则通过调用 insertNode 方法在相应位置<strong>插入节点</strong>，并调用 removeTail 方法<strong>移除原 tail 节点</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 辅助dummy指针，便于对头节点的操作</span></span><br><span class="line">    ListNode tail = head.next; <span class="comment">// 内循环结束节点</span></span><br><span class="line">    <span class="keyword">while</span>(tail!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode p = dummy; <span class="comment">// 内循环每次从头节点的前驱节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(p.next!=tail)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val &gt; tail.val)&#123;</span><br><span class="line">                insertNode(p, tail); <span class="comment">// 插入</span></span><br><span class="line">                tail = removeTail(p, tail); <span class="comment">// 移除旧节点tail</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// 返回头节点，注意此时的头节点不一定是原来的head！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝节点q，新节点为p的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(ListNode p, ListNode q)</span></span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(q.val);</span><br><span class="line">    newNode.next = p.next;</span><br><span class="line">    p.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">removeTail</span><span class="params">(ListNode p, ListNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p.next!=q)</span><br><span class="line">        p = p.next;</span><br><span class="line">    p.next = q.next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回下一轮循环的尾节点的前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-4-单链表快速排序"><a href="#3-4-单链表快速排序" class="headerlink" title="3.4 单链表快速排序"></a>3.4 单链表快速排序</h5><hr>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41190227/article/details/86600821</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之贪心法</title>
    <url>/2020/03/17/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法，求解问题时总是做出当前最优的选择，即求出局部最优解。通过每一步贪心选择，最终可得到问题的一个整体最优解。</p>
<a id="more"></a>

<p><strong>贪心算法不是对所有问题都能得到整体最优解</strong></p>
<p>贪心策略：无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<p><em>基本要素</em></p>
<p><strong>贪心选择</strong>：整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p>
<p>每一次的贪心选择就是将所求问题简化为规模更小的子问题，从顶向下、迭代地做出选择。</p>
<p><strong>最优子结构</strong>：问题的最优解包含子问题的最优解。</p>
<p>与DP不同的是，贪心算法对每个子问题都要作出最优选择，不能回退；动态规划则会依据之前的子问题的结果进行选择，可以回退。</p>
<p>如何实现？</p>
<p>从原问题的某一个初始解出发，逐步逼近给定的目标，直至算法终止。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题集（二）：动态规划问题</title>
    <url>/2020/03/15/LeetCode%E9%A2%98%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>总结在LeetCode刷题过程中遇见的动态规划求解的问题。</p>
<p>有关 DP 的详细介绍见<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五大常用算法之动态规划</a></p>
<a id="more"></a>

<h4 id="最大子序和问题"><a href="#最大子序和问题" class="headerlink" title="最大子序和问题"></a>最大子序和问题</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题-最大子序和</a>。</p>
<p><code>Kadane</code>算法求解最大子序和问题的分析见<a href="https://merlinhu0112.github.io/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/">动态规划和分治法求解最大子序和问题</a>。</p>
<h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：<code>[-2, 1, -3, 4, -1, 2, 1, -5, 4]</code></p>
<p>正确输出结果：<code>6</code></p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        currSum = Math.max((currSum+nums[i]), nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h5><ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">第300题-最长上升子序列</a></p>
<h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>用例：<code>[10, 9, 2, 5, 3, 7, 101, 18]</code></p>
<p>输出：<code>4</code></p>
<h5 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h5><p>用数组 <code>dp</code> 保存以数组 <code>nums</code> 下标 <code>0</code> 为起点、下标 <code>i</code> 为终点的局部区间最长上升子序列的长度，将其称为 <em>局部最长上升子序列长度</em>。</p>
<p>逐个更新 <code>dp</code> 数组。易知，计算 <code>dp[i]</code> 的值，若满足：</p>
<blockquote>
<p>0 &lt;= j &lt; i，且 nums[j] &lt; nums[i]</p>
</blockquote>
<p>即对于局部区间 <code>[0, j]</code>，元素 <code>nums[i]</code> 是满足上升条件的。</p>
<p> 状态转移方程为：</p>
<blockquote>
<p>dp[i] = max{ dp[j] } + 1， 0 &lt;= j &lt; i，且 nums[j] &lt; nums[i]</p>
</blockquote>
<h5 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// 保存不同索引位置处对应的局部最大上升子序列长度</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>); <span class="comment">// 局部最长上升子序列长默认为1，即假设完全不存在上升序列</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>; <span class="comment">// 全局最长上升子序列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双循环，逐个计算索引i位置处的最大上升子序列长度，最后求出全局最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="comment">// 只有当nums[i]大于nums[j]时，严格满足上升条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对内循环中的赋值语句的理解</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>若写成下式是<strong>错误的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为，索引 <code>j</code> 对应的局部最长上升子序列长度值，不一定是区间 <code>[0, i-1]</code> 中的最大值！</p>
<h5 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul>
<li>时间复杂度：O(N^2) </li>
<li>空间复杂度：O(N)</li>
</ul>
<hr>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h4><p>相关题目：<a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">第343题-整数拆分</a>，<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14-I.剪绳子</a>。</p>
<h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>题目：给定一个正整数 <code>n</code>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回可以获得的最大乘积。</p>
<p>条件：2 &lt;= n &lt;= 58 ，且 2 &lt;= m &lt;= n，其中 <code>m</code> 是划分的个数。</p>
<h5 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2. 分析"></a>2. 分析</h5><p>设数组 <code>dp</code> 中的任意元素 dp[i] 保存整数 <code>i</code> 对应的最大乘积，其中 i &gt;= 2。</p>
<p>边界条件为：</p>
<blockquote>
<p>dp[2] = 1</p>
</blockquote>
<p>其中 dp[0] 和 dp[1] 为无效参数，仅起到填充作用，以使 <code>dp</code> 数组的索引 <code>i</code> 与正整数 <code>n</code> 对应。</p>
<p>对于整数 <code>i</code> ，可将其划分为 <code>j</code> 和 <code>i-j</code> ，其中 1&lt;= j &lt; i。</p>
<p><code>j * (i-j)</code> 正是整数 <code>i</code> 拆分、求积的一种形式，但这不一定是最大值。因为对于由 <code>i</code> 划分得到的 <code>j</code> ，它对应的 <code>dp[j]</code> 不一定等于 <code>j</code>，即对整数 <code>j</code> 进一步划分，或许还能得到更大的乘积。</p>
<p>综上，应在 j * ( i - j ) 和 dp[j] * ( i - j ) 中选择较大者。</p>
<h5 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3. 实现"></a>3. 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            dp[i] = Math.max(Math.max((j*(i-j)), (dp[j]*(i-j))), dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-性能-1"><a href="#4-性能-1" class="headerlink" title="4. 性能"></a>4. 性能</h5><ul>
<li>时间复杂度：O(N^2) </li>
<li>空间复杂度：O(N)</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>（转）TCP为什么三次握手而不是两次握手？</title>
    <url>/2020/03/10/%EF%BC%88%E8%BD%AC%EF%BC%89TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<p>TCP连接时需要三次握手，那为什么是三次呢？两次可不可以呢？</p>
<p>在复习TCP连接与断开的知识时，查找资料发现此篇文章写得甚是详细，特意转载而来。</p>
<a id="more"></a>

<blockquote>
<p>原文标题：TCP 为什么三次握手而不是两次握手（正解版）</p>
<p>作者：萧萧冷</p>
<p>版权声明：本文为CSDN博主「萧萧冷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/lengxiao1993/article/details/82771768" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>
</blockquote>
<h4 id="一、大部分网络博客的错误解读"><a href="#一、大部分网络博客的错误解读" class="headerlink" title="一、大部分网络博客的错误解读"></a>一、大部分网络博客的错误解读</h4><p>首先需要声明的是，百度搜索到的大部分网络博客关于这个问题的解答都是不清晰或者不准确的。讨论这个问题的大部分博客都会引用《计算机网络》的内容：</p>
<blockquote>
<p>防止已失效的连接请求又传送到服务器端，因而产生错误。</p>
</blockquote>
<p>不幸的是，这种解释是不准确的。TCP 采用三次握手的原因其实非常简单，远没有大部分博客所描述的那样云山雾绕。</p>
<p><strong>这里先给出结论：</strong></p>
<ul>
<li><p>为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中， 哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。</p>
</li>
<li><p>如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。</p>
</li>
</ul>
<h4 id="二、先修知识"><a href="#二、先修知识" class="headerlink" title="二、先修知识"></a>二、先修知识</h4><p>TCP通信流程</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/1.jpg" alt></p>
<p>上图中的每一个箭头都代表着一次 TCP 数据包的发送。</p>
<p>需要注意的是，上图中出现的 <code>ACK = x +1</code> 的写法很容易让人误以为数据包中的 ACK 域的数据值被填成了 <code>y+1</code>。 <code>ACK = x+1</code> 的实际含义是：</p>
<ul>
<li>TCP 包的 ACK 标志位（1 bit）被置成了 <code>1</code>；</li>
<li>TCP 包的确认号（acknowledgement number ）的值为 <code>x+1</code> 。</li>
</ul>
<p>类似的，TCP 数据包中的 SYN 标志位，也容易与序号（sequence number）混淆，这点需要读者注意。</p>
<p>TCP 数据包结构图</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/2.jpg" alt></p>
<h4 id="三、为什么-TCP-需要握手这个操作"><a href="#三、为什么-TCP-需要握手这个操作" class="headerlink" title="三、为什么 TCP 需要握手这个操作"></a>三、为什么 TCP 需要握手这个操作</h4><p>在解答为什么 TCP 需要三次握手， 而不是两次之前，首先需要回答的问题是:</p>
<blockquote>
<p>为什么需要握手这个操作，能不能不握手？</p>
</blockquote>
<p>如果读者对比一下 UDP 的通信流程和 TCP 的通信流程，可以发现，在 UDP 协议中，是没有握手这个操作的。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/3.jpg" alt></p>
<p>这里就引出了 TCP 与 UDP 的一个基本区别，TCP 是可靠通信协议，而 UDP 是不可靠通信协议。</p>
<ul>
<li>TCP 的可靠性含义：接收方收到的数据是完整、有序、无差错的。</li>
<li>UDP 不可靠性含义：接收方接收到的数据可能存在部分丢失，顺序也不一定能保证。</li>
</ul>
<p>UDP 和 TCP 协议都是基于同样的互联网基础设施，且都基于 IP 协议实现，互联网基础设施中对于数据包的发送过程是会发生丢包现象的，为什么 TCP 就可以实现可靠传输，而 UDP 不行？</p>
<p>TCP 协议为了实现可靠传输，通信双方需要判断自己已经发送的数据包是否都被接收方收到，如果没收到，就需要重发。为了实现这个需求，很自然地就会<strong>引出序号（sequence number）</strong>和 <strong>确认号（acknowledgement number）</strong>的使用。</p>
<p>发送方在发送数据包（假设大小为 10 byte）时，同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后，就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包，序号从 510 开始” 。</p>
<p>这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到，需要重发。</p>
<h4 id="四、为什么需要三次握手，而非两次"><a href="#四、为什么需要三次握手，而非两次" class="headerlink" title="四、为什么需要三次握手，而非两次"></a>四、为什么需要三次握手，而非两次</h4><p>正如上文所描述的，为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始。由于 TCP 是一个双向通信协议，通信双方都有能力发送信息，并接收响应。因此，通信双方都需要随机产生一个初始的序列号，并且把这个起始值告诉对方。</p>
<p>于是，这个过程就变成了下面这样。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/4.jpg" alt></p>
<p>下面这个流程图描述的和上面一样，但是更加清楚的展示了 TCP 数据包标志位，以及数据域的命名来源。</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/5.jpg" alt></p>
<p>补充知识：有一位读者关注到了三次握手中，序列号变化的问题，让笔者临时想起了曾经困扰自己的一个问题：</p>
<ul>
<li>为什么三次握手最后一次握手中，在上面的示意图中回复的 <code>seq = x+1</code> 而不是 <code>x+2</code></li>
</ul>
<p>答案：</p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/6.jpg" alt></p>
<p><img src="/2020/03/10/（转）TCP为什么三次握手而不是两次握手？/7.jpg" alt></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>Three-way handshake</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题集（一）：O(1)时间复杂度的操作</title>
    <url>/2020/03/09/LeetCode%E9%A2%98%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AO(1)%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>LeetCode 刷题过程中遇见 “O(1) 时间复杂度的操作” 系列问题，总结一下。</p>
<a id="more"></a>

<h4 id="一、最大队列"><a href="#一、最大队列" class="headerlink" title="一、最大队列"></a>一、最大队列</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">力扣-《剑指Offer》-面试题59 - II. 队列的最大值</a></p>
<h5 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请定义一个队列并实现函数 max_value 得到队列里的最大值。</p>
<ul>
<li>要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 <code>O(1)</code>。</li>
<li>若队列为空，pop_front 和 max_value 需要返回 -1。</li>
</ul>
<h5 id="2-图解"><a href="#2-图解" class="headerlink" title="2. 图解"></a>2. 图解</h5><p>队列 <code>queue</code> 实现 <code>MaxQueue</code> 的基本结构，双端队列 <code>deque</code> 保存<strong>最大值序列</strong>（降序）。</p>
<p>当元素 <code>ele</code> 入队时，分别进入 <code>queue</code> 和 <code>deque</code>。</p>
<ul>
<li>入 <code>queue</code> 时，元素 <code>ele</code> 直接入队。</li>
<li>入 <code>deque</code> 时，先从队尾开始寻找所有比<code>ele</code> 小的元素，直至遇见首个大于 <code>ele</code> 的元素或已经到了队头。随后从队尾开始，移除所有小于 <code>ele</code> 的元素并将 <code>ele</code> 入队。</li>
</ul>
<p>（图源：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">如何解决 O(1) 复杂度的 API 设计题</a>）</p>
<p><img src="/2020/03/09/LeetCode题集（一）：O(1)时间复杂度的操作/1.gif" alt></p>
<h5 id="3-代码实现："><a href="#3-代码实现：" class="headerlink" title="3. 代码实现："></a>3. 代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 队列queue，实现MaxQueue的基本结构</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">	<span class="comment">// 双端队列（可两端出、入队），用于记录最大值递减序列</span></span><br><span class="line">	<span class="keyword">private</span> Deque&lt;Integer&gt; deque;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">         deque = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> deque.size() &gt; <span class="number">0</span> ? deque.peek() : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	queue.add(value);</span><br><span class="line">    	<span class="keyword">while</span>(deque.size() &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &lt; value ) &#123;</span><br><span class="line">    		<span class="comment">// 移除双端队列后部小于value的元素，直至遇见一个</span></span><br><span class="line">    		<span class="comment">// 大于value的元素或双端队列为空时</span></span><br><span class="line">    		deque.pollLast();</span><br><span class="line">    	&#125;</span><br><span class="line">    	deque.add(value); <span class="comment">// 双端队列队尾入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取队首元素，若队列为空则为-1</span></span><br><span class="line">    	<span class="keyword">int</span> headEle = queue.size() &gt; <span class="number">0</span> ? queue.poll() : -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(deque.size() &gt; <span class="number">0</span> &amp;&amp; deque.peek() == headEle) &#123;</span><br><span class="line">    		deque.poll();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> headEle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二、最小栈"><a href="#二、最小栈" class="headerlink" title="二、最小栈"></a>二、最小栈</h4><p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">力扣-155. 最小栈</a></p>
<p><a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">力扣-《程序员面试金典》-面试题 03.02. 栈的最小值</a></p>
<h5 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>请设计一个栈，除了常规栈支持的 pop 与 push 函数以外，还支持 min 函数，该函数返回栈元素中的最小值。执行 push、pop 和 min 操作的时间复杂度必须为 <code>O(1)</code> 。</p>
<h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>类似最大队列的实现。</p>
<p>利用辅助栈保存最小值集合，当前待压栈元素若不小于辅助栈栈顶元素，将该元素压入辅助栈中；否则，辅助栈不变。</p>
<h5 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack; <span class="comment">// 存放元素</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; auxStack; <span class="comment">// 辅助栈，存放最小值序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        auxStack  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="comment">// 辅助栈不为空且栈顶元素小于x时，x不进入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span>(!auxStack.empty() &amp;&amp; auxStack.peek() &lt; x )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，x被压入辅助栈</span></span><br><span class="line">        auxStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小栈栈顶元素等于辅助栈栈顶元素时，说明当前最小值将被弹栈，</span></span><br><span class="line">        <span class="comment">// 因此辅助栈栈顶元素同时弹栈</span></span><br><span class="line">        <span class="keyword">int</span> temp = stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(auxStack.peek()==temp)&#123;</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小栈栈顶元素弹栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!auxStack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> auxStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="三、LRU缓存"><a href="#三、LRU缓存" class="headerlink" title="三、LRU缓存"></a>三、LRU缓存</h4><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">力扣-《程序员面试金典》-面试题 16.25. LRU缓存</a></p>
<p><strong>LRU缓存</strong>：Least Recently Used，即最近最久未使用的，是一种常见的缓存淘汰算法。当存储的数据总量达到缓存限制时，删除最久未使用过的数据。</p>
<h5 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h5><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值（允许你插入和检索特定键对应的值），并在初始化时指定最大容量。</p>
<p>当缓存被填满时，它应该删除最近最少使用的项目。</p>
<p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<h5 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2. 思路"></a>2. 思路</h5><p>为实现常数时间内 get 和 put 键值对，采用<strong>哈希表</strong>存储，如 HashMap。</p>
<p>在操作键值对的同时，需要额外维护使用键值对的先后顺序，且维护也应在常数时间内完成。<strong>双向链表</strong>是一个不错的选择。</p>
<p>双向链表维护访问先后顺序。其头结点（或尾结点）表示最近最久未使用过的数据。（以尾结点表示最近最久未使用为例）</p>
<ul>
<li>插入新的键值对时，将 <code>key</code> 存入双向链表的头结点，表示最近被使用的数据。</li>
<li>当更新键值对时，将 <code>key</code> 从双向链表相应位置移向头结点。</li>
<li>当缓存已满时，移除双向链表的尾结点并移除散列表中对应的键值对即可。</li>
</ul>
<p>上述三种操作，第一种和第三种均很容易在常数时间内实现，而第二种需要额外的辅助才能实现O(1)的时间复杂度，因为双向链表查找的时间复杂度为 O(N)。</p>
<p>Java提供的 <code>java.util.LinkedHashMap</code> 基于 <code>HashMap</code> 和双链表很容易实现LRU缓存。</p>
<h5 id="3-基于LinkedHashMap（有序字典）的实现"><a href="#3-基于LinkedHashMap（有序字典）的实现" class="headerlink" title="3. 基于LinkedHashMap（有序字典）的实现"></a>3. 基于LinkedHashMap（有序字典）的实现</h5><p>Java提供的 LinkedHashMap 类默认按照键值对插入顺序维护双向链表，同时也提供一个特殊的构造函数，以实现按访问顺序维护双向链表。</p>
<ul>
<li>initialCapacity：初始化容量</li>
<li>loadFactor：加载因子</li>
<li>accessOrder：true 表示按访问顺序，false 表示按插入顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 LinkedHashMap 类提供的 removeEldestEntry 方法默认返回 false，因此需要重写该方法，并指定删除最久未使用数据的规则（如当数据量超过缓存容量时）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码实现</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> MAX_CACHE_SIZE; <span class="comment">// 缓存容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    	MAX_CACHE_SIZE = capacity;</span><br><span class="line">        <span class="comment">// 初始容量根据缓存容量和加载因子计算得到，不应设置为等于缓存容量。</span></span><br><span class="line">        <span class="comment">// 若初始容量被设置为缓存容量，易导致rehash操作发生，降低算法性能。</span></span><br><span class="line">    	map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;((<span class="keyword">int</span>) Math.ceil(capacity / <span class="number">0.75f</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line">    		<span class="meta">@Override</span></span><br><span class="line">    		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">    			<span class="keyword">return</span> size() &gt; MAX_CACHE_SIZE;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	Integer value = map.get(key);</span><br><span class="line">    	<span class="keyword">return</span> value == <span class="keyword">null</span> ? -<span class="number">1</span> : value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、基于哈希表和双向链表的实现"><a href="#4、基于哈希表和双向链表的实现" class="headerlink" title="4、基于哈希表和双向链表的实现"></a>4、基于哈希表和双向链表的实现</h5><p>如思路部分所述，可使用双向链表保存访问键值对的顺序信息。</p>
<p>双向链表插入操作的时间复杂度为O(1)，但查询操作的时间复杂度为O(N)。若被访问的键值对对应的链表结点位于链表中部，那么查找操作将时总时间复杂度提升为O(N)。那如何解决这一问题呢？</p>
<p>参照 LinkedHashMap 的源码实现。将键值对保存在链表结点中，哈希表保存 <strong>key 和 结点内存地址</strong>，这样，定位至相应结点的时间复杂度就被优化为O(1)。</p>
<p><em>结点结构如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>哈希表结构如下</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br></pre></td></tr></table></figure>

<p>（图源：<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">LRU 缓存机制</a>）</p>
<p><img src="/2020/03/09/LeetCode题集（一）：O(1)时间复杂度的操作/2.jpg" alt></p>
<p>头尾指针为辅助指针。</p>
<p><em>算法实现</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 双向链表的结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> key;</span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node prev;</span><br><span class="line">		Node next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Node head; <span class="comment">// 辅助的头指针</span></span><br><span class="line">	<span class="keyword">private</span> Node tail; <span class="comment">// 辅助的尾指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在头部插入结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeadNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		node.prev = head;</span><br><span class="line">		node.next = head.next;</span><br><span class="line">		head.next.prev = node;</span><br><span class="line">		head.next = node;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移除尾结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">removeTailNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node target = tail.prev;</span><br><span class="line">		removeNode(target);</span><br><span class="line">		<span class="comment">// 返回被移除的结点指针，是为了再移除尾结点后，</span></span><br><span class="line">		<span class="comment">// 从哈希表中删除对应的记录。</span></span><br><span class="line">		<span class="keyword">return</span> target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node pNode = node.prev;</span><br><span class="line">		Node qNode = node.next;</span><br><span class="line">		pNode.next = qNode;</span><br><span class="line">		qNode.prev = pNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 移动结点至头结点位置</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先移除，再插入</span></span><br><span class="line">		removeNode(node);</span><br><span class="line">		insertHeadNode(node);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, Node&gt; cache;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 加载因子</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> MAX_CACHE_SIZE; <span class="comment">// 缓存容量;</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.ceil(capacity / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>; <span class="comment">// 哈希表初始容量</span></span><br><span class="line">    	cache = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    	MAX_CACHE_SIZE = capacity;</span><br><span class="line">    	<span class="comment">// 初始化头尾指针</span></span><br><span class="line">    	head = <span class="keyword">new</span> Node();</span><br><span class="line">    	tail = <span class="keyword">new</span> Node();</span><br><span class="line">    	head.next = tail;</span><br><span class="line">    	tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	Node node = cache.get(key);</span><br><span class="line">    	<span class="keyword">if</span>(node==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	moveToHead(node); <span class="comment">// 更新访问记录</span></span><br><span class="line">    	<span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	Node node = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">// 键已存在</span></span><br><span class="line">    	<span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">    		node = cache.get(key);</span><br><span class="line">    		node.value = value;</span><br><span class="line">    		moveToHead(node);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 键不存在</span></span><br><span class="line">    	node = <span class="keyword">new</span> Node();</span><br><span class="line">    	node.key = key;</span><br><span class="line">    	node.value = value;</span><br><span class="line">    	insertHeadNode(node); <span class="comment">// 插入头结点</span></span><br><span class="line">    	cache.put(key, node);</span><br><span class="line">    	<span class="comment">// 还需判断哈希表容量是否已超过缓存容量</span></span><br><span class="line">    	<span class="keyword">if</span>(cache.size() &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">    		Node target = removeTailNode(); <span class="comment">// 移除尾结点</span></span><br><span class="line">    		cache.remove(target.key);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h4>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Max Queue</tag>
        <tag>Min Stack</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是深拷贝，什么是浅拷贝？</title>
    <url>/2020/03/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F/</url>
    <content><![CDATA[<p>浅拷贝（shallow copy）与深拷贝（deep copy）有何区别？浅克隆与深克隆又有何区别？Object基类中受保护的（protected）clone( )方法与Cloneable接口又有何联系？</p>
<a id="more"></a>

<h3 id="一、克隆对象"><a href="#一、克隆对象" class="headerlink" title="一、克隆对象"></a>一、克隆对象</h3><h4 id="1-建立副本"><a href="#1-建立副本" class="headerlink" title="1. 建立副本"></a>1. 建立副本</h4><p>在Java中，对于<strong>基本数据类型</strong>的变量，为其建立副本的过程较为简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 基本数据类型之一的int变量</span></span><br><span class="line">b = a; <span class="comment">// 变量b为变量a的副本，值与a相同，b = 1</span></span><br></pre></td></tr></table></figure>

<p>如果为<strong>引用类型</strong>的变量建立副本，会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// get/set方法省略</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"name = "</span> + name + <span class="string">", age = "</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为 People 类实例化一个新对象 <code>aPeople</code>，并将其初始化。为 <code>aPeople</code> 建立副本，为 <code>bPeople</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCloneDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">		aPeople.print();</span><br><span class="line">		People bPeople = aPeople; <span class="comment">// 副本</span></span><br><span class="line">		bPeople.print();</span><br><span class="line">		bPeople.setAge(<span class="number">18</span>); <span class="comment">// 修改</span></span><br><span class="line">		aPeople.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试修改 <code>bPeople</code> ，发现 <code>aPeople</code> 的成员变量也随之发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">aPeople: name = Merlin, age = <span class="number">18</span>; <span class="comment">// age发生变化</span></span><br></pre></td></tr></table></figure>

<p>对象 <code>aPeople</code> 的 <code>age</code> 属性发生变化的原因在于， <code>People bPeople = aPeople</code> 语句是将 <code>aPeople</code> 的<strong>内存地址</strong>赋予 <code>bPeople</code> 。</p>
<p><code>aPeople</code> 和 <code>bPeople</code> <strong>同时指向堆内存中的同一地址</strong>。修改变量 <code>bPeople</code> 引用的对象的属性，会立即被 <code>aPeople</code> 看见。（注：字符串 <code>Merlin</code> 保存在常量池中，在此简化之。）</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/1.jpg" alt></p>
<h4 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="2. Object类的clone方法"></a>2. Object类的clone方法</h4><p>如上所述，为引用类型变量 <code>aPeople</code> 进行复制对象引用并赋值给 <code>bPeople</code> 的操作后，无法单独操作两个对象。</p>
<p>那么，如何在保留一个对象原有状态数据的前提下对新对象进行操作呢？</p>
<p><strong>克隆对象</strong>：用新对象保存当前对象的状态，在克隆的副本上对对象进行操作。这与 <code>new</code> 操作得到一个初始化的新对象是不同的。 </p>
<p>在Java的Object基类中，提供一种受保护的（protected）的<strong>clone()</strong>方法，实现克隆对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>基于JDK 1.8的源码，对clone()方法有如下规定：</p>
<p>一般地，对任意对象，以下三种语句均应返回 <code>true</code>，但都无强制性规定。</p>
<blockquote>
<ul>
<li>x .clone( ) != x ;</li>
<li>x .clone( ) .getClass( ) == x .getClass ;</li>
<li>x .clone( ) .equals(x) ; </li>
</ul>
</blockquote>
<h4 id="3-克隆对象演示"><a href="#3-克隆对象演示" class="headerlink" title="3. 克隆对象演示"></a>3. 克隆对象演示</h4><p>数组已实现 Cloneable 接口，可直接使用 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] cloneArray = array.clone(); <span class="comment">// 数组均实现了Cloneable接口</span></span><br><span class="line">    System.out.println(array); <span class="comment">// 打印原始数组的内存地址</span></span><br><span class="line">    System.out.println(cloneArray); <span class="comment">// 打印克隆数组的内存地址</span></span><br><span class="line">    System.out.println(array==cloneArray);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] bArray = array;</span><br><span class="line">    System.out.println(bArray); <span class="comment">// 打印复制对象引用并赋值给新对象的内存地址</span></span><br><span class="line">    System.out.println(array==bArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为对象 <code>array</code> 复制对象引用并赋值给 <code>bArray</code> ，及克隆对象 <code>array</code> 得到 <code>cloneArray</code> 。</p>
<p>输出结果显示，克隆对象指向<strong>新的内存地址</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>db9742 <span class="comment">// 原始对象内存地址</span></span><br><span class="line"><span class="number">6</span>d06d69c <span class="comment">// 克隆对象内存地址</span></span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">@<span class="number">15</span>db9742 <span class="comment">// 复制对象引用并赋值给新对象</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/2.jpg" alt></p>
<h3 id="二、浅克隆和深克隆"><a href="#二、浅克隆和深克隆" class="headerlink" title="二、浅克隆和深克隆"></a>二、浅克隆和深克隆</h3><blockquote>
<p>浅克隆（浅拷贝）与深克隆（深拷贝）</p>
</blockquote>
<h4 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1. 浅克隆"></a>1. 浅克隆</h4><p>仅支持拷贝<strong>基本数据类型的成员变量</strong>：对基本数据类型的成员变量，复制<strong>值副本</strong>给克隆对象；对引用类型的成员变量，<strong>仅复制内存地址</strong>给克隆对象。</p>
<p><em>浅克隆代码示例</em></p>
<p>基于前述 People 类，必须实现 Cloneable 接口，重写 clone() 方法。注意：</p>
<ul>
<li>提高方法的访问权限，以便包外访问。</li>
<li>调用父类（Object类）的clone方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码同前</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">// 实现标记接口Cloneable，重写Object类的</span></span><br><span class="line">	<span class="comment">// clone方法，提高访问权限，调用父类的clone方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		People people = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改克隆对象 <code>bPeople</code> 的属性，不影响原始对象 <code>aPeople</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    System.out.println(aPeople);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    <span class="comment">// 尝试修改bPeople对象</span></span><br><span class="line">    bPeople.setAge(<span class="number">18</span>); </span><br><span class="line">    bPeople.print();</span><br><span class="line">    System.out.println(bPeople);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">aPeople地址：<span class="number">15</span>db9742</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">18</span>;</span><br><span class="line">bPeople地址：<span class="number">6</span>d06d69c <span class="comment">// 克隆后，地址发生了改变</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，拷贝对象 <code>aPeople</code>（浅克隆）时，在堆内存中新开辟了一块内存空间以存放新的对象，并将克隆对象 <code>bPeople</code> 指向该引用。基本数据类型的属性 <code>age</code> 的值被复制到新的对象中，而引用类型的属性<strong>仅复制内存地址</strong>。</p>
<p>修改 <code>bPeople</code> 对象的属性 <code>age</code> 时，仅修改内存地址为 <code>6d06d69c</code> 的对象，不影响原始对象 <code>aPeople</code>。</p>
<p>在浅克隆时，修改克隆对象引用类型的属性时可能会影响到原始对象。在此例中，String 是不可变对象，属特殊情况。 </p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/3.jpg" alt></p>
<h4 id="2-浅克隆在面对引用变量时面临的问题"><a href="#2-浅克隆在面对引用变量时面临的问题" class="headerlink" title="2. 浅克隆在面对引用变量时面临的问题"></a>2. 浅克隆在面对引用变量时面临的问题</h4><p>如前所示，在浅克隆时，修改克隆对象引用类型的属性（不可变的类型除外）时可能会影响到原始对象。</p>
<p>在 People 类中添加引用类型属性 <code>city</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// get/set，构造方法均略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新 clone() 方法，实现浅克隆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> City city; <span class="comment">// 引用类型的成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		People people = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			people = (People) <span class="keyword">super</span>.clone(); <span class="comment">// 浅克隆</span></span><br><span class="line">		&#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">    <span class="comment">// 修改city变量</span></span><br><span class="line">    city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing; <span class="comment">// 修改bPeople影响了aPeople</span></span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br></pre></td></tr></table></figure>

<p>可见，修改克隆对象 <code>bPeople</code> 的<strong>可变引用类型的成员变量</strong>，影响了原始对象 <code>aPeople</code> 。内存示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/4.jpg" alt></p>
<h4 id="3-深克隆"><a href="#3-深克隆" class="headerlink" title="3. 深克隆"></a>3. 深克隆</h4><p>支持拷贝<strong>基本类型和引用类型的成员变量</strong>：对基本数据类型和引用类型的成员变量，都是复制值副本给克隆对象。</p>
<p>深克隆示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/5.jpg" alt></p>
<p>深克隆与浅克隆的区别在于，对<strong>可变的引用类型的成员变量，深克隆时为其开辟新的内存空间，浅克隆时仅复制内存地址</strong>。</p>
<blockquote>
<p>这里需要注意 name 属性！该属性为 String 类型，是不可变类型。因而克隆对象和原始对象的 name 变量保存的是同一内存地址。</p>
</blockquote>
<p><em>深克隆代码实现</em></p>
<p>对可变的引用类型，也要实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 其余同前</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		City city = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			city = (City) <span class="keyword">super</span>.clone(); <span class="comment">// 浅克隆</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> city;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写 People 类的 Clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People people = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">        people.city = (City) city.clone(); <span class="comment">// 深克隆</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心在于：</p>
<blockquote>
<p>people.city = (City) city.clone();</p>
</blockquote>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">    <span class="comment">// 修改city变量</span></span><br><span class="line">    city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    bPeople.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai; <span class="comment">// 独立修改</span></span><br></pre></td></tr></table></figure>

<p>修改过程的内存示意图如下：</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/6.jpg" alt></p>
<h4 id="4-浅克隆时String类型的特殊性"><a href="#4-浅克隆时String类型的特殊性" class="headerlink" title="4. 浅克隆时String类型的特殊性"></a>4. 浅克隆时String类型的特殊性</h4><p>String 属于不可变类型，从源码可看出其未实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure>

<p>对于第二章第一小节提及的 People 类，其拥有 <code>name</code> 和 <code>age</code> 两个属性。 <code>name</code> 属性为 String 类型。克隆对象 <code>aPeople</code> 得到 <code>bPeople</code>，在内存中的示意图如下。</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/7.jpg" alt></p>
<p>字符串 <code>Merlin</code> 保存在常量池中，变量 <code>name</code> 保存的是字符串的内存地址。</p>
<p>现在来看看修改 <code>bPeople</code> 的 <code>name</code> 属性会发生什么！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>);</span><br><span class="line">    aPeople.print();</span><br><span class="line">    System.out.println(aPeople);</span><br><span class="line">    People bPeople = (People) aPeople.clone();</span><br><span class="line">    bPeople.setName(<span class="string">"hujun"</span>); <span class="comment">// 修改bPeople的name属性</span></span><br><span class="line">    bPeople.print();</span><br><span class="line">    System.out.println(bPeople);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>;</span><br><span class="line">aPeople地址：<span class="number">15</span>db9742</span><br><span class="line">bPeople: name = hujun, age = <span class="number">25</span>; <span class="comment">// 独立修改了bPeople</span></span><br><span class="line">bPeople地址：<span class="number">6</span>d06d69c</span><br></pre></td></tr></table></figure>

<p><strong>修改克隆对象的 String 类型引用不影响原始对象！！！</strong></p>
<p>前述关于浅/深克隆的差异，核心在于<strong>是否仅复制引用类型变量的内存地址</strong>。String 属于不可变的引用类型，且未实现 Cloneable 接口，因此 String 类型的变量<strong>只允许被复制内存地址</strong>。</p>
<p>当修改克隆对象 <code>bPeople</code> 的 <code>name</code> 属性时，虚拟机会在常量池中另辟地址，保存字符串 <code>hujun</code> ，并将新的内存地址赋予克隆对象 <code>bPeople</code> 的 <code>name</code>  属性。</p>
<p>内存示意图如下。</p>
<p><img src="/2020/03/06/什么是深拷贝，什么是浅拷贝？/8.jpg" alt></p>
<h3 id="三、两种实现深克隆方式的差异"><a href="#三、两种实现深克隆方式的差异" class="headerlink" title="三、两种实现深克隆方式的差异"></a>三、两种实现深克隆方式的差异</h3><h4 id="1-clone方法"><a href="#1-clone方法" class="headerlink" title="1. clone方法"></a>1. clone方法</h4><p>实现Cloneable接口，重写Object类的clone()方法，并适当提高重写的clone()方法的访问权限</p>
<p><strong>问题：</strong>如上代码所示，在 People 类中存在引用类型 <code>City</code>，因此在实现深克隆时，首先需要对City类实现浅克隆，随后再实现深克隆。<strong>克隆过程是嵌套的</strong>。</p>
<p>对于多层嵌套的引用类型，这一方法显然很麻烦。</p>
<p>采用序列化可简化深度克隆过程。</p>
<h4 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h4><p>City 类实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 删除clone()方法，其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>People 类实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 删除clone()方法，其余同前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    City city = <span class="keyword">new</span> City(<span class="string">"Shanghai"</span>);</span><br><span class="line">    People aPeople = <span class="keyword">new</span> People(<span class="string">"Merlin"</span>, <span class="number">25</span>, city);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        People bPeople = MyCloneUtil.deepClone(aPeople);</span><br><span class="line">        aPeople.print();</span><br><span class="line">        bPeople.print();</span><br><span class="line">        <span class="comment">// 修改city变量</span></span><br><span class="line">        city.setCity(<span class="string">"Beijing"</span>);</span><br><span class="line">        aPeople.print();</span><br><span class="line">        bPeople.print();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br><span class="line">aPeople: name = Merlin, age = <span class="number">25</span>, city = Beijing;</span><br><span class="line">bPeople: name = Merlin, age = <span class="number">25</span>, city = Shanghai;</span><br></pre></td></tr></table></figure>

<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>1、为什么要实现克隆？</p>
<p>想对一个对象进行处理，又想保留原有的状态数据进行接下来的操作，这就需要克隆。</p>
<p>Java语言中克隆针对的是类的实例。</p>
<p>2、浅克隆与深克隆的区别？</p>
<p>浅克隆：对基本数据类型的成员变量，复制值副本给克隆对象；对引用类型的成员变量，仅复制内存地址给克隆对象。</p>
<p>深克隆：对基本数据类型和引用类型的成员变量，都是复制值副本给克隆对象。</p>
<p>3、浅克隆时，若引用类型为不可变类型，浅克隆过程也是安全的！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Clone</tag>
        <tag>Shallow Copy</tag>
        <tag>Deep Copy</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配之BM、KMP算法</title>
    <url>/2020/03/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBM%E3%80%81KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配算法，给定主串（string）和模式串（pattern），要求返回模式串在主串中首次出现的位置，若无则返回 <code>-1</code> 。比如主串为 <code>abjdefoahs</code> ，模式串为 <code>def</code> ，算法返回结果为 <code>3</code> 。又比如主串为 <code>abjdfeoahs</code>，模式串为 <code>wyz</code> ，算法返回结果为 <code>-1</code> 。</p>
<p>常见的字符串匹配算法有：BF（Brute Force）、RK（Robin-Karp）、<strong>KMP</strong>、BM（Boyer Moore）、Sunday等。</p>
<a id="more"></a>

<h3 id="一、BM算法"><a href="#一、BM算法" class="headerlink" title="一、BM算法"></a>一、BM算法</h3><p>在<a href>字符串匹配之BF、RK算法</a>部分已学习了BF、RK两种算法。</p>
<p>BF算法过于暴力，时间复杂度较高。</p>
<p>RK算法针对BF算法进行了优化，在较好的示例中时间复杂度较好。但RK算法不稳定，当样本哈希冲突严重时，RK算法一路退化至BF算法。</p>
<p>本小节学习的BM算法时间复杂度仅为 <code>O( )</code>，且稳定，常用于文本编辑器中的查找功能。</p>
<p>在BM算法中，有两个非常重要的概念：<strong>坏字符规则</strong> 和 <strong>好后缀规则</strong>。</p>
<h4 id="1-坏字符规则"><a href="#1-坏字符规则" class="headerlink" title="1. 坏字符规则"></a>1. 坏字符规则</h4><p>坏字符规则是指，对于模式串和等长的主串子串，子串从右向左出现的第一个不与模式串对应位置字符匹配的子串字符，称之为坏字符。<strong>根据坏字符在模式串中是否出现，将模式串移动不等距离</strong>。</p>
<p>在第一轮中，从右向左第一个字符 <code>d</code> 就是坏字符。随后在模式串中同样地<strong>从左向右</strong>找到首个字符d。移动模式串不再像BF/RK算法那样单次移动一位，而是直接<strong>将坏字符对齐</strong>。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_1.jpg" alt></p>
<p>第二轮与第一轮相似。对比前两轮可发现，<strong>每轮移动模式串的距离不一定是相等的！</strong>这与坏字符的位置有关。</p>
<p>正是这一特性，有效降低了算法的比较次数，提高了性能。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_2.jpg" alt></p>
<p>第三轮类似。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_3.jpg" alt></p>
<p>第四轮中遇见<strong>模式串中不存在坏字符</strong>的情况，这时直接<strong>将模式串移动至主串子串的坏字符下一位</strong>。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_4.jpg" alt></p>
<p>第五轮类似。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_5.jpg" alt></p>
<p>第六轮，顺利完成匹配。</p>
<p><img src="/2020/03/06/字符串匹配之BM、KMP算法/BM_Algorithm_6.jpg" alt></p>
<p>坏字符规则代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">boyerMoore</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时，主串和模式串从0至pattern.length-1位一一对应</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 模式串对应主串的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= (m-n)) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找坏字符，其中坏字符位于主串</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(string.charAt(start+i) != pattern.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未找到坏字符，即一一匹配，返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到坏字符，确定模式串移动距离</span></span><br><span class="line">        <span class="keyword">int</span> badCharIndex = findBadCharacter(string.charAt(start+i), pattern, i); <span class="comment">// 模式串中寻找坏字符从i-1开始</span></span><br><span class="line">        <span class="comment">// 计算坏字符产生的位移</span></span><br><span class="line">        <span class="keyword">int</span> offset = badCharIndex &gt;= <span class="number">0</span> ? i-badCharIndex : i+<span class="number">1</span>;</span><br><span class="line">        start += offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> badChar 坏字符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 坏字符索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串中坏字符的位置，不存在则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBadCharacter</span><span class="params">(<span class="keyword">char</span> badChar, String pattern, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>( badChar == (pattern.charAt(i)) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://blog.csdn.net/bjweimengshu/article/details/104368394" target="_blank" rel="noopener">漫画：如何优化 “字符串匹配算法”？</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String Matching</tag>
        <tag>BM</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配之BF、RK算法</title>
    <url>/2020/03/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E3%80%81RK%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>字符串匹配算法，给定主串（string）和模式串（pattern），要求返回模式串在主串中首次出现的位置，若无则返回 <code>-1</code> 。比如主串为 <code>abjdefoahs</code> ，模式串为 <code>def</code> ，算法返回结果为 <code>3</code> 。又比如主串为 <code>abjdfeoahs</code>，模式串为 <code>wyz</code> ，算法返回结果为 <code>-1</code> 。</p>
<p>常见的字符串匹配算法有：BF（Brute Force）、RK（Robin-Karp）、<strong>KMP</strong>、BM（Boyer Moore）、Sunday等。</p>
<a id="more"></a>

<h3 id="一、BF算法"><a href="#一、BF算法" class="headerlink" title="一、BF算法"></a>一、BF算法</h3><p>遇到任何困难，都不要怕，先试试暴力法！</p>
<h4 id="1-BF算法流程："><a href="#1-BF算法流程：" class="headerlink" title="1. BF算法流程："></a>1. BF算法流程：</h4><p>在前三轮中，模式串首位字符与主串对应位置字符不匹配，将模式串“向右移动一位”。在第四轮匹配中，模式串的首位字符与主串对应位置的字符匹配，则继续比较第二位，直到完成全部匹配。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/BF_Algorithm.jpg" alt></p>
<h4 id="2-BF算法实现："><a href="#2-BF算法实现：" class="headerlink" title="2. BF算法实现："></a>2. BF算法实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bruteForce</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=((string.length())-(pattern.length())); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(string.charAt(i+j) != pattern.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-BF算法的性能"><a href="#3-BF算法的性能" class="headerlink" title="3. BF算法的性能"></a>3. BF算法的性能</h4><p>BF算法不需要前期预处理，它的时间复杂度取决于内外循环，为 <code>O ( ( m - n + 1 ) * n ) = O ( m * n )</code> 。其中， <code>m</code> 为主串长度， <code>n</code> 为 模式串长度。</p>
<hr>
<h3 id="二、RK算法"><a href="#二、RK算法" class="headerlink" title="二、RK算法"></a>二、RK算法</h3><p>BF算法在最坏情况下，外层循环执行 <code>m - n + 1</code> 次，内层循环执行 <code>n</code> 次。RK（Robin-Karp）算法利用字符串本身，通过<strong>比较字符串哈希值</strong> 和 <strong>逐位字符匹配</strong> 相结合的方式，提高算法性能。</p>
<h4 id="1-RK算法流程"><a href="#1-RK算法流程" class="headerlink" title="1. RK算法流程"></a>1. RK算法流程</h4><h5 id="1-1-计算模式串哈希值以及首次计算部分主串哈希值"><a href="#1-1-计算模式串哈希值以及首次计算部分主串哈希值" class="headerlink" title="1.1 计算模式串哈希值以及首次计算部分主串哈希值"></a>1.1 计算模式串哈希值以及首次计算部分主串哈希值</h5><p>计算长度为 <code>n</code> 的模式串的哈希值。</p>
<p>截取主串 <code>[0, n-1]</code> 段，<strong>首次</strong>计算部分主串哈希值</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_1.jpg" alt></p>
<p>那么如何计算哈希值呢？</p>
<p>（1）按位相加</p>
<p>按位相加意指将字符串 <code>a - z</code> 视为 <code>0 - 25</code> ，取每一位字符的”和”。</p>
<p>示例如图：</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_2.jpg" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashcode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里采用最简单的哈希值计算方式：</span></span><br><span class="line">    <span class="comment">// 把a当做0，把b当中1，把c当中2.....然后按位相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        hashcode += str.charAt(i)-<span class="string">'a'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）转换成二十六进制</p>
<p>转换成二十六进制是指将字符串 <code>a - z</code> 视为 <code>0 - 25</code> ，且将每一位字符当成二十六进制数来计算。</p>
<p>示例如图：</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_3.jpg" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = <span class="number">26</span>;</span><br><span class="line"><span class="comment">// 用计算得到的哈希值对q取模，防止哈希值溢出</span></span><br><span class="line"><span class="comment">// q为满足(q*d &lt; MAX_INT)的随机素数</span></span><br><span class="line"><span class="keyword">int</span> q = <span class="number">144451</span>;</span><br><span class="line"><span class="comment">// h标记字符串高位字符的基数</span></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 主串的初始哈希值</span></span><br><span class="line"><span class="keyword">int</span> strCode = string.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 模式串的初始哈希值</span></span><br><span class="line"><span class="keyword">int</span> patternCode = pattern.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    strCode = (strCode * d + string.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">    patternCode = (patternCode * d + pattern.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">    h = (h * d) % q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，为防止哈希值溢出，需要对其取模。</p>
<h5 id="1-2-比较哈希值"><a href="#1-2-比较哈希值" class="headerlink" title="1.2 比较哈希值"></a>1.2 比较哈希值</h5><p>对每一轮计算得到的哈希值进行比较。</p>
<ul>
<li><p>哈希值不等，模式串“向右移动一位“，重新计算主串部分的哈希值，模式串不变。</p>
</li>
<li><p>哈希值相等，进入逐位匹配。</p>
</li>
</ul>
<h5 id="1-3-移动主串，重新计算主串部分哈希值"><a href="#1-3-移动主串，重新计算主串部分哈希值" class="headerlink" title="1.3 移动主串，重新计算主串部分哈希值"></a>1.3 移动主串，重新计算主串部分哈希值</h5><p>显然，第一轮两种哈希值计算方法得到的结果均不等，需要重新计算主串部分的哈希值。</p>
<p>在首次计算哈希值过程中，循环语句执行 <code>n</code> 次，即计算哈希值的算法时间复杂度为 <code>O (n)</code>。如果在<strong>重新计算主串部分的哈希值</strong>过程中<strong>完全重新</strong>计算，时间复杂度仍为 <code>O(n)</code>。</p>
<p>将模式串移动一位，<strong>主串部分</strong>去除首位元素并添加末位元素，中间部分并未改变。中间部分的哈希值保存在上一次计算结果当中。故，若是能利用上一次的哈希值计算本次哈希值，则<strong>将时间复杂度优化为</strong> <code>O(1)</code>。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_4.jpg" alt></p>
<p>（1）按位相加</p>
<p>按位相加计算哈希值的算法，其重新计算哈希值的过程较为简单：减去当前主串部分首位字符的值，再加上下一位待添加字符的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextHash</span><span class="params">(String string, <span class="keyword">int</span> hashCode, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    hashCode -= string.charAt(index)-<span class="string">'a'</span>; <span class="comment">// 减去当前主串部分首位字符的值</span></span><br><span class="line">    hashCode += string.charAt(index+n)-<span class="string">'a'</span>; <span class="comment">// 加上下一位待添加字符的值</span></span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）二十六进制算法</p>
<p>按位相加计算哈希值的算法，其重新计算哈希值的过程稍复杂。变量 <code>h</code> 记录了字符串首位字符的基数，重新计算时，将其乘以首位字符的值，得到的是首位字符的哈希值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新主串从i到i+n的哈希值</span></span><br><span class="line">strCode = ((strCode - h*(string.charAt(i)-<span class="string">'a'</span>))*d + (string.charAt(i+n)-<span class="string">'a'</span>)) % q;</span><br><span class="line"><span class="keyword">if</span>(strCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    strCode += q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-逐位匹配"><a href="#1-4-逐位匹配" class="headerlink" title="1.4 逐位匹配"></a>1.4 逐位匹配</h5><p>两个字符串的哈希值相同，并不意味着字符串一定相同，这是<strong>哈希冲突</strong>。</p>
<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_5.jpg" alt></p>
<p>当字符串的哈希值相同时，仍需要进一步逐位匹配字符。</p>
<ul>
<li>哈希值相同的两个字符串，逐位匹配成功，则返回结果。</li>
<li>否则，重新计算哈希值（步骤1.3）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因存在哈希冲突，当哈希值相同时，仍需要额外逐位比对字符串</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/03/字符串匹配之BF、RK算法/RK_Algorithm_6.jpg" alt></p>
<h4 id="2-RK算法的完整实现"><a href="#2-RK算法的完整实现" class="headerlink" title="2. RK算法的完整实现"></a>2. RK算法的完整实现</h4><h5 id="2-1-按位相加"><a href="#2-1-按位相加" class="headerlink" title="2.1 按位相加"></a>2.1 按位相加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robinKarp</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="comment">// 模式串的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">    <span class="comment">// 计算模式串的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> patternCode = firstHash(pattern);</span><br><span class="line">    <span class="comment">// 计算主串当中第一个和模式串等长的子串哈希值</span></span><br><span class="line">    <span class="keyword">int</span> strCode = firstHash(string.substring(<span class="number">0</span>, n));</span><br><span class="line">    <span class="comment">// 用模式串的哈希值和主串的局部哈希值比较。</span></span><br><span class="line">    <span class="comment">// 如果匹配，则进行精确比较；如果不匹配，计算主串中相邻子串的哈希值。</span></span><br><span class="line">    <span class="comment">// 外层循环的最大循环次数为 m-n+1。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m-n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strCode == patternCode &amp;&amp; compareString(i, string, pattern))&#123;</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是最后一轮，更新主串从i到i+n的哈希值</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;m-n)&#123;</span><br><span class="line">            strCode = nextHash(string, strCode, i, n); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashcode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里采用最简单的哈希值计算方式：</span></span><br><span class="line">    <span class="comment">// 把a当做0，把b当中1，把c当中2.....然后按位相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        hashcode += str.charAt(i)-<span class="string">'a'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHash</span><span class="params">(String string, <span class="keyword">int</span> hashCode, <span class="keyword">int</span> index, <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    hashCode -= string.charAt(index)-<span class="string">'a'</span>; </span><br><span class="line">    hashCode += string.charAt(index+n)-<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因存在哈希冲突，当哈希值相同时，仍需要额外逐位比对字符串</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-二十六进制法"><a href="#2-2-二十六进制法" class="headerlink" title="2.2 二十六进制法"></a>2.2 二十六进制法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回模式串在主串中首次出现的位置，若无则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">improvedRobinKarp</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">int</span> m = string.length();</span><br><span class="line">    <span class="comment">// 模式串的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">    <span class="comment">// 26个字母，二十六进制</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">26</span>;</span><br><span class="line">    <span class="comment">// 用计算得到的哈希值对q取模，防止哈希值溢出</span></span><br><span class="line">    <span class="comment">// q为满足(q*d &lt; MAX_INT)的随机素数</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">144451</span>;</span><br><span class="line">    <span class="comment">// h标记字符串高位字符的基数</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主串的初始哈希值</span></span><br><span class="line">    <span class="keyword">int</span> strCode = string.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">// 模式串的初始哈希值</span></span><br><span class="line">    <span class="keyword">int</span> patternCode = pattern.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次计算主串和模式串的哈希值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        strCode = (strCode * d + string.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">        patternCode = (patternCode * d + pattern.charAt(i)-<span class="string">'a'</span>) % q;</span><br><span class="line">        h = (h * d) % q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用模式串的哈希值和主串的局部哈希值比较。</span></span><br><span class="line">    <span class="comment">// 如果匹配，则进行精确比较；如果不匹配，计算主串中相邻子串的哈希值。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m-n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strCode == patternCode &amp;&amp; compareString(i, string, pattern))&#123;</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m-n) &#123;</span><br><span class="line">            <span class="comment">// 更新主串从i到i+n的哈希值</span></span><br><span class="line">            strCode = ((strCode - h*(string.charAt(i)-<span class="string">'a'</span>))*d + (string.charAt(i+n)-<span class="string">'a'</span>)) % q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            strCode += q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compareString</span><span class="params">(<span class="keyword">int</span> start, String string, String pattern)</span></span>&#123; </span><br><span class="line">    String subString = string.substring(start, start+pattern.length());</span><br><span class="line">    <span class="keyword">return</span> subString.equals(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-RK算法的性能"><a href="#3-RK算法的性能" class="headerlink" title="3. RK算法的性能"></a>3. RK算法的性能</h4><p>RK算法首次计算哈希值过程可视为预处理，其时间复杂度为 <code>O(n)</code>。优化后的重新计算哈希值的算法，其时间复杂度为 <code>O(1)</code>。</p>
<p>模式串的哈希值和主串的局部哈希值比较过程，在较好的情况下（即哈希冲突少），最大循环次数为 <code>m - n + 1</code>，故其时间复杂度为 <code>O( m - n + 1 )</code>。</p>
<p>综上，RK算法在<strong>较好的情况下</strong>，时间复杂度为 <code>O(m)</code>。</p>
<p>当然，RK算法也有不足。<strong>当哈希冲突频繁时</strong>，算法性能会下降（即RK算法性能不稳定），<strong>严重时RK算法会退化成BF算法。</strong></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://blog.csdn.net/bjweimengshu/article/details/103966767" target="_blank" rel="noopener">漫画：什么是字符串匹配算法？</a></p>
<p>[2] <a href="https://blog.csdn.net/tyler_download/article/details/52457108?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">面试算法之字符串匹配算法，Rabin-Karp算法详解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>String Matching</tag>
        <tag>BM</tag>
        <tag>KMP</tag>
        <tag>BF</tag>
        <tag>RK</tag>
      </tags>
  </entry>
  <entry>
    <title>xmall项目源码学习</title>
    <url>/2020/03/01/xmall%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>通过阅读GitHub上开源的<a href="https://github.com/Exrick/xmall" target="_blank" rel="noopener">xmall项目</a>深入学习分布式项目，初步了解SpringBoot框架及多种中间件的使用、原理。</p>
<a id="more"></a>

<h3 id="一、前期配置学习"><a href="#一、前期配置学习" class="headerlink" title="一、前期配置学习"></a>一、前期配置学习</h3><h4 id="1-ZooKeeper"><a href="#1-ZooKeeper" class="headerlink" title="1. ZooKeeper"></a>1. ZooKeeper</h4><h5 id="1-1-ZooKeeper概述"><a href="#1-1-ZooKeeper概述" class="headerlink" title="1.1 ZooKeeper概述"></a>1.1 ZooKeeper概述</h5><p>ZooKpeeper用于分布式应用程序的高性能协调服务。（“ZooKeeper is a high-performance coordination service for distributed applications.”）</p>
<p>ZooKeeper可提供用于命名，配置管理，同步和组服务等高级别的服务，目的在于减轻分布式应用程序从头开始实施协调服务的责任。</p>
<p><em>ZooKeeper服务如下图</em></p>
<p><img src="/2020/03/01/xmall项目源码学习/zookeeper_service.jpg" alt></p>
<p>ZooKeeper允许分布式进程通过共享的<strong>层次命名空间</strong>相互协调。ZooKeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。将ZooKeeper数据节点称为<strong>znode</strong>。</p>
<p><em>ZooKeeper的层次命名空间</em></p>
<p><img src="/2020/03/01/xmall项目源码学习/zookeeper_namespace.jpg" alt></p>
<h5 id="1-2-ZooKeeper的特点"><a href="#1-2-ZooKeeper的特点" class="headerlink" title="1.2 ZooKeeper的特点"></a>1.2 ZooKeeper的特点</h5><ol>
<li>ZooKeeper数据保存在内存中，因此具备高吞吐量和低延迟。</li>
<li>ZooKeeper的所有服务器维护内存中的状态图像，以及持久存储事务日志和数据库快照。</li>
<li>只要大多数服务器可用，ZooKeeper服务将正常服务。</li>
<li>标记每一次更新，可用于实现同步。</li>
<li>在“读取为主”的工作负载中，ZooKeeper非常快。</li>
</ol>
<h5 id="1-3-ZooKeeper的配置及运行"><a href="#1-3-ZooKeeper的配置及运行" class="headerlink" title="1.3 ZooKeeper的配置及运行"></a>1.3 ZooKeeper的配置及运行</h5><p>（1）从<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">ZooKeeper官网</a>下载压缩包 <code>apache-zookeeper-3.5.7-bin.tar.gz</code> ，解压至本地，重命名为 <code>zookeeper</code>。</p>
<p>（2）在ZooKeeper目录下新建data和dataLog文件夹，用于存储内存数据库快照和日志文件。</p>
<p>（3）将 zookeeper\conf\ 目录下的 <code>zoo_sample.cfg</code> 文件重命名为 <code>zoo.cfg</code> ，并修改配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># “心跳”，最小会话超时为tickTime的两倍</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 内存数据库快照</span><br><span class="line">dataDir=/.../zookeeper/data</span><br><span class="line"># 日志文件目录</span><br><span class="line">dataLogDir=/.../zookeeper/dataLog</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 侦听客户端连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line">## Metrics Providers</span><br><span class="line">#</span><br><span class="line"># https://prometheus.io Metrics Exporter</span><br><span class="line">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="line">#metricsProvider.httpPort=7000</span><br><span class="line">#metricsProvider.exportJvmInfo=true</span><br></pre></td></tr></table></figure>

<h4 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a>2. Redis</h4><h5 id="2-1-Redis概述"><a href="#2-1-Redis概述" class="headerlink" title="2.1 Redis概述"></a>2.1 Redis概述</h5><p>Redis是用C语言编写的、基于<strong>内存数据集（in-memory dataset）</strong>的内存数据存储结构，可用来实现<strong>数据库</strong>、<strong>缓存</strong>（cache）和<strong>消息代理</strong>（message broker）。</p>
<p>Redis是<strong>键值存储</strong>的形式，支持常见的字符串，哈希，列表（list），集合（set）、有序集合、位图和超日志等。</p>
<p>Redis具备：</p>
<ul>
<li>事务。</li>
<li>不同级别的磁盘持久化（on-disk persistence），可一次全部持久化，也可以通过将每个命令附加到log来持久化它，还可以选择禁用持久化（用于网络内存缓存）。</li>
<li>通过<strong>哨兵</strong>（Redis Sentinel）和 Redis Cluster自动分区提供高可用性。</li>
<li>对数据进行原子操作（如 <em>INCR</em> 命令），如追加到字符串，在哈希中增加值，将元素推送到列表等。</li>
</ul>
<h5 id="2-2-安装与启动"><a href="#2-2-安装与启动" class="headerlink" title="2.2 安装与启动"></a>2.2 安装与启动</h5><p>（1）在Ubuntu系统中，直接使用apt包管理器安装Redis。</p>
<p>（2）启动Redis服务器：redis-server。</p>
<p>（3）Redis客户端连接本地Redis服务器： redis-cli。</p>
<h4 id="3-ActiveMQ"><a href="#3-ActiveMQ" class="headerlink" title="3. ActiveMQ"></a>3. ActiveMQ</h4><h5 id="3-1-ActiveMQ概述"><a href="#3-1-ActiveMQ概述" class="headerlink" title="3.1 ActiveMQ概述"></a>3.1 ActiveMQ概述</h5><p>ActiveMQ 是一种基于 Java 消息服务（Java Message Service）的消息中间件。</p>
<p>在<strong>高并发</strong>的条件下，由于来不及同步处理，请求往往会发生阻塞。例如大量的 update 请求同时到达 MySQL 服务器，造成请求大量堆积。通过使用 ActiveMQ，<strong>异步处理已到达的请求</strong>，缓解服务器压力。</p>
<p>（图源：<a href="https://www.cnblogs.com/xiguadadage/p/11217604.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xiguadadage/p/11217604.html）</a></p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_1.png" alt></p>
<p>如上图所示，通过 ActiveMQ 保存开锁指令，随后异步执行耗时的开锁操作，以减轻服务器的压力。</p>
<h5 id="3-2-ActiveMQ消息类型"><a href="#3-2-ActiveMQ消息类型" class="headerlink" title="3.2 ActiveMQ消息类型"></a>3.2 ActiveMQ消息类型</h5><p>JMS 消息通常有两种类型，ActiveMQ 是基于 JMS 的，所以介绍 ActiveMQ 的两种消息类型：<strong>点对点</strong>（Point-to-Point）和<strong>发布/订阅</strong>（Publish/Subscribe）。</p>
<p>（1）点对点</p>
<p>生产者与消费者点对点发送消息，借助队列（javax.jms.Queue）存储消息。</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_2.png" alt></p>
<p>点对点类型的要点：</p>
<ul>
<li>每个消息只有一个消费者 <code>Consumer</code> ，一旦被消费，消息就不再在队列中。</li>
<li>生产者 <code>Producer</code> 发送消息不受消费者状态的影响。（无依赖性）</li>
<li>消费者在成功接收消息后，需要向队列应答成功。</li>
</ul>
<p>（2）发布/订阅</p>
<p>生产者发布事件，不同的消费者订阅并使用感兴趣的事件。此类型一般与特定的主题（javax.jms.Topic）关联。</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_3.png" alt></p>
<p>发布/订阅类型的要点：</p>
<ul>
<li>每个消息可以有<strong>多个消费者</strong>。</li>
<li>针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。（有依赖性）</li>
<li>为了消费消息，订阅者必须<strong>保持运行</strong>的状态。</li>
</ul>
<h5 id="3-3-ActiveMQ的使用"><a href="#3-3-ActiveMQ的使用" class="headerlink" title="3.3 ActiveMQ的使用"></a>3.3 ActiveMQ的使用</h5><p>下载并解压至本地，在bin目录下执行相应命令：</p>
<ul>
<li>启动：./activemq start</li>
<li>查看状态：./activemq status</li>
<li>关闭：./activemq stop</li>
</ul>
<p>在浏览器中输入<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a> 可访问控制台，账户/密码为 admin/admin。</p>
<p>接下来测试 ActiveMQ 应用于简单的 Java 程序中。</p>
<p>（1）Maven中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageProducer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerURL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建连接工厂</span></span><br><span class="line">		ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(brokerURL);</span><br><span class="line">		<span class="comment">// 建立连接</span></span><br><span class="line">		Connection conn = factory.createConnection();</span><br><span class="line">		conn.start();</span><br><span class="line">		<span class="comment">// 创建会话</span></span><br><span class="line">		Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">		<span class="comment">// 创建队列目标，并标识队列名称，消费者将依据队列名称接收数据</span></span><br><span class="line">		Destination dest = session.createQueue(<span class="string">"TestQueue"</span>);</span><br><span class="line">		<span class="comment">// 创建生产者</span></span><br><span class="line">		MessageProducer producer = session.createProducer(dest);</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">			TextMessage message = session.createTextMessage(<span class="string">"第"</span>+i+<span class="string">"条消息"</span>);</span><br><span class="line">			producer.send(message);</span><br><span class="line">			System.out.println(message.getText());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭连接</span></span><br><span class="line">		conn.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生产者之前，控制台如下：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_4.jpg" alt></p>
<p>运行生产者，发送5条消息，控制台发生了变化：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_5.jpg" alt></p>
<p>如图，队列中等待的消息 <code>Pending Message</code> 有5条，当前无消费者。</p>
<p>（3）消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.Connection;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageConsumer;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerURL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建连接工厂</span></span><br><span class="line">		ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(brokerURL);</span><br><span class="line">		<span class="comment">// 建立连接</span></span><br><span class="line">		Connection conn = factory.createConnection();</span><br><span class="line">		conn.start();</span><br><span class="line">		<span class="comment">// 创建会话</span></span><br><span class="line">		Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">		<span class="comment">// 创建队列目标，并标识队列名称，消费者将依据队列名称接收数据</span></span><br><span class="line">		Destination dest = session.createQueue(<span class="string">"TestQueue"</span>);</span><br><span class="line">		<span class="comment">// 创建消费者</span></span><br><span class="line">		MessageConsumer consumer = session.createConsumer(dest);</span><br><span class="line">		<span class="comment">// 消费者监听</span></span><br><span class="line">		consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">				TextMessage textMessage = (TextMessage) message;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(textMessage.getText());</span><br><span class="line">				&#125;<span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者启动后，控制台又发生了变化：</p>
<p><img src="/2020/03/01/xmall项目源码学习/ActiveMQ_6.jpg" alt></p>
<p>显示此时有1个消费者，刚入队的5条消息均已出队，当前队列中无消息。</p>
<p>注意创建会话的方法，其中有两个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建会话</span></span><br><span class="line">Session session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>

<ol>
<li>false: 表示 <em>不使用事务</em> 。事务：生产者在发送消息后等待消息代理的确认，没有回应则抛出异常，并由生产者负责处理。</li>
<li><em>确认模式</em> ：<ul>
<li><code>AUTO_ACKNOWLEDGE</code>：指定消息接收者在每次收到消息时自动发送确认。消息只向目标发送一次，但传输过程中可能因为错误而丢失消息。</li>
<li><code>CLIENT_ACKNOWLEDGE</code>：由消息接收者确认收到消息，通过调用消息的 <code>acknowledge()</code> 方法（会通知消息提供者收到了消息）。</li>
<li><code>DUPS_OK_ACKNOWLEDGE</code>：指定消息提供者在消息接收者没有确认发送时重新发送消息（这种确认模式不在乎接收者收到重复的消息）。</li>
</ul>
</li>
</ol>
<h5 id="3-4-ActiveMQ进阶之多种MQ简要比较"><a href="#3-4-ActiveMQ进阶之多种MQ简要比较" class="headerlink" title="3.4 ActiveMQ进阶之多种MQ简要比较"></a>3.4 ActiveMQ进阶之多种MQ简要比较</h5><ul>
<li>ActiveMQ 适用于解耦和异步操作，简单易用，对队列数较多的情况支持不好。</li>
<li>RabbitMQ，erlang开发，性能较稳定，社区活跃度高，但是不利于做二次开发和维护。</li>
<li>RocketMQ 支持海量消息，但未实现 JMS 规范。</li>
<li>Kafka 适用于大数据领域、日志采集等场景。</li>
</ul>
<h5 id="3-5-ActiveMQ进阶之持久化"><a href="#3-5-ActiveMQ进阶之持久化" class="headerlink" title="3.5 ActiveMQ进阶之持久化"></a>3.5 ActiveMQ进阶之持久化</h5><p>为避免意外丢失数据，也为重启时可恢复至重启前的正常状态，ActiveMQ 需要实现持久化。</p>
<p>ActiveMQ的消息持久化机制有 <strong>JDBC，AMQ，KahaDB</strong> 和 <strong>LevelDB</strong>。</p>
<p><strong>持久化原理</strong>：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，然后试图将消息发送给接收者，发送成功则将消息从存储中删除，失败则继续尝试。</p>
<p>消息中心启动以后首先要检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>
<p>（1）JDBC</p>
<p>数据库会创建3个表：<code>activemq_msgs</code>，<code>activemq_acks</code> 和 <code>activemq_lock</code>。</p>
<p><code>activemq_msgs</code>用于存储消息，<code>Queue</code> 和 <code>Topic</code> 都存储在这个表中。</p>
<p>（2）AMQ</p>
<ul>
<li>以顺序追加的方式将消息写入日志文件。</li>
<li>创建消息主键索引，且提供缓存。综上，AMQ 性能优于 JDBC。</li>
</ul>
<p>AMQ 的缺点：</p>
<ul>
<li>重建索引时间长，且索引文件占用磁盘空间较大。</li>
</ul>
<p>（3）KahaDB（默认）</p>
<p>从 ActiveMQ 5.4 开始成为默认的持久化插件。</p>
<ul>
<li>基于日志文件，支持索引和缓存。</li>
<li>使用更少的数据文件，恢复时间远小于 AMQ。</li>
</ul>
<p>（4）LevelDB</p>
<p>5.6 版本推出的持久化引擎，性能高于 KahaDB。可见这几种持久化方式中，LevelDB 性能最好。</p>
<h4 id="4-Elasticsearch"><a href="#4-Elasticsearch" class="headerlink" title="4. Elasticsearch"></a>4. Elasticsearch</h4><h5 id="4-1-Elasticsearch概述"><a href="#4-1-Elasticsearch概述" class="headerlink" title="4.1 Elasticsearch概述"></a>4.1 Elasticsearch概述</h5><p>Elasticsearch是一个基于Apache Lucene的开源搜索引擎，使用Java语言开发并使用Lucene作为其核心来实现索引和搜索。</p>
<p>Elasticsearch通过集成的RESTful API来隐藏Lucene的复杂性，它是：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引且可被搜索；</li>
<li>分布式的实时分析搜索引擎；</li>
<li>可扩展性，处理PB级结构化或非结构化数据。</li>
</ul>
<h5 id="4-2-运行Elasticsearch"><a href="#4-2-运行Elasticsearch" class="headerlink" title="4.2 运行Elasticsearch"></a>4.2 运行Elasticsearch</h5><p>（1）前台启动：./bin/elasticsearch</p>
<p>（2）关闭：Ctrl+c</p>
<h5 id="4-3-节点与集群"><a href="#4-3-节点与集群" class="headerlink" title="4.3 节点与集群"></a>4.3 节点与集群</h5><ul>
<li>节点（Node）：一个运行着的Elasticsearch实例。</li>
<li>集群（cluster）：一组具有相同的 <code>cluster.name</code> 的节点的集合。集群内的节点共享数据，提供故障转移和扩展功能。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.jianshu.com/p/cd8e037e11ff" target="_blank" rel="noopener">消息中间件之ActiveMQ</a></p>
<p>[2] <a href="https://www.cnblogs.com/xiguadadage/p/11217604.html" target="_blank" rel="noopener">浅谈ActiveMQ与使用</a></p>
<p>[3] <a href="https://es.xiaoleilu.com/" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>xmall</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之分治法</title>
    <url>/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>是一种十分重要的算法思想，其精髓是”分而治之”，即把复杂的问题分解成数个小规模的、形式相同的子问题，再逐个”击破”子问题，最后合并所有子问题的解以解决原问题。诸如快速排序、归并排序、快速傅里叶变换等算法均是分治法思想的重要体现。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>分治法（Divide and Conquer）与<strong>动态规划</strong>类似，二者最大的区别在于：适用于分治法求解的问题，经分解后得到的<strong>子问题往往是相互独立的</strong>。</p>
<p>分治法可解决的问题，应具备如下特征：</p>
<p>（1）问题的规模缩小后，更容易解决。</p>
<p>（2）该问题可分解为若干个小规模的、形式相同的问题，即该问题具有最优子结构性质。这体现了<strong>递归思想</strong>在分治法中的应用。</p>
<p><strong>（3）利用该问题分解出的子问题的解能够合并为该问题的解。</strong>这决定了某一问题是否适用于分治法。不符时应考虑贪心法或<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>。</p>
<p>（4）子问题是相互独立的。子问题若不独立，应考虑<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>。</p>
<h4 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h4><p>二分查找是分治思想的重要且常用的实现算法之一。</p>
<p>二分查找的基本思路是：将目标对象（一般为数组）一分为二，递归地进入子对象继续进行二分查找，直至子问题可以很容易被解决。其核心代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">    mid = (hi+lo)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 最小规模的子问题，直接返回子问题的结果</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">        hi = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、最大子序和问题"><a href="#三、最大子序和问题" class="headerlink" title="三、最大子序和问题"></a>三、最大子序和问题</h4><p>最大子序和问题是一道经典的算法题，可参见LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>。</p>
<p>问题描述：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<p>在<a href="https://merlinhu0112.github.io/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/">动态规划和分治法求解最大子序和问题</a>一文中，采用动态规划法解决了此问题。如何用分治法解决此问题呢？</p>
<p>分治法的核心在于如何将目标数组划分为若干个子数组并分别求出子数组的最大子序和。容易想到，将数组沿 <code>(left+right)/2</code> 划分为两段，分别递归求解两段的最大子序和，随后合并结果（即从两个值中选择较大者）。</p>
<p>那么，取上述两段最大子序和中的较大者就是数组 <code>nums</code> 的最大子序和了吗？</p>
<p>显然，上述结论是不成立的。因为将数组一分为二，没有考虑到<strong>数组跨越中间元素组成的序列</strong>的情况。那么，考虑它就是咯！</p>
<p>就测试用例而言，我们可沿索引为 <code>4</code> 的元素将 <code>nums</code> 划分为：</p>
<ul>
<li>[-2, 1, -3, 4, -1]，左半段，leftSum；</li>
<li>[2, 1, -5, 4]，右半段，rightSum；</li>
<li>[ … , 4, <strong>-1</strong>, 2, … ]，跨越中间元素的数组，crossSum。</li>
<li>取上述三者的最大值。</li>
</ul>
<p>对于左右半段，递归调用函数即可求解。如何求解跨越中间元素数组的最大子序和（crossSum）呢？</p>
<p>如图，以已经划分至最小规模的 <code>[-2, 1, -3]</code> 为例。我们从 <code>-1</code> 出发，扫描至左端边界，求得跨越中间元素数组的<strong>含边界</strong> <code>-1</code> 的最大子序和 <code>leftCrossSum</code> ；再从 <code>-3</code> 出发，扫描至右端边界，求得跨越中间元素数组的含边界 <code>-3</code> 的最大子序 <code>rightCrossSum</code> ；二者之和即为 <code>crossSum</code> 。</p>
<p><img src="/2020/02/26/五大常用算法之分治法/fig1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursion(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = recursion(nums, left, mid); <span class="comment">// 继续划分，递归求解，左段</span></span><br><span class="line">    <span class="keyword">int</span> rightSum = recursion(nums, mid+<span class="number">1</span>, right); <span class="comment">// 继续划分，递归求解，右段</span></span><br><span class="line">    <span class="keyword">int</span> crossSum = crossSum(nums, left, right); <span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解跨越中间元素时的最大序列和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> leftCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid; i&gt;=left; i--) &#123;</span><br><span class="line">        <span class="comment">// 扫描左边</span></span><br><span class="line">        leftCurrSum += nums[i];</span><br><span class="line">        leftCrossSum = Math.max(leftCrossSum, leftCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightCrossSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> rightCurrSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>; i&lt;=right; i++) &#123;</span><br><span class="line">        <span class="comment">// 扫描右边</span></span><br><span class="line">        rightCurrSum += nums[i];</span><br><span class="line">        rightCrossSum = Math.max(rightCrossSum, rightCurrSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCrossSum+rightCrossSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n log n)；</li>
<li>空间复杂度：O(log n)。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划和分治法求解最大子序和问题</title>
    <url>/2020/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>基于LeetCode<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">第53题</a>，总结<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">动态规划</a>和<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin" target="_blank" rel="noopener">分治法</a>的解题思路，同时涉及经典的Kadane算法。</p>
<a id="more"></a>

<h4 id="一、题目介绍"><a href="#一、题目介绍" class="headerlink" title="一、题目介绍"></a>一、题目介绍</h4><p>题目：求最大子序和。给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>用例：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<p>正确输出结果：6</p>
<h4 id="二、动态规划法"><a href="#二、动态规划法" class="headerlink" title="二、动态规划法"></a>二、动态规划法</h4><p>在<a href="https://merlinhu0112.github.io/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五大常用算法之动态规划</a>中学习了动态规划中首先需要确定的三个要素：</p>
<ul>
<li><p>最优子结构</p>
</li>
<li><p>边界</p>
</li>
<li><p>状态转移方程</p>
</li>
</ul>
<p>在本题中，对于数组 <code>nums</code> 中索引为 <code>i</code> 的元素，其<strong>当前最大子序和</strong>为下列二者中的较大者：</p>
<ul>
<li>索引 <code>i-1</code> 处的当前最大子序和，加上索引 <code>i</code> 处的 <code>nums</code> 数组元素值；</li>
<li>索引 <code>i</code> 处的 <code>nums</code> 数组元素值。</li>
</ul>
<p>设 <code>dp</code> 数组保存每个元素位置的<strong>当前最大子序和</strong>。</p>
<p>状态转移方程为：<code>dp[i] = max( (dp[i-1]+nums[i]), (nums[i]) )</code>；边界条件为：<code>dp[0] = nums[0]</code>。</p>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/dp_1.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// dp数组存储nums数组每个元素位置的当前最大子序和</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max((dp[i-<span class="number">1</span>]+nums[i]), nums[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dp.length; ++i) &#123;</span><br><span class="line">        res = Math.max(dp[i], res); <span class="comment">// 遍历dp数组，找出最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="三、Kadane算法"><a href="#三、Kadane算法" class="headerlink" title="三、Kadane算法"></a>三、Kadane算法</h4><blockquote>
<p>Kadane算法是一种动态规划算法。</p>
</blockquote>
<p>在上述动态规划算法中，使用 <code>dp</code> 数组保存数组 <code>nums</code> 所有位置的最大子序和。在经典的 kadane算法中，对此进行了优化。</p>
<p>Kadane算法采用两个辅助变量：</p>
<ul>
<li>currSum：当前位置 <code>i</code> 的最大子序和，对应的是 <code>dp</code> 中 <code>i</code> 位置的元素值；</li>
<li>maxSum：保存全局最大子序和。</li>
</ul>
<p>算法过程的图示如下：</p>
<p><img src="/2020/02/25/动态规划和分治法求解最大子序和问题/kadane.png" alt></p>
<p>算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        currSum = Math.max((currSum+nums[i]), nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法总结：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、分治法"><a href="#四、分治法" class="headerlink" title="四、分治法"></a>四、分治法</h4><p>关于分治法求解过程，详见<a href="https://merlinhu0112.github.io/2020/02/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95/">五大常用算法之分治法</a>。</p>
<h4 id="五、算法性能总结："><a href="#五、算法性能总结：" class="headerlink" title="五、算法性能总结："></a>五、算法性能总结：</h4><p>暴力法的时间复杂度较高，为 O(n^3) 或 O(n^2)。</p>
<p>分治法的思路较为复杂，从是否跨越中间元素出发，将数组分为三个不会重合的子序列，对其分别求出最大子序和，取三者中的较大者即可。该算法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。</p>
<p>动态规划法的思路更加直观、易理解。算法性能也是最优的，时间复杂度可达 O(n)，空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建线程的方式</title>
    <url>/2020/02/21/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>尽管提倡使用线程池高效地管理线程，但了解线程创建的基础方法还是非常有必要的。</p>
<a id="more"></a>

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>创建线程的四种方式：</p>
<ul>
<li>继承Thread类，无返回结果</li>
<li>实现Runnable接口，无返回结果</li>
<li>通过FutureTask类，有返回结果</li>
<li>通过线程池创建</li>
</ul>
<h3 id="二、继承Thread类创建线程类"><a href="#二、继承Thread类创建线程类" class="headerlink" title="二、继承Thread类创建线程类"></a>二、继承Thread类创建线程类</h3><blockquote>
<p>Java的单继承机制，使得类继承Thread类后，不能再继承其它类。</p>
</blockquote>
<h5 id="1-具体实现过程如下："><a href="#1-具体实现过程如下：" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>继承Thread类，重写<strong>run( )</strong>方法。run( )方法表示线程要执行的任务，被称为执行体。</li>
<li>创建Thread子类对象实例，即创建线程对象。</li>
<li>调用线程对象的<strong>start( )</strong>方法启动该线程。</li>
</ol>
<h5 id="2-实现代码"><a href="#2-实现代码" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之一：继承Thread类，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   MyThread myThread = <span class="keyword">new</span> MyThread(); <span class="comment">// 实例化线程对象</span></span><br><span class="line">   myThread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式"><a href="#3-匿名内部类形式" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><p><em>上述还可以写成匿名内部类的形式</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、通过Runnable接口创建线程类"><a href="#二、通过Runnable接口创建线程类" class="headerlink" title="二、通过Runnable接口创建线程类"></a>二、通过Runnable接口创建线程类</h3><blockquote>
<p>在多数情况下，如果仅覆盖run( )方法而不涉及Thread类的其它方法，不建议使用第一种途径新建线程。</p>
</blockquote>
<h5 id="1-具体实现过程如下：-1"><a href="#1-具体实现过程如下：-1" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>定义Runnable接口的实现类，重写run( )方法。该实现类的实例作为<strong>任务对象</strong>，run( )方法为执行体。</li>
<li>传入任务对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
</ol>
<h5 id="2-实现代码-1"><a href="#2-实现代码-1" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RunnableTask类——任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Java创建线程的方式之二：实现Runnable接口，重写run方法。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunnableTask runTask = <span class="keyword">new</span> RunnableTask(); <span class="comment">// 实例化任务类</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runTask); <span class="comment">// 传入任务对象，创建线程对象</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名内部类形式-1"><a href="#3-匿名内部类形式-1" class="headerlink" title="3. 匿名内部类形式"></a>3. 匿名内部类形式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、通过FutureTask类创建有返回结果的线程"><a href="#三、通过FutureTask类创建有返回结果的线程" class="headerlink" title="三、通过FutureTask类创建有返回结果的线程"></a>三、通过FutureTask类创建有返回结果的线程</h3><blockquote>
<p>FutureTask实现 <code>Future</code> 和 <code>Runnable</code> 接口，是一个可取消的<strong>异步计算任务</strong>，通过其可跟踪任务的执行情况，获取任务的执行结果。</p>
</blockquote>
<p>FutureTask类的两个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable); <span class="comment">// 执行给定的Callable对象</span></span><br><span class="line">FutureTask(Runnable runnable, V result); <span class="comment">// 执行给定的Runnable对象，成功后返回给定的result</span></span><br></pre></td></tr></table></figure>

<h5 id="1-具体实现过程如下：-2"><a href="#1-具体实现过程如下：-2" class="headerlink" title="1. 具体实现过程如下："></a>1. 具体实现过程如下：</h5><ol>
<li>创建Callable接口的实现类，重写call( )方法。call( )方法为执行体，<strong>有返回值</strong>。或者，创建Runnable接口的实现类，重写run( )方法。run( )方法为执行体，无返回值。</li>
<li>调用FutureTask类的构造方法创建FutureTask对象，其中对Runnable对象需要指定result。</li>
<li>传入FutureTask对象，构造Thread类实例对象，即真正的线程对象。</li>
<li>调用线程对象的start( )方法启动该线程。</li>
<li>调用FutureTask对象的<strong>get( )</strong>方法获取线程执行结束的返回值。</li>
</ol>
<h5 id="2-实现代码-2"><a href="#2-实现代码-2" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h5><ol>
<li><em>对于 Callable对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Callable接口的实现类，重写call( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">// call( )方法有返回值</span></span><br><span class="line">		<span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"异步计算任务开始"</span>);</span><br><span class="line">			number = Math.random()*<span class="number">10</span>;</span><br><span class="line">			number += <span class="number">500</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTask()); <span class="comment">// 传入Callable对象，创建FutureTask对象</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask); <span class="comment">// 传入FutureTask对象，创建线程对象</span></span><br><span class="line">    thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    Double result = futureTask.get(); <span class="comment">// 通过FutureTask类的get()方法获取异步计算结果</span></span><br><span class="line">    System.out.println(<span class="string">"计算结果为："</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><em>对于 Runnable 对象</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Runnable接口的实现类，重写run( )方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开启线程"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;Double&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Double&gt;(<span class="keyword">new</span> RunnableTask(), <span class="number">520.0</span>);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    Double result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、通过线程池管理线程"><a href="#四、通过线程池管理线程" class="headerlink" title="四、通过线程池管理线程"></a>四、通过线程池管理线程</h3><blockquote>
<p>通过工厂类 Executors 或 ThreadPoolExecutor 类可创建线程池，通过线程池可管理线程。</p>
</blockquote>
<p><em>以 Executors 为例</em></p>
<p>（1）Executors 可生成四种不同的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>; <span class="comment">// 固定长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>; <span class="comment">// 可缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>; <span class="comment">// 单线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>; <span class="comment">// 延时/定时执行任务，固定长度</span></span><br></pre></td></tr></table></figure>

<p>（2）演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">    es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.cnblogs.com/jinggod/p/8485106.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinggod/p/8485106.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类中代码加载顺序</title>
    <url>/2020/02/04/Java%E7%B1%BB%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>Java中静态变量、静态代码块、构造代码块、成员变量和构造方法的加载顺序，以及父类、子类中的加载顺序。</p>
<a id="more"></a>

<h3 id="一、单一类中代码的首次加载顺序"><a href="#一、单一类中代码的首次加载顺序" class="headerlink" title="一、单一类中代码的首次加载顺序"></a>一、单一类中代码的首次加载顺序</h3><blockquote>
<p>静态变量/静态代码块 &gt;&gt;&gt; 成员变量/构造代码块 &gt;&gt;&gt; 构造方法</p>
</blockquote>
<p><em>代码示例：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 静态变量、静态代码块和构造方法的加载次序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Test();</span><br><span class="line">		<span class="comment">//new Test().staticFunction();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	static &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(a); // 报错，因为静态变量a的加载顺序在此静态代码块之后</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 静态变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态变量比构造代码块先加载，a = "</span>+a);</span><br><span class="line">		a = <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="string">"构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载"</span>);</span><br><span class="line">		System.out.println(<span class="string">"构造代码块加载时，修改了静态变量a的值：a = "</span>+a);</span><br><span class="line">		System.out.println(<span class="string">"构造方法被加载前，完成成员变量初始化：b = "</span>+b); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// 成员变量初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态代码块</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法只有在被调用时才会加载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法被调用"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块被加载</span><br><span class="line">静态变量比构造代码块先加载，a = <span class="number">1</span></span><br><span class="line">构造代码块被加载</span><br><span class="line">构造方法被加载</span><br><span class="line">构造代码块加载时，修改了静态变量a的值：a = <span class="number">3</span></span><br><span class="line">构造方法被加载前，完成成员变量初始化：b = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>结合示例代码和其运行结果，可知在<strong>（首次）加载类</strong>的时候，</p>
<ul>
<li>首先，加载<strong>静态变量</strong>和<strong>静态代码块</strong>，其中二者的加载顺序<strong>与代码顺序相同</strong>；</li>
<li>其次，<em>在调用构造方法后</em>，按代码顺序<strong>先加载成员变量</strong>和<strong>构造代码块</strong>；</li>
<li>最后，加载<strong>构造函数</strong>。</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li>静态变量和静态代码块仅在首次加载类时被加载；</li>
<li>每调用一次构造方法，都要按序加载成员变量、构造代码块、构造函数；</li>
<li>静态方法仅在被调用时才会加载。</li>
</ul>
<h3 id="二、首次加载时父类与子类的情况"><a href="#二、首次加载时父类与子类的情况" class="headerlink" title="二、首次加载时父类与子类的情况"></a>二、首次加载时父类与子类的情况</h3><p><em>加载顺序规则如下</em>：</p>
<ol>
<li><p>按代码位置加载<strong>父类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的静态变量和静态代码块；</p>
</li>
<li><p>按代码位置加载<strong>父类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>父类的构造方法</strong>；</p>
</li>
<li><p>按代码位置加载<strong>子类</strong>的成员变量和构造代码块；</p>
</li>
<li><p>加载<strong>子类的构造方法</strong>。</p>
</li>
</ol>
<p><em>代码示例如下：</em></p>
<p>（父类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的成员变量：fatherEle = "</span>+fatherEle);</span><br><span class="line">		System.out.println(<span class="string">"父类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> fatherEle = <span class="number">520</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（子类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的成员变量：sonEle = "</span>+sonEle);</span><br><span class="line">		System.out.println(<span class="string">"子类的构造方法被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sonEle = <span class="number">1314</span>;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的构造代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的静态代码块被加载"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（测试方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> * 父类、子类代码加载顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的执行结果如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态代码块被加载</span><br><span class="line">子类的静态代码块被加载</span><br><span class="line">父类的构造代码块被加载</span><br><span class="line">父类的成员变量：fatherEle = <span class="number">520</span></span><br><span class="line">父类的构造方法被加载</span><br><span class="line">子类的构造代码块被加载</span><br><span class="line">子类的成员变量：sonEle = <span class="number">1314</span></span><br><span class="line">子类的构造方法被加载</span><br></pre></td></tr></table></figure>

<h3 id="三、非首次加载时父类与子类的情况"><a href="#三、非首次加载时父类与子类的情况" class="headerlink" title="三、非首次加载时父类与子类的情况"></a>三、非首次加载时父类与子类的情况</h3><blockquote>
<p>静态变量和静态代码块不需要再加载，其余按上述（3~6）执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之回溯算法</title>
    <url>/2020/01/13/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基于八皇后问题给出回溯算法的解析过程。回溯算法是真的难，过于抽象，还需反反复复地看看看！</p>
<a id="more"></a>

<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>回溯法（探索与回溯法）是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“<strong>回溯点</strong>”。</p>
<p>其基本思想是，在包含问题的所有解的解空间树中，按照<strong>深度优先搜索</strong>的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</p>
<h4 id="二、典型应用之八皇后问题"><a href="#二、典型应用之八皇后问题" class="headerlink" title="二、典型应用之八皇后问题"></a>二、典型应用之八皇后问题</h4><p>题干：八皇后问题由马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。试问总共有多少种摆放的方法？==（92种）==</p>
<h5 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h5><ul>
<li><p>显然，棋盘上每一行（或每一列）上只能同时出现一个皇后。要解决此问题，可先摆放第1行的皇后，紧接着摆放第2行的皇后。</p>
</li>
<li><p>在摆放第i行的皇后时，需要判断其是否与前面所有行已存在的皇后产生冲突。</p>
</li>
<li><p>若无，直接放置，并继续下一行，直至摆放完最后一行。</p>
</li>
<li><p>若产生冲突，则调整此行的皇后位置。若此行所有位置均不符合要求，则需要<strong>回溯至第i-1行，调整改行皇后的位置</strong>，直至回溯至第1行。</p>
</li>
</ul>
<h5 id="2-图解"><a href="#2-图解" class="headerlink" title="2. 图解"></a>2. 图解</h5><p>（1）放置第1行的皇后：8格均可，先尝试放置在第1格。红色表示<strong>下一行</strong>对应位置已被锁定。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/1.jpg" alt></p>
<p>（2）放置第2行的皇后：前两格已被第1行的皇后锁定，故只能在后6格中任选，选第3格。相应的，前两行放置好的皇后也锁定了第3行部分位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/2.jpg" alt></p>
<p>（3）放置第3行的皇后：在未被锁定的后4格中任选，选第5格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/3.jpg" alt></p>
<p>（4）放置第4行的皇后：只有3格可选，选第2格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/4.jpg" alt></p>
<p>（5）放置第5行的皇后：只剩2格可选，选第1格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/5.jpg" alt></p>
<p>（6）放置第6行的皇后：只能选择第4格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/6.jpg" alt></p>
<p>（7）放置第7行的皇后：只能选择第6格。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/7.jpg" alt></p>
<p>（8）放置完前7行后可发现，第8行所有位置均被锁定。故回溯至第7行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/8.jpg" alt></p>
<p>（9）第7行仅有一个位置，且已尝试过，故继续回溯至第6行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/9.jpg" alt></p>
<p>（10）同样地，继续回溯至第5行。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/10.jpg" alt></p>
<p>（11）第5行有两个位置，前一个已被尝试过，故选择第4格作为第5行皇后的新位置。</p>
<p><img src="/2020/01/13/五大常用算法之回溯算法/11.jpg" alt></p>
<blockquote>
<p>很不幸，第5行重新放置后，第6行所有位置被锁定，故仍需回溯至第4行。在此就不继续演示了。</p>
</blockquote>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题，基于递归的回溯思想，解决此问题</span></span><br><span class="line"><span class="comment"> * 2020-01-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] checkerboard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 棋盘的列投影，记录每一行的皇后存放的列索引值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> len = <span class="number">8</span>; <span class="comment">// 棋盘的行或列长度为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> queens = <span class="number">8</span>; <span class="comment">// 皇后数，为8</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// 记录总共的解法数，对八皇后问题，应为92</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EightQueens</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归地放置皇后到第i+1行合适的位置</span></span><br><span class="line"><span class="comment">	 * 放置第i+1行的皇后之后，需要判断其是否与之前的皇后冲突，若无，递归进入下一行；</span></span><br><span class="line"><span class="comment">	 * 若产生冲突，将其往后移动一列，避免冲突</span></span><br><span class="line"><span class="comment">	 * 注意for循环内部是递归嵌套的，若到最后某一行皇后已无法移动，则会逐步返回上一层，直至</span></span><br><span class="line"><span class="comment">	 * 调整首行以实现放入所有皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putQueen</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==queens) &#123;</span><br><span class="line">			total++; <span class="comment">// 此语句执行则说明当前结果是一种可行解法，故总解法数加1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;len; col++) &#123;</span><br><span class="line">				checkerboard[i] = col; <span class="comment">// 对于第i+1行，该行的皇后放在第col+1列；若if语句为false，则调整第i+1行的皇后位置</span></span><br><span class="line">				<span class="keyword">if</span>(check(i)) &#123;</span><br><span class="line">					putQueen(i+<span class="number">1</span>); <span class="comment">// 若检查发现，第i+1行及之前各行皇后位置均满足题意，则递归移动下一行</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断第i+1行放入的皇后是否与之前的皇后产生冲突</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 行序号，[0, 7]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">			<span class="comment">// j为第i+1行之前的所有行，需要逐一比较</span></span><br><span class="line">			<span class="keyword">if</span>(checkerboard[i]==checkerboard[j] || i-checkerboard[i]==j-checkerboard[j] ||</span><br><span class="line">					i+checkerboard[i]==j+checkerboard[j]) &#123;</span><br><span class="line">				<span class="comment">// checkerboard[i]==checkerboard[j] 判断不同行的皇后是否在同一列</span></span><br><span class="line">				<span class="comment">// i-checkerboard[i]==j-checkerboard[j] 判断不同行的皇后是否在左对角线上</span></span><br><span class="line">				<span class="comment">// i+checkerboard[i]==j+checkerboard[j] 判断不同行的皇后是否在右对角线上</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 辅助方法，启动putQueen</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		putQueen(<span class="number">0</span>); <span class="comment">// 从第1行开始，其行序号为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.php.cn/faq/415926.html" target="_blank" rel="noopener">https://www.php.cn/faq/415926.html</a></p>
<p>[2] <a href="https://www.jianshu.com/p/dd3c3f3e84c0" target="_blank" rel="noopener">https://www.jianshu.com/p/dd3c3f3e84c0</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程学习笔记</title>
    <url>/2020/01/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。</p>
<a id="more"></a>

<p>多线程</p>
<ul>
<li><p>优点：多线程程序提高了资源利用效率；</p>
</li>
<li><p>并发安全性问题：多个线程共享进程的部分资源，对于这些共享变量的访问操作可能出现并发异常；</p>
<blockquote>
<p>解决途径：Java提供的同步机制</p>
</blockquote>
</li>
<li><p>活跃性问题：线程陷入死循环，影响后序代码的执行；</p>
</li>
<li><p>性能消耗问题。</p>
</li>
</ul>
<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>重要概念：</p>
<ul>
<li>状态访问操作：任何可能影响对象外部可见行为的操作；</li>
<li>共享：多个线程可同时访问；</li>
<li>可变：变量值可变。</li>
</ul>
<h4 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h4><h5 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h5><p>（1）简单描述线程安全</p>
<blockquote>
<p>当多个线程访问某个类时，该类始终表现出正确的行为，则该类是线程安全的。</p>
</blockquote>
<p>（2）无状态对象是线程安全的</p>
<blockquote>
<p>无状态对象：不包含任何域和对其它类中域的引用，在操作过程中不保存数据，是不变的类，线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessClass</span></span>&#123;</span><br><span class="line">	<span class="comment">// 不含域，即无成员变量（实例变量和类变量）及局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a; <span class="comment">// Instance Variable(non-static variable)，实例变量，不含</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">// Class Variable(static variable)，类变量，不含</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">10</span>; <span class="comment">// Local Variable，局部变量，不含</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态的对象示例 -- Servlet</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行过程中，仅由线程独享的栈中保存临时数据，因而是线程安全的</span></span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(res, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-竞态条件（Race-Condition）"><a href="#1-2-竞态条件（Race-Condition）" class="headerlink" title="1.2 竞态条件（Race Condition）"></a>1.2 竞态条件（Race Condition）</h5><p>（1）什么是竞态条件？</p>
<p>并发编程中，由于不恰当的执行时序而出现不正确的结果。</p>
<blockquote>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</blockquote>
<p>（2）常见的竞态条件类型</p>
<ol>
<li>先检查后执行（Check-Then-Act）：通过一个可能失效的观测结果来决定下一步的动作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span></span>&#123;</span><br><span class="line">    Private ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyInitRace <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于示例 <strong>延迟初始化</strong> 类，两个线程交替执行过程中，可能均观测到 <code>instance==null</code>，于是分别实例化新的<code>ExpensiveObject</code> 对象，造成 <code>getInstance()</code> 方法返回不同的实例，这是异常情况。</p>
<ol start="2">
<li>读取 - 修改 - 写入：非原子性的操作造成并发异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 访问计数器，线程每访问一次，加1</span></span><br><span class="line">    ...</span><br><span class="line">    count++; <span class="comment">// count++是非原子性的操作，它包括：读取旧值、修改值、写入新值 这三个操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程交替执行时，<code>count++</code> 操作是 <strong>非原子性</strong> 的，最终两个线程分别执行完 <code>count++</code> 操作后得到的 <code>count</code> 是相同的，显然这出现了并发异常。</p>
<p>（3）对于竞态条件，如何保证并发安全性？</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png" alt></p>
<h4 id="2-多线程的安全性"><a href="#2-多线程的安全性" class="headerlink" title="2. 多线程的安全性"></a>2. 多线程的安全性</h4><blockquote>
<p>安全的多线程并发应保证原子性、可见性和有序性</p>
</blockquote>
<h5 id="2-1-原子性、可见性和有序性"><a href="#2-1-原子性、可见性和有序性" class="headerlink" title="2.1 原子性、可见性和有序性"></a>2.1 原子性、可见性和有序性</h5><p>（1）原子性：对于单个或者多个操作，要么全部执行且不会被中断，要么都不执行。</p>
<blockquote>
<p>Atomic包、synchronized关键字、Lock接口</p>
</blockquote>
<p>（2）可见性：对于共享的可变变量，当一个线程修改了它，其它线程能立即看到变化。</p>
<blockquote>
<p>关键字 synchronized、volatile 和 final，Lock接口</p>
</blockquote>
<p>（3）有序性: </p>
<blockquote>
<p>happens-before原则</p>
</blockquote>
<ul>
<li>程序的执行顺序与代码顺序相同；</li>
<li>JVM在实际执行时会发生 <em>指令重排序</em> ；</li>
<li>重排序对单线程程序无影响，对多线程程序可能会造成并发异常！</li>
</ul>
<h5 id="2-2-如何保证可见性？"><a href="#2-2-如何保证可见性？" class="headerlink" title="2.2 如何保证可见性？"></a>2.2 如何保证可见性？</h5><p><img src="/2020/01/12/Java并发编程笔记/%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt></p>
<h4 id="3-Java-的同步机制"><a href="#3-Java-的同步机制" class="headerlink" title="3. Java 的同步机制"></a>3. Java 的同步机制</h4><blockquote>
<p>同步以保证线程安全。Java提供关键字<strong>synchronized（内置锁）</strong> 和 <strong>Lock接口</strong> 这两种机制实现同步。关键字<strong>volatile</strong> 仅保证可见性，不保证原子性。</p>
</blockquote>
<h5 id="3-1-多线程并发异常演示"><a href="#3-1-多线程并发异常演示" class="headerlink" title="3.1 多线程并发异常演示"></a>3.1 多线程并发异常演示</h5><p>（1）Bank类模拟银行账户存取操作，其中未对相应的方法进行同步，使其面临并发异常的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟多线程并发操作银行账户，Bank类实现了取钱和存钱操作。</span></span><br><span class="line"><span class="comment"> * 注意：在实际应用中，涉及金融数字时不应采用任何基本数据类型，而应使用BigDecimal类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）两个线程分别对同一个Bank实例进行反复地存、取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestBank类，演示在无同步前提下，多个线程并发地对Bank类实例</span></span><br><span class="line"><span class="comment"> * 进行操作是否会出现并发异常。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 存钱线程</span></span><br><span class="line">		Thread addThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.addMoney(<span class="number">300</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 取钱线程</span></span><br><span class="line">		Thread subThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.subMoney(<span class="number">500</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		addThread.start();</span><br><span class="line">		subThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.RuntimeException: 当前账户余额不足</span><br><span class="line">	at javasynchronization.Bank.subMoney(Bank.java:20)</span><br><span class="line">	at javasynchronization.UnsafeThread$2.run(UnsafeThread.java:39)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1500 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结合第2行和第4行可知，并发出现异常：存入300元后余额应为1300元；在1300元的基础上支取500元恰好剩余800元。</p>
<p>第12行显示，支取线程因异常而中断，此后为单线程（存钱）操作，不存在并发风险。</p>
</blockquote>
<h5 id="3-2-synchronized-修饰的同步方法【内置锁】"><a href="#3-2-synchronized-修饰的同步方法【内置锁】" class="headerlink" title="3.2 synchronized 修饰的同步方法【内置锁】"></a>3.2 synchronized 修饰的同步方法【内置锁】</h5><blockquote>
<p>关键字 synchronized，Java 所有对象都有一个内置锁，重量级锁。</p>
</blockquote>
<p>（1）SynchronizedBank类，通过<strong>synchronized</strong>实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronizedBank类，模拟银行账户的存取操作，是线程安全的类。</span></span><br><span class="line"><span class="comment"> * 关键字synchronized对subMoney和addMoney方法进行修饰，即利用</span></span><br><span class="line"><span class="comment"> * Java内置锁对上述方法进行加锁，以实现复合操作的原子性，保证线程</span></span><br><span class="line"><span class="comment"> * 安全。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果（测试代码类似于3.1部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1100 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-3-synchronized-同步代码块"><a href="#3-3-synchronized-同步代码块" class="headerlink" title="3.3 synchronized 同步代码块"></a>3.3 synchronized 同步代码块</h5><blockquote>
<p>与 synchronized 修饰的<strong>同步方法</strong>相比，<strong>同步代码块</strong>可<strong>仅对涉及共享变量的操作语句进行加锁</strong>。</p>
</blockquote>
<p>（1）同步代码块示例（由于打印语句需要读取共享变量，故仍要纳入同步代码块中，造成误认为同步方法与同步代码块加锁区域是相同的！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynBloBank类，通过同步代码块避免并发风险。其与SynchronizedBank类中</span></span><br><span class="line"><span class="comment"> * synchronized关键字修饰的同步方法类似，只是同步代码块的同步范围更小（对</span></span><br><span class="line"><span class="comment"> * 影响并发安全性的语句进行同步）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynBloBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynBloBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 同步代码块，锁对象是"this"，即调用此方法者</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 900 元</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 700 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 500 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步代码块：对有并发风险的操作语句进行加锁；</p>
<p>同步方法：对含有并发风险操作的方法进行加锁。</p>
</blockquote>
<h5 id="3-4-ReentrantLock-【显示锁】"><a href="#3-4-ReentrantLock-【显示锁】" class="headerlink" title="3.4 ReentrantLock 【显示锁】"></a>3.4 ReentrantLock 【显示锁】</h5><blockquote>
<p>ReentrantLock类实现Lock接口</p>
</blockquote>
<p>（1）ReentrantLock加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank类，线程安全类。</span></span><br><span class="line"><span class="comment"> * Lock接口定义了锁的操作（包括lock和unlock）。ReentrantLock类实现Lock接口，</span></span><br><span class="line"><span class="comment"> * 默认采用非公平的锁策略。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 锁对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 8888 元</span><br><span class="line">Thread-1 支取 500 元，余额为 8388 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8688 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8188 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8488 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8788 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8288 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-5-关键字-volatile-【不行！】"><a href="#3-5-关键字-volatile-【不行！】" class="headerlink" title="3.5 关键字 volatile 【不行！】"></a>3.5 关键字 volatile 【不行！】</h5><blockquote>
<p>volatile 关键字可以<strong>实现可见性</strong>，但<strong>无法保证原子性</strong>。</p>
</blockquote>
<p>（1）volatile 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VolatileBank类，关键字volatile修饰成员变量count，保证</span></span><br><span class="line"><span class="comment"> * 可见性，但不能保证原子性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VolatileBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前账户初始金额为 1500 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机测试结果表明：并发过程出现异常，即 <em>关键字 volatile 无法保证原子性！</em></p>
</blockquote>
<h4 id="4-Java-中的锁"><a href="#4-Java-中的锁" class="headerlink" title="4. Java 中的锁"></a>4. Java 中的锁</h4><p><img src="/2020/01/12/Java并发编程笔记/Java%E4%B8%AD%E7%9A%84%E9%94%81.png" alt></p>
<h5 id="4-1-synchronized及锁升级过程"><a href="#4-1-synchronized及锁升级过程" class="headerlink" title="4.1 synchronized及锁升级过程"></a>4.1 synchronized及锁升级过程</h5><blockquote>
<p>JDK 1.5之后，synchronized锁被划分为四种状态：无锁 - 偏向锁 - 轻量级锁 - 重量级锁。</p>
</blockquote>
<p>（1）Java普通对象的内存布局</p>
<p>（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> &amp; <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt></p>
<p>（2）锁升级过程</p>
<p>Java锁升级过程（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ol>
<li><p>无锁</p>
<ul>
<li>偏向锁标志位：0</li>
<li>锁标志位：01</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li>设定 -XX:BiasedLockingStartupDelay = 0，由默认轻量级锁改为偏向锁。</li>
<li>偏向锁标志位：1</li>
<li>锁标志位：01</li>
<li><strong>记录当前线程ID</strong></li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li><p>锁标志位：00</p>
</li>
<li><p>当<strong>第二个线程</strong>参与竞争偏向锁时，对象根据对象头markdown中记录的<strong>线程ID</strong>发现是新线程，<strong>立即撤销偏向锁，升级为轻量级锁</strong>。</p>
</li>
<li><p>线程生成<strong>LockRecord</strong>保存在线程栈中。每个线程通过<strong>CAS（自旋）</strong>操作，试图将对象头中的<strong>指向栈中锁记录的指针</strong>记录为自己的LockRecord。成功则获取锁。</p>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>锁标志位：10</li>
<li>锁竞争加剧（如线程自旋次数或自旋的线程数超过阈值），由轻量级锁升级为重量级锁。</li>
<li>重量级锁开始切换用户态/内核态，开销较大。</li>
</ul>
</li>
</ol>
<h5 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h5><p>（暂无）</p>
<h5 id="4-3-ReentrantReadWriteLock"><a href="#4-3-ReentrantReadWriteLock" class="headerlink" title="4.3 ReentrantReadWriteLock"></a>4.3 ReentrantReadWriteLock</h5><p>（暂无）</p>
<h3 id="二、Java类库中的并发基础构建模块"><a href="#二、Java类库中的并发基础构建模块" class="headerlink" title="二、Java类库中的并发基础构建模块"></a>二、Java类库中的并发基础构建模块</h3><h4 id="1-同步容器类"><a href="#1-同步容器类" class="headerlink" title="1. 同步容器类"></a>1. 同步容器类</h4><ul>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<p>同步容器类通过“封装状态，同步所有公有方法”使得每次只有一个线程可以访问容器的状态，以此实现线程安全。</p>
<h5 id="1-1-为什么要为同步容器类额外地进行客户端加锁？"><a href="#1-1-为什么要为同步容器类额外地进行客户端加锁？" class="headerlink" title="1.1 为什么要为同步容器类额外地进行客户端加锁？"></a>1.1 为什么要为同步容器类额外地进行客户端加锁？</h5><blockquote>
<p>客户端加锁：对于使用某个对象的客户端代码，通过对象本身用于保护其状态的锁来保护这段客户端代码。</p>
</blockquote>
<p><em>对于复合操作，同步容器类可能会出现并发异常，但这种异常并非是同步容器类被破坏导致的</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步容器类Vector，对其进行复合操作时可能会出现异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    vector.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程 <code>Thread_A</code> 和 <code>Thread_B</code> 并发地对 <code>Vector</code> 实例进行复合操作时，<strong>无法破坏 vector 对象</strong>，但从下图可以看出，对调用者 <code>Thread_A</code> 来说，出现异常。</p>
<p><img src="/2020/01/12/Java并发编程笔记/3.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行客户端加锁，以保证对同步容器类实例的复合操作是线程安全的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象vector的锁来进行客户端加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">   		<span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    	vector.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-对容器进行迭代操作是有并发风险的"><a href="#1-2-对容器进行迭代操作是有并发风险的" class="headerlink" title="1.2 对容器进行迭代操作是有并发风险的"></a>1.2 对容器进行迭代操作是有并发风险的</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在迭代操作中，其它线程可能并发地修改容器，导致当前线程迭代出现异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    	doSomething(vector.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-如何降低加锁带来的性能影响？"><a href="#1-3-如何降低加锁带来的性能影响？" class="headerlink" title="1.3 如何降低加锁带来的性能影响？"></a>1.3 如何降低加锁带来的性能影响？</h5><blockquote>
<p>克隆容器，在<strong>线程封闭</strong>的副本上进行加锁、复合操作。</p>
</blockquote>
<h4 id="2-并发容器类"><a href="#2-并发容器类" class="headerlink" title="2. 并发容器类"></a>2. 并发容器类</h4><h5 id="2-1-并发容器类与同步容器类的比较"><a href="#2-1-并发容器类与同步容器类的比较" class="headerlink" title="2.1 并发容器类与同步容器类的比较"></a>2.1 并发容器类与同步容器类的比较</h5><p>（1）同步容器类在执行每一个操作时均持有锁，虽保证了线程安全，但降低了并发性。</p>
<p>（2）多个线程竞争同步容器类的锁时，将严重降低系统吞吐量。</p>
<p>（3）并发容器类较同步容器类有更好地并发性能。</p>
<h5 id="2-2-以ConcurrentHashMap为例"><a href="#2-2-以ConcurrentHashMap为例" class="headerlink" title="2.2 以ConcurrentHashMap为例"></a>2.2 以ConcurrentHashMap为例</h5><p>（1）加锁策略 —— <strong>分段锁（Lock Striping）</strong>，细粒度的锁</p>
<ul>
<li>Hashtable（同步容器类）：执行每个操作时均持有锁，提供独占式访问；</li>
<li>SynchronizedMap（同步且基于散列的Map，Collections类中定义的内部类）：独占式访问</li>
<li>ConcurrentHashMap：不是将每个方法在同一个锁上同步，因此<strong>不提供独占式访问</strong>；多个线程可并发访问容器。</li>
</ul>
<p>（2）分段锁策略的特性</p>
<ul>
<li>多个读取线程可并发地访问容器；</li>
<li>多个写入线程可并发地修改容器；</li>
<li>读取线程和并发线程可并发地操作容器。</li>
</ul>
<p>（3）ConcurrentHashMap的优势</p>
<ul>
<li>并发环境下提高系统吞吐量；</li>
<li>迭代器不会抛出ConcurrentModificationException。</li>
</ul>
<h5 id="2-3-ConcurrentHashMap结构及分段锁"><a href="#2-3-ConcurrentHashMap结构及分段锁" class="headerlink" title="2.3 ConcurrentHashMap结构及分段锁"></a>2.3 ConcurrentHashMap结构及分段锁</h5><p><img src="/2020/01/12/Java并发编程笔记/4.jpg" alt></p>
<p>如图所示，ConcurrentHashMap被分为多个片段（Segment），同时一个片段被分为多个HashEntry。</p>
<ul>
<li>Segment继承 <code>ReentrantLock</code> ，扮演锁的角色；</li>
<li>HashEntry用于存储键值对数据（注意：ConcurrentHashMap中key和value均不得为null）；</li>
<li>修改HashEntry数组的数据时，线程必须<strong>先获得对应的Segment锁</strong>。</li>
</ul>
<h4 id="3-同步工具类"><a href="#3-同步工具类" class="headerlink" title="3. 同步工具类"></a>3. 同步工具类</h4><blockquote>
<p>同步工具类是指能根据其自身的状态来<strong>协调线程的控制流</strong>的对象。</p>
</blockquote>
<p>示例：阻塞队列（BlockingQueue）、信号量（Semaphore）、栅栏（Barrier）、闭锁（Latch）</p>
<h5 id="3-1-信号量"><a href="#3-1-信号量" class="headerlink" title="3.1 信号量"></a>3.1 信号量</h5><p>信号量通过管理一组虚拟的许可来控制操作，其具体实现如下：</p>
<ul>
<li>控制同时访问数</li>
<li>实现资源池</li>
<li>对容器施加边界</li>
</ul>
<h5 id="3-2-闭锁"><a href="#3-2-闭锁" class="headerlink" title="3.2 闭锁"></a>3.2 闭锁</h5><p>闭锁是指可以<strong>延迟线程的进度</strong>直到其到达终止状态，其特性如下：</p>
<ul>
<li><p>一次性对象，<strong>不能被重置</strong>；</p>
</li>
<li><p>闭锁到达终止状态前，不允许任何线程通过；</p>
</li>
<li><p>闭锁到达终止状态后，允许线程通过；</p>
</li>
<li><p>用以确保某些活动直到其它活动都完成后再开始，例如待所需资源全部加载后才开始执行初始化。</p>
</li>
</ul>
<h5 id="3-3-栅栏"><a href="#3-3-栅栏" class="headerlink" title="3.3 栅栏"></a>3.3 栅栏</h5><p>栅栏能<strong>阻塞一组线程</strong>直到某个事件发生</p>
<ul>
<li>栅栏要求线程同时到达栅栏位置，方能继续执行；</li>
<li>非一次性；</li>
<li>闭锁用于<em>等待事件</em>，栅栏用于<em>等待线程</em>。</li>
</ul>
<h3 id="三、任务执行策略"><a href="#三、任务执行策略" class="headerlink" title="三、任务执行策略"></a>三、任务执行策略</h3><h4 id="1-串行与并行执行任务"><a href="#1-串行与并行执行任务" class="headerlink" title="1. 串行与并行执行任务"></a>1. 串行与并行执行任务</h4><h5 id="1-1-串行执行任务"><a href="#1-1-串行执行任务" class="headerlink" title="1.1 串行执行任务"></a>1.1 串行执行任务</h5><p><em>显然，服务器单线程串行执行任务，低吞吐量 &amp; 低响应速度</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket connection = socket.accept(); <span class="comment">// 接收请求</span></span><br><span class="line">            handleRequest(connection); <span class="comment">// 处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，服务器只有一个主线程来监听80端口、接收并处理请求。简言之，每次只能有一个请求被处理，后续请求必须等待前序请求完成后才能被服务器接收、处理。</p>
<h5 id="1-2-并行执行任务"><a href="#1-2-并行执行任务" class="headerlink" title="1.2 并行执行任务"></a>1.2 并行执行任务</h5><p><em>主线程监听端口、接收并分发请求，同时创建新线程来处理请求</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); <span class="comment">// 主线程接收请求</span></span><br><span class="line">            Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection); <span class="comment">// 主线程创建新线程处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(command).start(); <span class="comment">// 启动新线程，处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性：</p>
<ul>
<li><strong>在不超过服务器处理能力的前提下</strong>，提高了服务器吞吐量和响应速度；</li>
<li>主线程监听端口、接收并分发请求，创建新线程；</li>
<li>处理请求的线程<strong>并发地处理请求</strong>。</li>
</ul>
<h5 id="1-3-主线程频繁新建线程的风险"><a href="#1-3-主线程频繁新建线程的风险" class="headerlink" title="1.3 主线程频繁新建线程的风险"></a>1.3 主线程频繁新建线程的风险</h5><ul>
<li>创建和销毁线程的开销非常高；</li>
<li>大量线程带来的资源消耗会降低性能；</li>
<li>线程数量超过限制会造成系统异常。</li>
</ul>
<h4 id="2-Executor框架-——-异步任务执行框架"><a href="#2-Executor框架-——-异步任务执行框架" class="headerlink" title="2. Executor框架 —— 异步任务执行框架"></a>2. Executor框架 —— 异步任务执行框架</h4><blockquote>
<p>异步任务执行：将<strong>任务的提交过程</strong>和<strong>执行过程</strong>解耦合</p>
</blockquote>
<h5 id="2-1-为何使用Executor框架？"><a href="#2-1-为何使用Executor框架？" class="headerlink" title="2.1 为何使用Executor框架？"></a>2.1 为何使用Executor框架？</h5><p>前述两种<em>任务执行策略</em>（单线程串行执行任务、新建线程并行执行任务）均存在一定的不足。在异步任务执行框架中将任务的提交和执行解耦，其中通过<strong>线程池</strong>实现对线程的高效管理。</p>
<h5 id="2-2-Executor框架的基础-——-生产者-消费者模式"><a href="#2-2-Executor框架的基础-——-生产者-消费者模式" class="headerlink" title="2.2 Executor框架的基础 —— 生产者-消费者模式"></a>2.2 Executor框架的基础 —— 生产者-消费者模式</h5><ul>
<li>生产者：提交任务的操作</li>
<li>消费者：执行任务的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">50</span>; <span class="comment">// 线程池长度</span></span><br><span class="line">    <span class="comment">// newFixedThreadPool方法将返回一个固定长度的线程池，其长度不再变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec</span><br><span class="line">        = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Connection connection = socket.accept();</span><br><span class="line">         	Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(command); <span class="comment">// 线程池负责管理线程以执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>通过实现 Executor接口，可制定更丰富的执行策略</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Executor框架结构"><a href="#2-3-Executor框架结构" class="headerlink" title="2.3 Executor框架结构"></a>2.3 Executor框架结构</h5><p><img src="/2020/01/12/Java并发编程笔记/5.jpg" alt></p>
<p><em>Executor框架包括以下三个部分：</em></p>
<ol>
<li><p><strong>任务</strong>：被执行的任务需要实现Runnable接口或Callable接口；</p>
</li>
<li><p><strong>执行</strong>：线程执行任务，包括Executor接口和最重要的<strong>ThreadPoolExecutor</strong>类；</p>
</li>
<li><p><strong>异步计算</strong>：包括Future接口及实现Future接口的FutureTask类。</p>
</li>
</ol>
<h5 id="2-4-Executor框架的执行过程"><a href="#2-4-Executor框架的执行过程" class="headerlink" title="2.4 Executor框架的执行过程"></a>2.4 Executor框架的执行过程</h5><p>（1）创建任务对象</p>
<p>创建实现Runnable接口或Callable接口的任务对象。</p>
<p><em>实现 Runnable接口，重写 run 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>实现 Callable 接口，重写 call 方法：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"实现Callable接口，重写Call方法，有返回值"</span>;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Runnable接口与Callable接口的区别：</strong></p>
<ul>
<li>Runnable接口无返回值；</li>
<li>Callable接口有返回值，需要声明抛出异常。</li>
</ul>
<p><em>通过工厂类 Executors 的 Callable(Runnable task) 方法可将 Runnable 对象包装成 Callable 对象</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Object&gt; task = Executors.callable(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<p>（2）执行任务</p>
<blockquote>
<p>通过实现java.util.concurrent.ExecutorService接口的对象来执行任务</p>
</blockquote>
<ol>
<li>将Runnable对象交给ExecutorService执行，调用<strong>execute</strong>方法，无返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Runnable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象，<strong>但调用Future对象的get方法，返回值为null</strong>。【源码分析见 2.5】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;Object&gt; future = (Future&lt;Object&gt;) es.submit(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(future.get()==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"future.get()返回null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将Callable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">				<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure>

<p>（3）关闭线程池</p>
<ol>
<li>对于执行ExecutorService的execute方法，调用shutdown方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"></span><br><span class="line">es.shutdown(); <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于执行ExecutorService的submit方法，主线程可执行FutureTask.get()方法等待任务执行完毕，也可通过FutureTask.cancel()方法取消任务的执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(future.get());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解"><a href="#2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解" class="headerlink" title="2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解"></a>2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解</h5><p> <strong>AbstractExecutorService</strong>类实现了ExecutorService接口并实现了<strong>submit()</strong> 方法，ThreadPoolExecutor类从AbstractExecutorService类继承了submit方法。</p>
<p><em>基于 JDK 1.8的源码，分析如下：</em></p>
<p>AbstractExecutorService类实现了ExecutorService接口，实现submit()方法。将Runnable对象交给 ExecutorService去处理且调用<code>submit(Runnable task)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask); <span class="comment">// 调用ThreadPoolExecutor类的execute方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部通过调用<code>newTaskFor(Runnable runnable, T value)</code>方法返回一个<code>FutureTask</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造<code>FutureTask</code>对象时，通过调用<code>Executors.callable(runnable, result)</code>方法<strong>将Runnable对象包装成Callable对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于提交的 Callable 对象，AbstractExecutorService 类同样是调用 newTaskFor 方法 返回一个 FutureTask 对象：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-线程池-——-高效地管理线程的生命周期"><a href="#3-线程池-——-高效地管理线程的生命周期" class="headerlink" title="3. 线程池 —— 高效地管理线程的生命周期"></a>3. 线程池 —— 高效地管理线程的生命周期</h4><p><em>重要参数：</em></p>
<ul>
<li><p>corePoolSize：线程池的目标大小，即无任何任务执行时线程池的大小，且仅当工作队列已满才会产生大于此值的线程数量。</p>
</li>
<li><p>maximumPoolSize：线程池最大同时活动线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。线程空闲时间大于存活时间，被标记为“可回收”；活动线程数大于corePoolSize时，回收标记为“可回收”的空闲线程。</p>
</li>
</ul>
<p><strong><em>两个重要的问题：</em></strong></p>
<ol>
<li><p>为什么要使用线程池，而不是直接手动创建线程？</p>
<ul>
<li><p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。</p>
</li>
<li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>为什么要通过ThreadPoolExecutor创建线程池，而不是通过工厂类Executors？<ul>
<li>使开发者更加明确线程池的运行规则，避免资源耗尽的风险。</li>
<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integet.MAX_VALUE，可能会堆积大量的请求。</li>
<li>CachedThreadPool 和 ScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程。</li>
<li>上述四种方式其本质还是调用ThreadPoolExecutor。</li>
</ul>
</li>
</ol>
<h5 id="3-1-通过工厂类Executors的静态工厂方法"><a href="#3-1-通过工厂类Executors的静态工厂方法" class="headerlink" title="3.1 通过工厂类Executors的静态工厂方法"></a>3.1 通过工厂类Executors的静态工厂方法</h5><p>通过调用工厂类Executors中的静态工厂方法，可产生如下类型的线程池：</p>
<ul>
<li>newFixedThreadPool  固定长度</li>
<li>newCachedThreadPool 可缓存</li>
<li>newSingleThreadExecutor 单线程</li>
<li>newScheduledThreadPool 延时/定时执行任务，固定长度</li>
</ul>
<p>（1）newFixedThreadPool</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为指定值nThread，keepAliveTime设为0。</p>
</li>
<li><p>固定长度的线程池。因corePoolSize为nThread，故每提交一个任务就创建一个线程，直到总数为nThreads。</p>
</li>
<li><p>keepAliveTime为0，线程不会超时。</p>
</li>
<li><p>线程执行过程中异常中断，会新建线程以补充。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）newCachedThreadPool</p>
<ul>
<li><p>corePoolSize设为0，maximumPoolSize设为Integer.MAX_VALUE，keepAliveTime设为60秒。</p>
</li>
<li><p>无可用线程时新建线程，有可用线程时则复用该线程。</p>
</li>
<li><p>因maximumPoolSize设为Integer.MAX_VALUE，即线程数最大值为2147483647。</p>
</li>
<li><p>线程存活时间为60秒，避免大量空闲线程对资源的消耗。</p>
</li>
<li><p>同步任务队列SynchronousQueue<runnable>。</runnable></p>
</li>
<li><p>此线程池适用于大量短暂的异步任务。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）newSingleThreadExecutor</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为1，keepAliveTime设为0。</p>
</li>
<li><p>首次提交任务时创建单个线程，且仅维持一个线程。</p>
</li>
<li><p>当线程在关闭前异常终止，程序新建一个线程以执行后续任务。</p>
</li>
<li><p>确保任务串行执行。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法返回的是FinalizableDelegatedExecutorService对象，其内部保存一个ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Executors类的静态方法newSingleThreadExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类FinalizableDelegatedExecutorService，其继承自Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e; <span class="comment">// 内部保存一个ExecutorService对象</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）newScheduledThreadPool</p>
<ul>
<li><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>可延时执行阻塞任务的队列。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法指定线程池基本大小、返回ScheduledThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ScheduledThreadPoolExecutor类，其调用父类ThreadPoolExecutor的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-ThreadPoolExecutor"><a href="#3-2-ThreadPoolExecutor" class="headerlink" title="3.2 ThreadPoolExecutor"></a>3.2 ThreadPoolExecutor</h5><p>（暂无）</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] 《Java并发编程实战》Goetz B. 著，童云兰译</p>
<p>[2] <a href="https://www.infoq.cn/article/ConcurrentHashMap/" target="_blank" rel="noopener">https://www.infoq.cn/article/ConcurrentHashMap/</a></p>
<p>[3] <a href="http://www.bubuko.com/infodetail-1518587.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1518587.html</a></p>
<p>[4] <a href="https://blog.csdn.net/tongdanping/article/details/79604637" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79604637</a></p>
<p>[5] <a href="https://www.cnblogs.com/xifengxiaoma/p/11477136.html" target="_blank" rel="noopener">https://www.cnblogs.com/xifengxiaoma/p/11477136.html</a></p>
<p>[6] <a href="https://www.cnblogs.com/jiansen/p/7351872.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiansen/p/7351872.html</a></p>
<p>[7] <a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a></p>
<p>[8] <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>五大常用算法之动态规划</title>
    <url>/2020/01/02/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>通过阅读他人优秀的文章，基于经典的青蛙跳台阶问题，深入地学习动态规划建模过程。通过递归算法、自顶向下的备忘录算法及自低向上的动态规划算法，解决实际问题。</p>
<a id="more"></a>

<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>动态规划（Dynamic Programming）与<strong>分治法</strong>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。</p>
<p>用一个表来记录所有已解的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中，这就是动态规划法的基本思路。</p>
<h4 id="二、建模"><a href="#二、建模" class="headerlink" title="二、建模"></a>二、建模</h4><p>对问题建模前，须明确以下三个重要概念：</p>
<blockquote>
<p>1、最优子结构</p>
<p>2、边界</p>
<p>3、状态转移方程</p>
</blockquote>
<h4 id="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"><a href="#三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程" class="headerlink" title="三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程"></a>三、以青蛙跳台阶问题为例，深入剖析动态规划建模过程</h4><h5 id="1-对青蛙跳台阶问题的图解"><a href="#1-对青蛙跳台阶问题的图解" class="headerlink" title="1. 对青蛙跳台阶问题的图解"></a>1. 对青蛙跳台阶问题的图解</h5><p>（本小节图源：<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a> ）</p>
<ul>
<li>每次跳1级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/1.jpg" alt></p>
<ul>
<li>或每次跳2级台阶</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/2.jpg" alt></p>
<p>如果站在第n级台阶的角度上，如何到达该层？</p>
<blockquote>
<p>a. 从第n-1级台阶，跳1级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/3.jpg" alt></p>
<blockquote>
<p>b. 从第n-2级台阶，跳2级台阶，到达第n级</p>
</blockquote>
<p><img src="/2020/01/02/五大常用算法之动态规划/4.jpg" alt></p>
<p>显然，<strong>到达第n级台阶的路线总数等于到达第n-1级和第n-2级之和</strong>。</p>
<h5 id="2-建模"><a href="#2-建模" class="headerlink" title="2. 建模"></a>2. 建模</h5><ul>
<li><p>最优子结构</p>
<p>如上所述，第n级台阶的路线总数等于到达第n-1级和第n-2级之和，即 F(n) = F(n-1) + F(n-2)。</p>
</li>
<li><p>状态转移方程</p>
<p><strong>F(n) = F(n-1) + F(n-2)</strong></p>
</li>
<li><p>边界</p>
<p>F(1) = 1, F(2) = 2</p>
</li>
</ul>
<h5 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h5><p>（1）递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（2）备忘录算法（自顶向下）</p>
<p>利用集合Map，避免递归算法中的重复计算部分，提高算法效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N, HashMap&lt;Integer, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(N))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(N);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = frogJump(N-<span class="number">1</span>) + frogJump(N-<span class="number">2</span>);</span><br><span class="line">        map.put(N, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>（3）动态规划（自底向上）</p>
<p>备忘录算法中须保存所有子状态，若仅仅保存递推所需的前两个子状态，便能优化算法的空间复杂度。</p>
<blockquote>
<p>通过自底向上的递推，仅仅利用常数额外空间，优化算法的时间和空间复杂度，这便是动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp; <span class="comment">// 更新最新的子状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="四、更加复杂的动态规划——国王与金矿问题"><a href="#四、更加复杂的动态规划——国王与金矿问题" class="headerlink" title="四、更加复杂的动态规划——国王与金矿问题"></a>四、更加复杂的动态规划——国王与金矿问题</h4><p>问题：有一个国家发现了n座金矿，每座金矿的黄金储量不同，且每座金矿需要参与挖掘的工人数也不同。参与挖矿工人的总数是w。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要想得到尽可能多的黄金，应该选择挖取哪几座金矿？</p>
<p>（本小节图源：<a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a> ）</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/5.jpg" alt></p>
<h5 id="1-建模"><a href="#1-建模" class="headerlink" title="1. 建模"></a>1. 建模</h5><blockquote>
<p>n：金矿数量；w：总的工人数；g[]：保存每座金矿的矿藏量；p[]：保存每座金矿的用工数</p>
</blockquote>
<p>建模过程中，需要明确最优子结构、状态转移方程和边界这三个要素。</p>
<p>（1）确定最优子结构</p>
<p>以10名工人开挖5座金矿为例。其最优子结构分为如下两种情况：</p>
<ul>
<li>若不挖第5座金矿，则最优解为10人开挖4座金矿的最优解；</li>
<li>若挖第5座金矿，则需要找到剩下的人挖剩余的4座金矿的最优解；</li>
</ul>
<p><img src="/2020/01/02/五大常用算法之动态规划/6.jpg" alt></p>
<blockquote>
<p>显然，10人挖5座金矿的最优解是这两种子状态的较大值</p>
</blockquote>
<p>（2）确定状态转移方程</p>
<ul>
<li>若第n座金矿有足够的人工开挖，则w个工人开挖n座金矿的情形，满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = max(F(n-1, w), F(n-1, w-p[n-1])+g(n-1)), n&gt;1, w&gt;=p[n-1]</p>
</blockquote>
<ul>
<li>若w个工人不能满足开采第n座金矿所需的工人数，则满足下列方程：</li>
</ul>
<blockquote>
<p>F(n, w) = F(n-1, w), n&gt;1, w&lt;p[n-1]</p>
</blockquote>
<p>（3）确定边界</p>
<ul>
<li>若金矿数仅为1，且工人数能满足开采该金矿所需的工人数，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = g[0], n==1, w&gt;=p[0]</p>
</blockquote>
<ul>
<li>若金矿数为1，但工人总数不满足要求，则有：</li>
</ul>
<blockquote>
<p>F(n, w) = 0, n==1, w&lt;p[0]</p>
</blockquote>
<h5 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2. 算法实现"></a>2. 算法实现</h5><p>（1）递归解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = getMaxGold(n-<span class="number">1</span>, w, g, p);</span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p) + g[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(2^n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>（2）备忘录算法</p>
<blockquote>
<p>类似于青蛙跳问题中的备忘录算法，利用集合Map保存子状态，其中HashMap的Key是包含金矿数n和工人数w的对象，Value是最多的开采量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p, HashMap&lt;KeyObject, Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&lt;p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=p[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject a_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(a_obj)) &#123;</span><br><span class="line">        a = map.get(a_obj);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        a = getMaxGold(n-<span class="number">1</span>, w, g, p, map);</span><br><span class="line">        map.put(a_obj, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w&lt;p[n-<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyObject b_obj = <span class="keyword">new</span> KeyObject(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(b_obj)) &#123;</span><br><span class="line">        b = map.get(b_obj) + g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b = getMaxGold(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], g, p, map);</span><br><span class="line">        map.put(b_obj, b);</span><br><span class="line">        b += g[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类用于HashMap中的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyObject</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(n*w)</li>
</ul>
<p>（3）动态规划算法</p>
<p>以10名工人挖5座金矿为例，可作下表</p>
<p><img src="/2020/01/02/五大常用算法之动态规划/7.jpg" alt></p>
<p>表中，每一行的所有数据均可<strong>由上一行数据推导得到</strong>，因而动态规划算法可基于此规律，利用前一行数据推导当前行数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || w&lt;=<span class="number">0</span> || g==<span class="keyword">null</span> || p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] preResult = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>]; <span class="comment">// w+1列，保存上一行数据</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[w+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;p[<span class="number">0</span>]) &#123;</span><br><span class="line">            preResult[j] = <span class="number">0</span>; <span class="comment">// 当金矿数为1，但工人总数无法满足开采要求时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            preResult[j] = g[<span class="number">0</span>]; <span class="comment">// 金矿数为1，且工人总数满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> preResult[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="comment">// 外循环中，i为当前金矿索引；内循环中，j为工人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;p[i]) &#123;</span><br><span class="line">                <span class="comment">// 若j个工人不能满足开采第i+1座金矿所需的工人数</span></span><br><span class="line">                result[j] = preResult[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若第i+1座金矿有足够的人工开挖，则j个工人开挖i+1座金矿</span></span><br><span class="line">                result[j] = Math.max(preResult[j], preResult[j-p[i]]+g[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=w;j++) &#123;</span><br><span class="line">            preResult[j] = result[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*w)</li>
<li>空间复杂度：O(w)</li>
</ul>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a></p>
<p>[2] <a href="https://www.cnblogs.com/hczd123/p/7412950.html" target="_blank" rel="noopener">https://www.cnblogs.com/hczd123/p/7412950.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习之虚拟机</title>
    <url>/2019/11/11/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>通读周志明先生的《深入理解Java虚拟机》一书，学习了Java虚拟机的内存模型，内存管理机制，常见的垃圾回收算法和不同类型的垃圾收集器，以及字节码文件的结构。现整理成笔记，温故而知新！</p>
<a id="more"></a>

<h3 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h3><h4 id="1-Java内存区域图示如下："><a href="#1-Java内存区域图示如下：" class="headerlink" title="1. Java内存区域图示如下："></a>1. Java内存区域图示如下：</h4><p><img src="/2019/11/11/Java学习之虚拟机/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%A4%BA%E6%84%8F.png" alt></p>
<p>值得注意的是：<strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>、<strong>堆（Heap）</strong>、<strong>方法区（Method Area）</strong>：</p>
<ol>
<li><p>虚拟机栈主要与方法调用相关，存储的局部变量表中保存<strong>对象引用</strong>；</p>
</li>
<li><p>堆：存放所有的对象实例；</p>
</li>
<li><p>方法区：与编译相关，存储虚拟机加载的类信息、<strong>静态变量</strong>、常量等；</p>
</li>
<li><p>运行时常量池：编译生成的字面量和符号引用。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/2.png" alt></p>
<h4 id="2-HotSpot虚拟机新建对象过程"><a href="#2-HotSpot虚拟机新建对象过程" class="headerlink" title="2. HotSpot虚拟机新建对象过程"></a>2. HotSpot虚拟机新建对象过程</h4><p>以常见的HotSpot为例，介绍其新建普通 Java对象的过程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BAnew%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>（1）在堆中分配内存的两种方式：</p>
<ul>
<li><p>指针碰撞：内存区域规整（未使用区域与已使用区域分界）时，仅需要移动指针</p>
</li>
<li><p>空闲列表：因内存区域杂乱无章，虚拟机维持记录可用内存区域的表</p>
</li>
</ul>
<p><strong>（2）两种保证分配内存时线程安全的方法：</strong></p>
<ul>
<li><p>同步机制，CAS + 失败重试</p>
</li>
<li><p><strong>每个线程</strong>单独预分配一块内存区域，称之为<strong>本地线程分配缓冲（TLAB）</strong></p>
</li>
</ul>
<p>（3）对象的内存布局：</p>
<ol>
<li><p>对象头：保存运行时数据，如哈希码、GC分代年龄等；另一部分保存指向类元数据的<strong>类型指针</strong></p>
</li>
<li><p>实例数据部分</p>
</li>
<li><p>填充位</p>
</li>
</ol>
<h4 id="3-对象的访问方式"><a href="#3-对象的访问方式" class="headerlink" title="3. 对象的访问方式"></a>3. 对象的访问方式</h4><p>访问对象的途径主要是通过句柄和直接访问：</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p><strong>对象类型数据</strong>是指该实例所属的类</p>
<p>查找对象的元数据信息未经过对象本身</p>
<p>优点：垃圾收集需要调整对象所在内存地址时，不影响reference；</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<blockquote>
<p>查找对象的元数据信息须经过对象本身</p>
<p>优点：访问速度快</p>
</blockquote>
<h4 id="4、内存分配策略"><a href="#4、内存分配策略" class="headerlink" title="4、内存分配策略"></a>4、内存分配策略</h4><p>具体的内存分配策略取决于 GC组合、JVM参数设置：</p>
<ol>
<li><p>对象优先在新生代 Eden 区分配，该区域不足时，发起 Minor GC；</p>
</li>
<li><p>占用大内存的对象直接进入老年代；</p>
</li>
<li><p>寿命长的对象进入老年代（根据对象年龄计数器来判断）；</p>
</li>
<li><p>Survivor 空间中相同年龄的对象达到一半空间时，年龄大于或等于该年龄的对象可进入老年代；</p>
</li>
<li><p>老年代为 Minor GC提供空间分配担保。</p>
</li>
</ol>
<h3 id="二、GC工作区域"><a href="#二、GC工作区域" class="headerlink" title="二、GC工作区域"></a>二、GC工作区域</h3><p>在 JVM中，虚拟机栈、本地方法栈和程序计数器属于线程私有，随线程结束而释放内存。JVM中的GC关注的是<strong>方法区</strong>和<strong>堆</strong>。</p>
<h4 id="1-回收堆"><a href="#1-回收堆" class="headerlink" title="1. 回收堆"></a>1. 回收堆</h4><h5 id="1-1-如何判断对象内存可回收？"><a href="#1-1-如何判断对象内存可回收？" class="headerlink" title="1.1 如何判断对象内存可回收？"></a>1.1 如何判断对象内存可回收？</h5><p><strong>可达性分析算法</strong>：根搜索方法，通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain）。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg" alt></p>
<h5 id="1-2-Java中可作为GC-Roots的四种对象："><a href="#1-2-Java中可作为GC-Roots的四种对象：" class="headerlink" title="1.2 Java中可作为GC Roots的四种对象："></a>1.2 Java中可作为GC Roots的四种对象：</h5><ul>
<li><p>虚拟机栈的本地变量表中引用的对象</p>
</li>
<li><p>方法区类静态属性引用的对象</p>
</li>
<li><p>方法区常量引用的对象</p>
</li>
<li><p>本地方法栈Native方法引用的对象</p>
</li>
</ul>
<h5 id="1-3-经可达性分析后，可回收对象就一定会被回收？"><a href="#1-3-经可达性分析后，可回收对象就一定会被回收？" class="headerlink" title="1.3 经可达性分析后，可回收对象就一定会被回收？"></a>1.3 经可达性分析后，可回收对象就一定会被回收？</h5><p>经可达性分析后，被定为可回收的对象须经历<strong>两次标记</strong>方能被GC回收内存。【重点：finalize()方法】</p>
<h5 id="1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"><a href="#1-4-JVM为什么不采用经典的引用计数算法来判断对象是否可回收？" class="headerlink" title="1.4 JVM为什么不采用经典的引用计数算法来判断对象是否可回收？"></a>1.4 JVM为什么不采用经典的<strong>引用计数</strong>算法来判断对象是否可回收？</h5><p>引用计数算法实现简单，但面临一个重要缺陷：当两个对象互相引用（循环引用）时，相应的内存区域无法被回收，导致<strong>内存泄漏</strong></p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt></p>
<h5 id="1-5-引用分类（是否回收被引用对象所在的内存区域）"><a href="#1-5-引用分类（是否回收被引用对象所在的内存区域）" class="headerlink" title="1.5 引用分类（是否回收被引用对象所在的内存区域）"></a>1.5 引用分类（是否回收被引用对象所在的内存区域）</h5><ol>
<li><p>强引用：new出来的对象引用关系，不会回收；</p>
</li>
<li><p>软引用：有用、非必需，在内存溢出前进行二次回收；</p>
</li>
<li><p>弱引用：生存至下一次GC工作前，一旦GC开始回收内存，则直接回收其对象；</p>
</li>
<li><p>虚引用：无法通过虚引用取得对象，仅能在此对象被回收时通知系统。</p>
</li>
</ol>
<h4 id="2、回收方法区"><a href="#2、回收方法区" class="headerlink" title="2、回收方法区"></a>2、回收方法区</h4><p>方法区待回收的内容主要为：废弃常量 和 无用的类。</p>
<p>（1）废弃常量：当常量池中的常量不被任何对象引用时，则可以清理出常量池。</p>
<p>（2）无用的类：无用的类须满足下述三个条件，</p>
<ul>
<li><p>Java堆中该类所有的实例均已被回收；</p>
</li>
<li><p>该类的加载器ClassLoader已被回收；</p>
</li>
<li><p>无法通过反射机制访问该类的方法。</p>
</li>
</ul>
<h3 id="三、回收算法"><a href="#三、回收算法" class="headerlink" title="三、回收算法"></a>三、回收算法</h3><p>JVM 针对 Java堆 采用的回收算法主要分为：<strong>标记-清除算法、复制算法和标记-整理算法</strong>；采用的策略为：分代收集算法，即新生代采用复制算法，老年代采用标记-清除算法和标记-整理算法</p>
<h4 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h4><h5 id="1-1-标记-清除（Mark-Sweep）算法"><a href="#1-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="1.1 标记-清除（Mark-Sweep）算法"></a>1.1 标记-清除（Mark-Sweep）算法</h5><p>在标记阶段，由<strong>根节点开始经可达性分析</strong>，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象；</p>
<p>在清除阶段，清除所有未被标记的对象。</p>
<ul>
<li><p><em>特点：将循环引用标记为不可达，解决了引用计数算法无法处理循环引用的问题.</em></p>
</li>
<li><p><em>缺点：1、效率低；2、易导致内存区域不规整（即大量不连续的内存碎片）。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-2-复制（Copying）算法"><a href="#1-2-复制（Copying）算法" class="headerlink" title="1.2 复制（Copying）算法"></a>1.2 复制（Copying）算法</h5><p>内存对半分，先使用一半，需要清理时先将存活对象转移至保留内存区域，随后全部回收刚使用过的一半内存。</p>
<p><strong>适用于新生代</strong>中对象存活率低、可回收对象比例高的场景。</p>
<ul>
<li><em>优点：1、无内存碎片；2、效率高。</em></li>
<li><em>缺点：1、实际使用内存仅占一半，浪费资源；2、当对象存活率高时，需要较为频繁的复制操作，效率降低。</em></li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-3-标记-整理（Mark-Compact）算法"><a href="#1-3-标记-整理（Mark-Compact）算法" class="headerlink" title="1.3 标记-整理（Mark-Compact）算法"></a>1.3 标记-整理（Mark-Compact）算法</h5><p>针对老年代中对象存活率高，若使用复制算法，则效率低。</p>
<p>标记-整理算法（或标记-压缩算法）核心在于：标记完成后，将“分散”的存活对象移动至“端集中”区域，随后清理其端边界以外的内存。</p>
<ul>
<li><p><em>优点：1、适用于对象存活率高的场景；2、无内存碎片。</em></p>
</li>
<li><p><em>缺点：标记、整理过程代价高昂。</em></p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt></p>
<h5 id="1-4-分代收集（Generational-Collection）算法"><a href="#1-4-分代收集（Generational-Collection）算法" class="headerlink" title="1.4 分代收集（Generational Collection）算法"></a>1.4 分代收集（Generational Collection）算法</h5><p>将 Java堆分为<strong>新生代</strong>和<strong>老年代</strong></p>
<ul>
<li><p>新生代：对象存活率低，垃圾多；</p>
</li>
<li><p>老年代：对象存活率高，垃圾少。</p>
</li>
</ul>
<p>基于上述算法的优缺点，分代收集的策略是：<em>对新生代采用复制算法，对老年代采用标记-清除或标记-整理算法</em> 。</p>
<p>在新生代中，分为：较大的<strong>Eden空间</strong>和两块较小的<strong>Survivor空间</strong>。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt></p>
<ol>
<li><p>在新生代中，先使用Eden和一块Survivor区域，另一块Survivor区域保留，其空间比例一般为8：1：1；</p>
</li>
<li><p>回收时，Eden和Survivor(From)中<strong>存活时间长和大对象直接进入老年代</strong>，其余存活对象进入Survivor(To)区域；</p>
</li>
<li><p>当Survivor(To)区域空间不足时，利用<strong>分配担保机制</strong>，非存活时间长或大对象的存活对象同样被放入老年代中；</p>
</li>
<li><p>清理Eden和Survivor(From)。</p>
</li>
</ol>
<h4 id="2-HotSpot-的算法实现"><a href="#2-HotSpot-的算法实现" class="headerlink" title="2. HotSpot 的算法实现"></a>2. HotSpot 的算法实现</h4><p>（1）在可达性分析算法中，如何快速、精确地找出（枚举）根节点（GC Roots）？</p>
<p>精确：GC进行时停止所有 Java线程，确保分析时引用关系不再变化；</p>
<p>速度：OopMap（Ordinary Object Pointer Map）普通对象指针的Map数据结构，保存对象引用信息。</p>
<p>（2）Safe Point &amp; Safe Region</p>
<blockquote>
<p>安全点：GC中断线程的“位置”</p>
</blockquote>
<h3 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h3><p>重要概念：</p>
<p>（1）在垃圾收集器中，并发（Concurrent）与并行（Parallel）的区别：</p>
<ul>
<li><p>并发：用户进程与垃圾收集进程并发执行。单CPU环境，只能交替执行；多CPU环境，可同时执行。</p>
<blockquote>
<p><em>CMS 在并发标记、清理阶段</em></p>
</blockquote>
</li>
<li><p>并行：用户进程暂停，在多CPU环境中，多条垃圾收集线程可同时执行。</p>
</li>
</ul>
<p>在垃圾收集器中，并发与并行的重要区别在于<strong>前者不用暂停用户进程，后者必须暂停用户进程</strong>，这与常说的线程并发和并行的概念还是有点不同！单核和多核环境只决定了线程能否同时执行。</p>
<p>（2）吞吐量与GC停顿时间的关系</p>
<ul>
<li><p>吞吐量越高，表示CPU利用效率越高</p>
</li>
<li><p>GC停顿时间缩短是以牺牲吞吐量和新生代空间大小换来的</p>
</li>
</ul>
<p>因此，追求更短的 GC停顿时间，适合交互频繁的场景，代价是 CPU利用率下降；追求更高的 CPU利用率，适合计算量大的场景，代价是 GC停顿时间延长。*</p>
<p>（3）Minor GC 和 Full GC</p>
<ul>
<li><p>Minor GC：发生在新生代的垃圾收集动作，GC 频繁且速度快；</p>
</li>
<li><p>Major GC / Full GC：发生在老年代，速度比 Minor GC 慢。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt></p>
<h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p>（1）单线程：单条GC线程完成收集，且必须暂停其它所有用户正常工作线程（中断其它的 Java 线程）；</p>
<p>（2）对于单CPU环境，Serial 没有线程交互开销，最高的单线程收集效率；</p>
<p>（3）Client 模式下默认的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/Serial.jpg" alt></p>
<h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p>（1）多线程：多条GC线程（多核时才可能同时执行），且必须暂停其它所有用户正常工作线程；</p>
<p>（2）除多线程外，ParNew 其余实现与 Serial 相同；</p>
<p>（3）对于单CPU环境，ParNew 存在线程交互开销，效率低于 Serial；</p>
<p>（4）对于多核CPU环境，ParNew 因多线程并行，效率一般高于 Serial；</p>
<p>（5）Server模式下首选的新生代收集器。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParNew.jpg" alt></p>
<h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>（1）与 ParNew 在基本实现上相似；</p>
<p>（2）吞吐量优先：在GC停顿时间和CPU效率间平衡选择，不同于 CMS 等收集器追求尽可能短的 GC 停顿时          间；</p>
<p>（3）GC Ergonomics：自适应调节策略。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParallelScavenge.jpg" alt></p>
<h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p>（1）Serial 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p><img src="/2019/11/11/Java学习之虚拟机/SerialOld.jpg" alt></p>
<h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p>（1）Parallel Scavenge 收集器的 老年代 版</p>
<p>（2）标记 - 整理 算法</p>
<p>（3）Parallel Scavenge + Parallel Old 组合：吞吐量优先，适合注重吞吐量和CPU资源敏感的场景</p>
<p><img src="/2019/11/11/Java学习之虚拟机/ParallelOld.jpg" alt></p>
<h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p>（1）标记 - 清理 算法</p>
<p>（2）突出点：CMS ( Concurrent Mark Sweep ) 收集器在运行期间，<strong>不需要一直中断其它线程</strong>，因此能实现<strong>最短的 GC 停顿时间</strong></p>
<p>（3）分为以下四个步骤：</p>
<ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清理</p>
</li>
</ul>
<p>其中，并发标记 / 并发清理期间，不暂停其它 CPU 核上的线程，耗时较长；初始标记 / 重新标记期间，需要暂停其它所有线程，耗时较短。</p>
<p>（4）CMS 的不足：</p>
<ul>
<li><p>对CPU资源敏感，使吞吐量下降，CPU利用率降低</p>
</li>
<li><p>并发清理阶段其它用户线程产生的“浮动垃圾”须等到下次GC</p>
</li>
<li><p>潜在的 Concurrent Mode Failure 问题</p>
</li>
<li><p>清理算法产生大量空间碎片</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/CMS.jpg" alt></p>
<h4 id="7-G1-Garbage-First-收集器"><a href="#7-G1-Garbage-First-收集器" class="headerlink" title="7. G1( Garbage-First ) 收集器"></a>7. G1( Garbage-First ) 收集器</h4><p>基本原理：Region + 区域回收优先级</p>
<p>(1) 不再使用 新生代 / 老年代 划分，而是使用 <strong>Region</strong> 划分堆内存区域；</p>
<p>(2) G1追踪不同的 Region，并维护 <strong>优先列表</strong>，由此决定优先GC的区域；</p>
<p>(3) 不同的Region之间的对象引用关系保存在 Remembered Set中（新生代与老年代之间亦是）。</p>
<p><em>优点：</em></p>
<ul>
<li><p>更适合多 CPU的环境；</p>
</li>
<li><p>可独自运作，且对寿命不同的对象也采取不同的策略；</p>
</li>
<li><p>无内存碎片；</p>
</li>
<li><p><strong>可预测的暂停</strong>。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/g1.jpg" alt></p>
<p>运行过程如下：</p>
<ol>
<li><p>初始标记：标记GC Roots直接关联的对象；</p>
</li>
<li><p>并发标记：可达性分析，耗时长、与其它 Java线程并发；</p>
</li>
<li><p>最终标记：Remembered Set Logs中数据（记录并发标记阶段的引用变化）与Remembered Set合并；</p>
</li>
<li><p>筛选回收：有选择地确定GC Region。</p>
</li>
</ol>
<h3 id="五、虚拟机类加载"><a href="#五、虚拟机类加载" class="headerlink" title="五、虚拟机类加载"></a>五、虚拟机类加载</h3><p><strong><em>虚拟机将编译得到的字节码文件加载到内存，经连接、解析等过程，得到可直接使用的 Java 类型的过程，称为类加载</em></strong>。</p>
<p><strong><em>程序运行时期进行</em></strong></p>
<h4 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h4><p>类的生命周期如下图</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt></p>
<h5 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h5><p>加载Class文件过程三个动作：</p>
<ol>
<li><p>通过<strong>非数组类</strong>的全限定名获取二进制字节流，但具体的获取途径并未规定（可以从ZIP包、网络、JSP文件等）；</p>
<blockquote>
<p><em>数组类直接由虚拟机加载，不经过类加载器</em></p>
</blockquote>
</li>
<li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</p>
</li>
<li><p>在内存中生成类的访问入口对象 java.lang.Class。</p>
<blockquote>
<p><em>HotSpot 虚拟机将 Class 对象存放在方法区</em></p>
</blockquote>
</li>
</ol>
<h5 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h5><p><img src="/2019/11/11/Java学习之虚拟机/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E6%B5%81%E7%A8%8B.jpg" alt></p>
<blockquote>
<p>符号引用验证发生于解析阶段，说明<strong>类加载过程各项“工作”是按先后顺序开始，但不一定是前一阶段结束才开始后一阶段，不同阶段的“工作”可并行</strong></p>
</blockquote>
<h5 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h5><p>在方法区为<strong>类静态变量</strong>分配内存并初始化为零值，<strong>final</strong>修饰的<strong>类静态常量</strong>赋给定的初值</p>
<h5 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h5><p>（1）符号引用：存放于常量池中的常量，包括：</p>
<ol>
<li><p>类和接口的全限定名；</p>
</li>
<li><p>字段名和描述符；</p>
</li>
<li><p>方法名和描述符。</p>
</li>
</ol>
<p>（2）解析过程：将符号引用解析、翻译，匹配对应的物理内存地址，即直接引用。</p>
<h5 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h5><p>初始化阶段，执行类构造器的 <code>&lt;clinit&gt;()</code> 方法</p>
<blockquote>
<p>类变量赋值语句 &amp;&amp; 静态代码块</p>
</blockquote>
<h4 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h4><p>双亲委派模型的要点：</p>
<ol>
<li><p>子类加载器先请求父类加载器尝试加载；</p>
</li>
<li><p>父类加载器无法加载时，子类加载器再尝试加载；</p>
</li>
<li><p><strong>所有的加载请求首先被启动类加载器处理</strong>。</p>
</li>
</ol>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt></p>
<h3 id="六、并发"><a href="#六、并发" class="headerlink" title="六、并发"></a>六、并发</h3><h4 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h4><blockquote>
<p>定义了<strong>线程共享的变量</strong>从虚拟机内存中被读取或写入的底层实现</p>
<p>线程共享变量：实例字段、静态字段、构成数组对象的元素</p>
</blockquote>
<h4 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1 主内存与工作内存"></a>1.1 主内存与工作内存</h4><ul>
<li><p>工作内存中保存主内存中（共享）变量的拷贝副本；</p>
</li>
<li><p>工作内存中还保存了<strong>线程私有的变量</strong>；</p>
</li>
<li><p>线程对（共享）变量的读写操作必须经过工作内存才可与主内存交互；</p>
</li>
<li><p>线程间（共享）变量值的传递须借助主内存。</p>
</li>
</ul>
<p><img src="/2019/11/11/Java学习之虚拟机/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<h4 id="1-2-内存间交互"><a href="#1-2-内存间交互" class="headerlink" title="1.2 内存间交互"></a>1.2 内存间交互</h4><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">作用对象</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock</td>
<td align="center">主内存中的变量</td>
<td align="center">锁定状态，线程独占</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">主内存中的变量</td>
<td align="center">解除锁定状态</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">主内存中的变量</td>
<td align="center">将变量值传输至对应的工作内存中</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">工作内存中的变量</td>
<td align="center">read 操作后，将变量值放入工作内存的变量副本中</td>
</tr>
<tr>
<td align="center">use</td>
<td align="center">工作内存中的变量</td>
<td align="center">使用变量值</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">工作内存中的变量</td>
<td align="center">赋值</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">工作内存中的变量</td>
<td align="center">将变量值传输至主内存中</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">主内存中的变量</td>
<td align="center">store 操作后，变量值存入主内存的变量中</td>
</tr>
</tbody></table>
<h4 id="1-3-原子性、可见性和有序性"><a href="#1-3-原子性、可见性和有序性" class="headerlink" title="1.3 原子性、可见性和有序性"></a>1.3 原子性、可见性和有序性</h4><p>（1）原子性</p>
<ol>
<li>read、load、use、assign、store、write 均为原子性的变量操作，实现<strong>基本数据类型的访问和读写操作是原子性的</strong>；</li>
<li>lock 和 unlock 操作，更大范围内实现原子性（<strong>synchronized</strong> 关键字）。</li>
</ol>
<p>（2）可见性</p>
<ol>
<li><strong>volatile</strong> 关键字，<strong>最轻量级的同步机制</strong>，其修饰的变量对所有线程是可见的；</li>
<li>final 关键字；</li>
<li><strong>synchronized</strong> 关键字，同步代码块。</li>
</ol>
<p>（3）有序性</p>
<ol>
<li><em>线程内表现为串行的语义</em> ：在本线程内观察，操作是有序的；</li>
<li><em>指令重排</em> &amp; <em>工作内存与主内存同步延迟</em> ： 从另一个线程观察，被观察线程内的操作是无序的。</li>
</ol>
<h4 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2. Java线程"></a>2. Java线程</h4><blockquote>
<p>线程将进程的<strong>资源分配</strong>和<strong>执行调度</strong>分开，线程共享进程资源（内存地址、文件I/O等），线程独立被CPU调用、执行。</p>
</blockquote>
<p>实现线程的三种方式：内核线程实现、用户线程实现、用户线程加轻量级进程的混合实现。</p>
<h5 id="2-1-内核线程实现"><a href="#2-1-内核线程实现" class="headerlink" title="2.1 内核线程实现"></a>2.1 内核线程实现</h5><p><em>内核线程（Kernel-Level Thread, KLT）*：由操作系统内核完成线程切换、调度、任务映射等操作，用户程序通过 *轻量级进程 （Light Weight Process, LWP)</em> 接口使用内核线程。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：系统调用代价高</p>
</blockquote>
<h5 id="2-2-用户线程实现"><a href="#2-2-用户线程实现" class="headerlink" title="2.2 用户线程实现"></a>2.2 用户线程实现</h5><p><em>用户线程（User Thread, UT）</em> ：建立在用户空间的线程库，用户线程的建立、同步、调度和销毁在用户态中完成。</p>
<p><img src="/2019/11/11/Java学习之虚拟机/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<blockquote>
<p>特点：用户态操作，代价小；实现过程异常复杂。</p>
</blockquote>
<h5 id="2-3-用户线程加轻量级进程的混合实现"><a href="#2-3-用户线程加轻量级进程的混合实现" class="headerlink" title="2.3 用户线程加轻量级进程的混合实现"></a>2.3 用户线程加轻量级进程的混合实现</h5><blockquote>
<p>轻量级进程是用户线程与内核线程之间的桥梁</p>
</blockquote>
<p><img src="/2019/11/11/Java学习之虚拟机/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] 《深入理解Java虚拟机》周志明 著</p>
<p>[2] <a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p>
<p>[3] <a href="https://blog.csdn.net/wen7280/article/details/54428387" target="_blank" rel="noopener">https://blog.csdn.net/wen7280/article/details/54428387</a></p>
<p>[4] <a href="https://www.jianshu.com/p/114bf4d9e59e" target="_blank" rel="noopener">https://www.jianshu.com/p/114bf4d9e59e</a></p>
<p>[5] <a href="https://www.jianshu.com/p/50d5c88b272dc" target="_blank" rel="noopener">https://www.jianshu.com/p/50d5c88b272dc</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>集合源码一：HashMap源码阅读笔记</title>
    <url>/2019/09/05/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于 JDK 1.8 的HashMap阅读笔记，主要包括如下方面：</p>
<ul>
<li>HashMap的属性、构造方法及常用方法源码分析。</li>
<li>自定义的类，如何确保Key的一致性？</li>
<li>HashMap在JDK 1.8与JDK 1.7中的差异。</li>
</ul>
<a id="more"></a>

<h4 id="1-HashMap的概述"><a href="#1-HashMap的概述" class="headerlink" title="1. HashMap的概述"></a>1. HashMap的概述</h4><ul>
<li>HashMap允许空的键和空的值，是线程不安全的。Hashtable不允许空的键和空的值，是线程安全的。</li>
<li>HashMap不保证有序。</li>
<li>如果迭代性能很重要，则不要将初始容量设置得过高（或负载因子过低）。</li>
<li>多线程结构修改时（添加或删除键值对）必须保证同步，如Collections.synchronizedMap方法返回一个同步的Map。</li>
</ul>
<hr>
<h4 id="2-字段"><a href="#2-字段" class="headerlink" title="2. 字段"></a>2. 字段</h4><h5 id="2-1-静态常量"><a href="#2-1-静态常量" class="headerlink" title="2.1 静态常量"></a>2.1 静态常量</h5><p>（1）<strong>初始容量</strong>：16，且必须为2的幂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap规定哈希数组的容量为2的次幂。设n为容量。当n为2的幂时，转化成二进制为：100…00。在计算索引时（hash&amp;(n-1)），n-1为：011…11。</p>
<p>对于小于n-1的哈希值，索引位置就是哈希值；对于大于n-1的哈希值，索引位置就是取模。</p>
<p>因此，在获取索引时提高了与运算的速度，且保证了散列的均匀性。</p>
</blockquote>
<p>（2）<strong>最大容量</strong>：2^30 且应该为2的次幂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：那最大容量为什么不是 <code>1 &lt;&lt; 31</code> 呢？<code>1 &lt;&lt; 31</code> 的结果是-2147483648。</p>
<p>那最大容量为什么不是 <code>Integer.MAX_VALUE</code> ，即 <code>2^31 - 1</code> 呢？规定哈希数组的容量为2的幂。</p>
</blockquote>
<p>（3）<strong>默认负载因子</strong>：选择0.75是空间与时间的均衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>（4）<strong>链表转树的阈值</strong>：当链表结点个数达到TREEIFY_THRESHOLD时，链表转换为红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：为什么选择8？</p>
<p>理想情况下使用随机的哈希值，节点分布在桶中的频率遵循泊松分布。按照泊松分布的计算可以明确，链表中元素个数达到8时，其概率已经很低。因此，选择8是根据概率计算得到的一个合适的值，它既不会使链表长度不足，又不是令其太长。</p>
</blockquote>
<p>（5）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>哈希表容量达到MIN_TREEIFY_CAPACITY时，才允许链表转换成红黑树。</p>
<ul>
<li>MIN_TREEIFY_CAPACITY不小于TREEIFY_THRESHOLD的4倍。</li>
<li><strong>若哈希表容量不足MIN_TREEIFY_CAPACITY，而桶内元素又太多时，直接扩容</strong>。</li>
</ul>
<p>（6）<strong>树转链表的阈值</strong>：扩容时，原红黑树内结点数量不大于UNTREEIFY_THRESHOLD时，红黑树转换为链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-实例变量"><a href="#2-2-实例变量" class="headerlink" title="2.2 实例变量"></a>2.2 实例变量</h5><p>（1）<strong>modCount</strong>：记录哈希表的结构修改次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>使用迭代器时，若调用HashMap的remove()方法试图删除元素时，会抛出ConcurrentModificationException异常（fail-fast策略）。</p>
<p>其底层实现正是基于modCount属性。</p>
<p>每一次对HashMap对象<strong>结构的修改</strong>，modCount加1。在迭代器初始化时，会将该值赋予迭代器的expectedModCount变量。迭代过程中，如调用迭代器的next()方法，会调用checkForComodification()方法以检查modCount是否等于expectedModCount。若是，则正常；若否，则抛出异常。</p>
<p>因此，在使用迭代器时，必须使用迭代器的remove()方法移除集合元素。这一过程的本质是迭代器对象调用集合的remove()方法<strong>并将被修改的modCount值重新赋予expectedModCount变量</strong>，使二者保持一致。</p>
<hr>
<h4 id="3-节点内部类"><a href="#3-节点内部类" class="headerlink" title="3. 节点内部类"></a>3. 节点内部类</h4><p>（1）Node静态内部类：数组元素和链表节点。</p>
<blockquote>
<p>JDK 1.7中为Entry类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断两个Entry是否相等，仅当key和value均相等时，返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）TreeNode静态内部类：红黑树的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*其它方法略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h4><p>HashMap中的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>; <span class="comment">// 默认负载因子，0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>; <span class="comment">// 默认的初始容量，16；默认的负载因子，0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（1）使用指定的初始容量和负载因子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量大于最大容量时，将其置为最大容量。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 大于initialCapacity且最接近的2的次幂。</span></span><br><span class="line"><span class="comment">     * 随后扩容阈值还是会被重新计算。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>threshold：需要扩容时的阈值，在此先对其调用 tableSizeFor()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法返回的是一个<strong>大于形参且最接近的2的幂的值</strong>。<strong>创建哈希表时，threshold阈值会重新赋值</strong>。</p>
<p>（2）其它构造函数</p>
<p>都是调用第一种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用与指定Map相同的映射构造一个新的HashMap</p>
<p>此构造方法使用与指定Map相同的映射构造一个新的HashMap。 使用默认的加载因子（0.75）和足以将映射保存在指定Map中的初始容量创建HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将指定Map中的键值对复制进HashMap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>; <span class="comment">// 重新计算初始容量</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5. put方法"></a>5. put方法</h4><p>HashMap的put方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）首先看计算key哈希值的方法：</p>
<ul>
<li><p>当key为null时，哈希值为0；</p>
</li>
<li><p>否则，调用Object基类的native的hashCode()方法，且将哈希值的高16位做异或运算。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：为什么要对高16位做异或运算？</p>
<p>putVal方法中的第二个if语句，p = tab[i = (n - 1) &amp; hash] 。我们是根据key的哈希值来保存在散列表中的，我们表默认的初始容量是16，要放到散列表中，就是0-15的位置上。也就是<code>tab[i = (n - 1) &amp; hash]</code>。</p>
<p>可以发现的是：在做<code>&amp;</code>运算的时候，仅仅是<strong>后4位有效</strong>。那如果我们key的哈希值高位变化很大，低位变化很小。直接拿过去做<code>&amp;</code>运算，这就会导致计算出来的Hash值相同的很多，即哈希冲突严重。使用异或运算，向下传播较高位的影响，，否则由于表范围的限制，这些位将永远不会在索引计算中使用。</p>
</blockquote>
<p><em>详细解析如下：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设现有键A和键B，通过调用hashCode方法计算得到的hash分别为:</span><br><span class="line">A: 1111 1111 1111 0000 0000 0000 0000 0001</span><br><span class="line">B: 0000 0000 0000 1111 1111 1111 1111 0001</span><br><span class="line">假设底层数组长度为8，即n=7，二进制表示为：</span><br><span class="line">n: 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line"></span><br><span class="line">对A和n做&amp;运算得：</span><br><span class="line">   0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line">对B和n做&amp;运算得：</span><br><span class="line">   0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line">可见，虽然A和B的hash相差甚远，但是它们还是被分入同一个桶中。</span><br></pre></td></tr></table></figure>

<p>当有大量的<strong>高位变化明显、但低位不变化</strong>的hash结果时，会造成哈希冲突严重，使得散列不均匀。</p>
<p>为了解决这一问题，采用<strong>用key的哈希值的高16位与其自身做异或运算</strong>的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先对A和A的高16位做异或运算，再与n做与运算：</span><br><span class="line">  1111 1111 1111 0000 0000 0000 0000 0001</span><br><span class="line">^ 0000 0000 0000 0000 1111 1111 1111 0000</span><br><span class="line">  1111 1111 1111 0000 1111 1111 1111 0001</span><br><span class="line">&amp; 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">  0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br><span class="line"></span><br><span class="line">对B和B的高16位做异或或运算，再与n做与运算：</span><br><span class="line">  0000 0000 0000 1111 1111 1111 1111 0001</span><br><span class="line">^ 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">  0000 0000 0000 1111 1111 1111 1111 1110</span><br><span class="line">&amp; 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">  0000 0000 0000 0000 0000 0000 0000 0110 = 6</span><br></pre></td></tr></table></figure>

<p>经过处理，A和B对应的Node元素将存入数组tab的不同索引！</p>
<p>因此，hash(Object key)方法的目的在于：对于HashMap这种数组总长度一般不大（一般小于2^16）的情形，将哈希值高位的变化传递至低位，使得散列更加均匀。</p>
<p>至于为什么选择 <code>^</code> ？这是因为相较于 <code>&amp;</code> 和 <code>|</code> ，<code>^</code> 得到1/0的概率均为50%，更加符合hash算法设计的初衷。</p>
<p>（2）调用putVal方法</p>
<ul>
<li>hash：key的哈希值</li>
<li>key：键</li>
<li>value：待插入的值</li>
<li>onlyIfAbsent：true - 不更新已存在的旧值；false - 更新已存在的旧值</li>
<li>evict：false - 哈希表处于创建模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 散列表不存在或散列表长度为0时，调用resize()方法以初始化哈希表。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 当对应的桶为空时，新建一个Node结点，并将其放入桶中。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 对应的桶不为空，即桶中至少有一个元素。桶中链表的头结点指针此时为p。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 判断数组tab存储的是否为同一个key元素，若是则通过变量e记录之，</span></span><br><span class="line"><span class="comment">         * 以便在下面的代码中用新值value覆盖旧值。</span></span><br><span class="line"><span class="comment">         * 通过分别验证hashCode相等和key相等来保证key的唯一性。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果结点p为红黑树结点，则调用数的插入方法插入。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * key不是桶中链表的头结点，则沿链表寻找对应的结点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 未找到结点，在链表尾部插入新结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 插入新结点后，链表长度达到链转树的阈值时，链表转换为红黑树。</span></span><br><span class="line"><span class="comment">                     * TREEIFY_THRESHOLD-1：减去头结点。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到对应的结点，使用指针p记录该结点。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用新值更新旧值，并返回旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 记录对HashMap结构上的修改次数</span></span><br><span class="line">    <span class="comment">// 哈希表的尺寸超过扩容阈值，执行扩容操作。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引申：计算哈希数组的下标位置，为何要使用tab[i = (n - 1) &amp; hash]的操作？直接使用哈希值作为数组的索引不行吗？</p>
<p>答：Object类的hashCode()方法是根据<strong>对象的内存地址经特定算法计算得到的整型参数</strong>，其范围广。HashMap的容量一般不大，显然不合适。</p>
<p>在HashMap中，与运算是根据其容量大小，<strong>取哈希值一定数量的低位作为下标</strong>，其本质是将哈希值对容量取模。</p>
<p>以上，包括对哈希值进行异或运算和与运算，其核心目的都是为了使哈希过程随机化和均匀化，避免过度的哈希冲突。</p>
</blockquote>
<p>（3）key的一致性</p>
<p>在putVal方法中，判断key是否相同时，使用了如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))</span><br></pre></td></tr></table></figure>

<p>首先来看Object基类的equals(Object obj)方法，根据 JDK 1.8的API文档，其有如下特性：</p>
<ul>
<li>自反性：对任何非空的 x，x.equals(x) 返回true；</li>
<li>对称性：对任何非空的 x 和 y，当且仅当 x.equals(y) 返回 true 时，y.equals(x) 才返回true；</li>
<li>传递性：对任何非空的 x、y 和 z，若 x.equals(y) 和 y.equals(z) 均返回true，x.equals(z) 也应该返回true；</li>
<li>一致性：对任何非空的 x 和 y，若未加修改，那么多次调用 x.equals(y) 方法，返回结果均保持一致。</li>
<li>对任何非空的 x，x.equals(null) 应返回false。</li>
<li>对任何非空的 x 和 y，当且仅当 x 和 y 引用相同的对象（即 x==y）时，x.equals(y) 方法才返回true。可见，基类Object的equals方法本质上是<strong>内存地址比较</strong>。</li>
</ul>
<p>再来看看Object类的hashCode()方法，它有如下约定：</p>
<ul>
<li>对同一个对象多次调用，返回相同的哈希值；</li>
<li>equals方法返回true的两个对象，应返回相同的哈希值；</li>
<li>equals方法返回false的两个对象，对返回的哈希值没有明确要求，可相同也可不相同。</li>
</ul>
<p>综上，关于equals方法和hashCode方法有一个重要的约定：<strong>equals方法返回true时，hashCode方法返回相同的哈希值。</strong></p>
<p><strong><em>那么，对于自定义的 key类，如何保证 key的一致性呢？</em></strong></p>
<blockquote>
<p>结论：重写equals和hashCode方法，以满足上述约定。</p>
</blockquote>
<p><em>坏例子</em></p>
<p>自行定义一个 Key 的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get/set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立 HashMap 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stA和stB指向的均为同一个人</span></span><br><span class="line">    Student stA = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="string">"007"</span>);</span><br><span class="line">    Student stB = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="string">"007"</span>);</span><br><span class="line">    HashMap&lt;Student, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(stA, <span class="number">97</span>);</span><br><span class="line">    map.put(stB, <span class="number">75</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;Student@<span class="number">15</span>db9742=<span class="number">97</span>, Student@<span class="number">6</span>d06d69c=<span class="number">75</span>&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>stA</code> 和 <code>stB</code> 指向同一个对象，二者的 <code>key</code> 应该是相同的，但输出结果表明二者的 <code>key</code> 是不同的。</p>
<p>在HashMap的源码中，是<strong>通过比较hash相等和key相等来保证key的一致性的</strong>。对于Student类，其equals方法实际上调用的是Object基类的equals方法，即比较 <code>stA</code> 和 <code>stB</code> 的<strong>内存地址</strong>。</p>
<p>显然，<code>stA</code> 和 <code>stB</code> 表明同一个人，是指其name和id属性共同确定了张三这个人，但是二者的内存地址是不同的。在这里，我们比较key是否一致，应由name和id属性共同决定！</p>
<p>对于自定义的Key类，应保证<strong>重写equals方法和hashCode方法</strong>，以满足二者的约定条件，保证Key的一致性。</p>
<p><em>重写 Student 类的 equals 方法，使其实现比较 name 和 id 属性是否为相同的字符串。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass()!=obj.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Student otherObj = (Student) obj;</span><br><span class="line">    <span class="keyword">if</span>(name==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(otherObj.name!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!name.equals(otherObj.name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(otherObj.id!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!id.equals(otherObj.id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>重写 Student 类的 hashCode 方法，使其符合 equals 方法返回 true 则返回相同哈希值的约定。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ((name==<span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    result = prime * result + ((id==<span class="keyword">null</span>) ? <span class="number">0</span> : id.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;Student@<span class="number">16f</span>482f=<span class="number">75</span>&#125;</span><br></pre></td></tr></table></figure>

<p>保证了 Key 的一致性！</p>
<hr>
<h4 id="6-resize方法"><a href="#6-resize方法" class="headerlink" title="6. resize方法"></a>6. resize方法</h4><p>final修饰的resize()方法：初始化和扩容时使用。</p>
<ul>
<li>初始化时，将哈希表的初始容量设置为16，扩容阈值设置为12。</li>
<li>扩容时，新表的容量和扩容阈值均被设置为旧表的2倍。</li>
<li>当旧表容量超过最大容量（2^30）时，无法扩容。只能将扩容阈值设为整型最大值（2^31 - 1）,并返回旧的哈希表。</li>
<li>JDK 1.8 开始，向链表中插入结点的方式由头插法（JDK 1.7）修改为尾插法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/***当前旧的哈希表容量大于0***/</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 旧的哈希表容量已超过最大容量（2^30），无法扩容。</span></span><br><span class="line"><span class="comment">         * 只能将扩容阈值设为整型最大值（2^31 - 1）,并返回旧的哈希表。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新表的容量和扩容阈值均被设为旧表的2倍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***当前旧的哈希表容量等于0***/</span></span><br><span class="line">    <span class="comment">// 旧表的扩容阈值大于0，将新表的容量设为该值，新表的扩容阈值设置在第34行。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化表，表的容量设为默认值，为16；表的扩容阈值默认为12。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 构建新的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***拷贝旧表至新表的操作***/</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 桶中仅有一个结点时，计算在新表中的索引。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 循环过程实现了将Head和Tail指针分别指向链表的头尾结点。</span></span><br><span class="line"><span class="comment">                     * loHead和loTail表示结点在新表中的索引与旧表一致；</span></span><br><span class="line"><span class="comment">                     * hiHead和hiTail表示结点在新表中的索引为旧表索引+旧表容量</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+旧容量</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 新数组中的存储位置：原索引</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 新数组中的存储位置：原索引+旧容量</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容后，确定新的哈希数组中的索引的机制：</p>
<ul>
<li>扩容后，哈希表的容量为旧表的2倍。</li>
<li>重新依据hashCode &amp; (n-1)计算索引时，哈希值不变、n增大为2倍，<strong>导致最终的计算结果多了一位</strong>。<ul>
<li>哈希值对应的位为0，则新增的1对与运算结果无影响，新索引 = 旧索引；</li>
<li>哈希值对应的位为1，则新增的1对与运算结果有影响，新索引 = 旧索引+旧表容量。</li>
</ul>
</li>
</ul>
<p><strong>JDK 1.8中重新确定新的哈希数组索引的机制，相较于JDK 1.7有什么异同？</strong></p>
<ul>
<li>本质：<strong>二者相同</strong>。即JDK 1.8若重新计算hashCode，再进行与操作，得到的结果是不变的，即新索引 = 旧索引或者新索引 = 旧索引+旧表容量。</li>
<li>性能：重新计算key的哈希值需要消耗一定的性能，而JDK 1.8只需要执行一次与操作就能得到结果，显然后者更快。</li>
</ul>
<p><strong>JDK 1.7形成环状链表的风险？</strong></p>
<p>JDK 1.7在扩容时，将旧数组上的数据转移至新数组的过程中，其操作为<strong>按旧链表正序遍历，在新的桶中以头插法存入新节点</strong>。这种操作易导致<strong>链表逆序</strong>。</p>
<p>多线程并发扩容时，容易造成环形链表，导致遍历链表时形成死循环（Infinite Loop）。</p>
<p>JDK 1.8采用尾插法，避免上述问题。但需要明确的是，在JDK .18中，<strong>HashMap仍然是线程不安全的类</strong>。</p>
<hr>
<h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7. get方法"></a>7. get方法</h4><p>get(Object key)方法可返回指定key的值。若指定的key不存在或<strong>显式地为null</strong>，返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法调用getNode方法，沿链表或红黑树查找与key一致的节点。关于如何保证key的一致性，前已述及。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-remove方法"><a href="#8-remove方法" class="headerlink" title="8. remove方法"></a>8. remove方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用removeNode()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点在桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 链表头节点即是目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 头节点不是目标节点，首先判断是否已经树化，随后去树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 尚未树化，遍历链表，锁定目标节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// 修改集合结构的操作，触发modCount值变化</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-containsKey方法"><a href="#9-containsKey方法" class="headerlink" title="9. containsKey方法"></a>9. containsKey方法</h4><p>调用getNode方法，当key不存在或显式的为null时，皆返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-treeifyBin方法"><a href="#10-treeifyBin方法" class="headerlink" title="10. treeifyBin方法"></a>10. treeifyBin方法</h4><p>链表转换为红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只有当哈希表容量不小于MIN_TREEIFY_CAPACITY，链表才能转换为红黑树，</span></span><br><span class="line"><span class="comment">     * 否则，只能扩容处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-HashMap在JDK-1-7与JDK-1-8中的区别"><a href="#11-HashMap在JDK-1-7与JDK-1-8中的区别" class="headerlink" title="11.  HashMap在JDK 1.7与JDK 1.8中的区别"></a>11.  HashMap在JDK 1.7与JDK 1.8中的区别</h4><table>
<thead>
<tr>
<th align="center">不同点</th>
<th align="center">JDK 1.7</th>
<th align="center">JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">节点实现类</td>
<td align="center">Entry&lt;K, V&gt;</td>
<td align="center">Node&lt;K, V&gt;，TreeNode&lt;K, V&gt;</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">数组+链表</td>
<td align="center">数组+链表+红黑树</td>
</tr>
<tr>
<td align="center">计算key的哈希值</td>
<td align="center">4次位运算+5次异或运算</td>
<td align="center">1次位运算+1次异或运算</td>
</tr>
<tr>
<td align="center">链表节点插入方式</td>
<td align="center">尾插法</td>
<td align="center">头插法</td>
</tr>
<tr>
<td align="center">初始化方式</td>
<td align="center">单独的inflateTable方法</td>
<td align="center">集成在resize方法中</td>
</tr>
<tr>
<td align="center">扩容时计算新索引</td>
<td align="center">重新计算（慢）</td>
<td align="center">原索引或原索引+旧容量（快）</td>
</tr>
</tbody></table>
<hr>
<h4 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h4><p>基于JDK 1.8版本的HashMap。</p>
<ul>
<li><p>HashMap的初始容量默认为16，最大容量为2^30，且容量一定是2的幂。</p>
</li>
<li><p>链表转红黑树的条件：哈希表的总节点数大于或等于MIN_TREEIFY_CAPACITY（默认：64），且链表的节点数大于或等于TREEIFY_THRESHOLD（默认：8）。</p>
</li>
<li><p>HashMap真正初始化哈希表（即初始化哈希数组<code>table</code>）是在首次添加键值对，即首次调用put方法时，且真正的初始化方法集成在resize方法中。在JDK 1.7版本中，初始化哈希表是在首次调用put方法，且哈希数组为空的情况下，直接调用inflateTable方法。</p>
</li>
<li><p>在计算key的哈希值时，采用高16位异或运算，是为了将高16位的变化引入低16位，使散列更加均匀。</p>
</li>
<li><p>对于自定义的key类，应重写equals和hashCode方法，使其满足约定。</p>
</li>
<li><p>HashMap允许null的键，是因为当key为null时，哈希值为0。因此，HashMap仅允许一个键为null。</p>
</li>
<li><p>扩容时，若旧表容量超过最大值，不扩容；成功扩容后，新表容量和阈值均为旧表的2倍。</p>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://www.jianshu.com/p/d4fee00fe2f8" target="_blank" rel="noopener">HashMap源码解析</a></p>
<p>[2] <a href="https://www.jianshu.com/p/2c1491d866f7" target="_blank" rel="noopener">HashMap就是这么简单【源码剖析】</a></p>
<p>[3] <a href="https://blog.csdn.net/weixin_41888813/article/details/99715799" target="_blank" rel="noopener">如何将自定义的类对象作为key存储到HashMap中？</a></p>
]]></content>
      <categories>
        <category>集合源码</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC框架学习笔记</title>
    <url>/2019/08/26/Spring%20MVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><strong>MVC模式</strong></p>
<blockquote>
<p>Model：数据模型层，封装用户的输入/输出数据</p>
<p>Controller：控制层，前、后端交互</p>
<p>View：视图层，前端显示</p>
</blockquote>
<hr>
<h4 id="1-Spring-MVC流程"><a href="#1-Spring-MVC流程" class="headerlink" title="1. Spring MVC流程"></a>1. Spring MVC流程</h4><p>Spring MVC框架流程图如下，其中最核心的是<strong>前端控制器（DispatcherServlet）</strong></p>
<p>![](Spring MVC框架学习笔记/Spring MVC框架流程图.png)</p>
<p><em>流程描述如下：</em></p>
<ol>
<li><p>用户请求被拦截、发送至前端控制器（DispatcherServlet）；</p>
</li>
<li><p>DispatcherServlet请求处理器映射器（HandlerMapping）查找相应的处理器（Handler），HandlerMapping将Handler、Intercepter（拦截器）返回给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet根据返回的Handler，请求处理器适配器（HandlerAdapter）执行Handler；</p>
</li>
<li><p>HandlerAdapter调用自己的Handler方法，利用 Java的<strong>反射机制</strong>执行具体的Controller方法，获得ModelAndView 视图对象；</p>
</li>
<li><p>HandlerAdapter将ModelAndView 视图对象发送给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet请求视图处理器（ViewResolver）解析，返回结果；</p>
</li>
<li><p>DispatcherServlet渲染视图，<strong>将Model中的模型数据填充到View视图的Request域</strong>，生成最终的View视图；</p>
</li>
<li><p>DispatcherServlet发送Response响应至用户界面。</p>
</li>
</ol>
<h4 id="2-DispatcherServlet"><a href="#2-DispatcherServlet" class="headerlink" title="2. DispatcherServlet"></a>2. DispatcherServlet</h4><p>DispatcherServlet是Spring MVC处理Http请求的核心组件：</p>
<p>（1）其顶级父类是HttpServlet，因此DispatcherServlet本质上是一个Servlet；</p>
<p>（2）其中的doService方法负责处理request请求；</p>
<p>（3）核心方法<strong>doDispatch</strong>负责处理拦截，转发请求，调用处理器获得结果，并得到结果视图。</p>
<p>web.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用配置的springmvc.xml文件对DispatcherServlet进行初始化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置拦截url符合".action"的请求至前端处理器DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-HandlerMapping"><a href="#3-HandlerMapping" class="headerlink" title="3. HandlerMapping"></a>3. HandlerMapping</h4><p>HandlerMapping常见有：BeanNameUrlHandlerMapping、SimpleUrlHandlerMapping、ControllerClassNameHandlerMapping。</p>
<p>Springmvc.xml配置如下</p>
<p>（1）BeanNameUrlHandlerMapping</p>
<p>映射规则：将bean的name作为url进行匹配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器BeanNameUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置被url映射的Handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/test.action"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）SimpleUrlHandlerMapping</p>
<p>通过<property>标签配置url与handler的映射关系</property></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器SimpleUrlHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_A"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"Interceptor_B"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Handler --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA.action"</span>&gt;</span>ControllerTestA<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB.action"</span>&gt;</span>ControllerTestB<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）ControllerClassNameHandlerMapping</p>
<p>采用CoC惯例优先原则</p>
<ul>
<li><p>对普通的Controller类，将类名“xxxController”映射至“/xxx*”的请求url</p>
</li>
<li><p>对MultiActionController（多动作控制器）类，会将特定的方法“yyy”映射至“/xxx/yyy.action”的请求url</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.support.ControllerBeanNameHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-HandlerAdapter"><a href="#4-HandlerAdapter" class="headerlink" title="4. HandlerAdapter"></a>4. HandlerAdapter</h4><p>（1）SimpleControllerHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>SimpleControllerHandlerAdapter要求编写实现Controller接口的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	modelAndView.addObject();</span><br><span class="line">	modelAndView.setViewName();</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）HttpRequestHandlerAdapter</p>
<p>springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>HttpRequestHandlerAdapter要求编写实现<strong>HttpRequestHandler接口</strong>的Handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">package</span> cn.merlin.ssm.controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.HttpRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">	request.setAttribute();</span><br><span class="line">	request.getRequestDispatcher();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpRequestHandlerAdapter与 SimpleControllerHandlerAdapter相比优点在于：</em></strong></p>
<ul>
<li>前者可以通过request获得http请求信息，及设置返回对象response的格式，如 JSON串！</li>
</ul>
<h4 id="5-注解方式使用HandlerMapping和HandlerAdapter"><a href="#5-注解方式使用HandlerMapping和HandlerAdapter" class="headerlink" title="5. 注解方式使用HandlerMapping和HandlerAdapter"></a>5. 注解方式使用HandlerMapping和HandlerAdapter</h4><p>“但是这种开发模式有一个缺点，<strong>一个Handler类中只能编写一个方法</strong>“”。</p>
<p>注：上面原话来自于《Spring MVC+Mybatis开发从入门到项目实战》p151。但是对这句话的理解产生了歧义！如MultiActionController类中就能编写多个处理方法。</p>
<p>改成：<strong>一个Handler类中一般只能编写一个处理方法</strong>。</p>
<blockquote>
<p>通过注解的方式，可以在单个Handler中通过@RequestMapping注解方式配置多个方法！</p>
</blockquote>
<p>（1）配置方式</p>
<p>使用默认的注解的映射器和适配器</p>
<blockquote>
<p>Spring MVC使用的默认注解的映射器和适配器是<strong>RequestMappingHandlerMapping</strong>和<strong>RequestMappingHandlerAdapter</strong></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者手动注明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）编写Handler类</p>
<p>此时，Handler不需要实现Controller接口或者HttpRequestHandler：</p>
<p><strong>@Controller</strong>：标明Handler控制器类</p>
<p><strong>@RequestMapping</strong>：将url请求映射至Handler类中特定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.merlin.ssm.</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModerlAndView</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/queryMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/deleteMethod"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）配置Handler类的bean</p>
<p>逐个Handler类配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.controller.ControllerTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或扫描指定包下所有@Controller注解的Handler类（推荐）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.merlin.ssm.controller"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Handler"><a href="#6-Handler" class="headerlink" title="6. Handler"></a>6. Handler</h4><h5 id="6-1-请求映射-RequestMapping注解"><a href="#6-1-请求映射-RequestMapping注解" class="headerlink" title="6.1 请求映射@RequestMapping注解"></a>6.1 请求映射@RequestMapping注解</h5><p>（1）请求路径</p>
<ol>
<li><p>类上注解@RequestMapping：请求域，相对Web应用根目录，表示此Handler所有方法的请求路径均在此路径下；</p>
</li>
<li><p>方法上注解@RequestMapping：相对于请求域路径。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求URL为：http://localhost:8080/"WebProjectName"/RequestArea/test.action</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"RequestArea"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerDemo</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）限定请求</p>
<blockquote>
<p>只能在方法上@RequestMapping实现</p>
</blockquote>
<ol>
<li><p>限制请求方法：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</p>
<p>@RequestMapping(value=”/test”, method=RequestMethod.GET)  // 限制请求方法为GET</p>
</li>
<li><p>限制请求参数：</p>
<p>@RequestMapping(value=”/test”, params=”username”) // 限制请求参数中必须含参数“username”</p>
</li>
<li><p>限制请求头：</p>
<p>@RequestMapping(value=”/test”, headers=”Content-Type:text/html;charset=”utf-8”)</p>
</li>
</ol>
<h5 id="6-2-参数绑定"><a href="#6-2-参数绑定" class="headerlink" title="6.2 参数绑定"></a>6.2 参数绑定</h5><p>（1）可直接绑定的类型：HttpRequest、HttpResponse、HttpSession、Model、ModelMap</p>
<p>（2）简单参数</p>
<ul>
<li><p>value：查询结果字段名 user_id 与 Java实体类中成员变量名 userId 可以不一致；</p>
</li>
<li><p>defaultValue：默认值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=&#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryDemo</span><span class="params">(Model model,@RequestParam(value=<span class="string">"user_id"</span>,defaultValue=<span class="string">"1"</span>)</span> Integer userId)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）绑定包装类</p>
<p>Spring MVC会完成创建相应的实体类 Fruit 并使用set方法注入属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/queryFruitsByCondition"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryFruitsByCondition</span><span class="params">(Model model,Fruit fruit)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）绑定集合</p>
<h4 id="7-视图解析器"><a href="#7-视图解析器" class="headerlink" title="7. 视图解析器"></a>7. 视图解析器</h4><h5 id="7-1-Spring-MVC中的视图解析器"><a href="#7-1-Spring-MVC中的视图解析器" class="headerlink" title="7.1 Spring MVC中的视图解析器"></a>7.1 Spring MVC中的视图解析器</h5><p>（1）AbstractCachingViewResolver</p>
<p>抽象类，定义了视图解析器<strong>缓存</strong>已解析视图的方法。</p>
<p>（2）UrlBasedViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存功能；</p>
</li>
<li><p>前缀属性prefix指定视图资源所在路径的前缀，后缀属性suffix指定视图资源所在路径的后缀；</p>
</li>
<li><p>支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀prefix属性指定了视图资源所在路径的前缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀suffix属性指定了视图资源所在路径的后缀信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解析至指定的视图，此处用来展示jsp页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>InternalResourceView类在服务器端通过<em>跳转</em> 的方式访问不能直接访问的/WEB-INF/目录下的资源</p>
<p><strong>（3）InternalResourceViewResolver</strong></p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存功能 + 支持<strong>“redirect:” 重定向</strong> 和 <strong>“forword:”内部跳转</strong>；</p>
</li>
<li><p>viewClass指定为InternalResourceView，因此不支持解析为其它视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jspViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体实现实例如下：</p>
<p>对于UserController类，其实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	定义toLogin()方法，处理拦截器传来的重定向至登录</span></span><br><span class="line"><span class="comment">	 *	页面的请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/user/toLogin.action"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/login.jsp"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器返回一个ModelAndView对象，InternalResourceViewResolver将名为“login.jsp”的<strong>视图View</strong>解析成一个InternalResourceView对象后，并将返回的model模型属性信息存放到对应的HttpRequest属性中，最后利用<strong>RequestDispatcher</strong>将请求<strong>跳转</strong>至资源“/WEB-INF/pages/login.jsp”。</p>
<p>（4）BeanNameViewResolver</p>
<ol>
<li><p>不继承 AbstractCachingViewResolver，因而无缓存视图的能力；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>在springmvc.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将此视图解析器的优先级设为高 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"toLogin"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Controller层返回名为“toLogin”<strong>（即类型为InternalResourceView的bean的id）</strong>的逻辑视图时，类似的，视图解析器BeanNameViewResolver将该视图解析为<strong>InternalResourceView对象</strong>，并跳转至指定资源。</p>
<p>（5）XmlViewResolver</p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>类似于BeanNameViewResolver，只是InternalResourceView类型的bean的配置信息单独配置在views.xml文件中；</p>
</li>
<li><p><strong>对views.xml存放位置无要求</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.XmlViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定路径下的配置文件/WEB-INF/views.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;bean id="</span><span class="attr">toLogin</span>" <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/login.jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（6）ResourceBundleViewResolver</strong></p>
<ol>
<li><p>extends AbstractCachingViewResolver，缓存视图；</p>
</li>
<li><p>视图资源文件为properties属性文件，且必须<strong>位于classpath根目录下</strong>；</p>
</li>
<li><p>支持解析为多种不同类型的视图View对象。</p>
</li>
</ol>
<p>springmvc.xml中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ResourceBundleViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定视图资源文件名为viewResource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"viewResource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>视图视图资源文件为viewResource，路径必须为”classpath:viewResource.properties”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.(class)=org.springframework.web.servlet.view.InternalResourceView</span><br><span class="line">login.url=/WEB-INF/pages/login.jsp</span><br></pre></td></tr></table></figure>

<p>（7）FreeMarkerViewResolver</p>
<ol>
<li><p>extends UrlBasedViewResolver，缓存；</p>
</li>
<li><p>指定解析后的视图类型为<strong>FreeMarkerView</strong>；</p>
</li>
<li><p>得到的模板文件，可输出为多种文本文档，如HTML、XML、RTF等。</p>
</li>
</ol>
<p>首先在springmvc.xml中配置该视图解析器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"fm_"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".html"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随后仍在springmvc.xml中配置FreeMarkerView类生成的最终视图模板的位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/freemarker/template"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置的视图模板路径下，新建 “fm_freemarker.html” 的模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarkerView<span class="tag">&lt;/<span class="name">title</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 取出数据放入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（8）VelocityViewResolver</p>
<ol>
<li><p>与FreeMarkerViewResolver相似</p>
</li>
<li><p>extends UrlBasedViewResolver；</p>
</li>
<li><p>指定解析后的视图类型为VelocityView。</p>
</li>
</ol>
<h5 id="7-2-视图解析器链-ViewResolverChain"><a href="#7-2-视图解析器链-ViewResolverChain" class="headerlink" title="7.2 视图解析器链 ViewResolverChain"></a>7.2 视图解析器链 ViewResolverChain</h5><p>（1）ViewResolver 实现 Ordered 接口，order属性明确了视图解析器链中不同视图解析器的优先级；</p>
<p>（2）<strong>order越小，优先级越高</strong>；</p>
<p>（3）解析视图时，先从优先级高的解析器开始，若不能解析，则找下一优先级的解析器，若均不能解析，则返回一个null的View对象，抛异常；</p>
<p>（4）<strong>InternalResourceViewResolver可解析任意视图</strong>。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1]《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架学习笔记</title>
    <url>/2019/08/22/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记基于《Spring MVC+Mybatis开发从入门到项目实战》一书，偏向于实践。</p>
<a id="more"></a>

<p><em>一些概念：</em></p>
<ol>
<li><p>ORM：Object Relation Mapping，对象关系映射。通过操作 Java对象来操作关系型数据库。</p>
</li>
<li><p>POJO与 JavaBean</p>
<ul>
<li>POJO：只有private属性和get/set方法且没有其他继承、实现的 Java对象。</li>
<li>JavaBean：private成员变量、get/set方法、<strong>空参构造函数</strong>、<strong>可序列化</strong>。</li>
</ul>
</li>
</ol>
<h4 id="1-Mybatis框架运行流程示意图如下："><a href="#1-Mybatis框架运行流程示意图如下：" class="headerlink" title="1. Mybatis框架运行流程示意图如下："></a>1. Mybatis框架运行流程示意图如下：</h4><p><img src="/2019/08/22/Mybatis框架学习笔记/1.jpg" alt></p>
<h4 id="2-基本配置示例："><a href="#2-基本配置示例：" class="headerlink" title="2. 基本配置示例："></a>2. 基本配置示例：</h4><p>（1）日志输出环境配置文件 <em>log4j.properties</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志级别</span><br><span class="line"># 在开发环境下，日志级别设置为DEBUG，生产环境设置为INFO或ERROR</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># 配置将日志信息打印至控制台</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 定制打印界面格式</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>

<p>（2）数据库配置文件 <em>db.properties</em> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据库配置文件</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br><span class="line">#c3p0.pool.maxPoolSize=400</span><br><span class="line">#c3p0.pool.minPoolSize=50</span><br><span class="line">#c3p0.pool.initialPoolSize=50</span><br><span class="line">#c3p0.pool.acquireIncrement=100</span><br></pre></td></tr></table></figure>

<p>（3）Mybatis核心配置文件 <em>SqlMapConfig.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- properties标签，引入外部配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置日志输出模式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用延迟加载（懒加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否启用积极加载，false表示按需加载（即消极加载） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否开启二级缓存 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置数据类型的别名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 自动为cn.merlin.mybatis.po包下所有的Java类配置别名，类名称s首字母小写 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.merlin.mybatis.po"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"cn.merlin.mybatis.test.QueryPlugin"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置MyBatis环境信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每一个environment标签对应一个单独的数据库环境 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 事务管理 --&gt;</span>	</span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 数据库配置信息 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 映射器，配置SQL映射文件的位置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"UserMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"BankMapper.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"cn/merlin/mybatis/mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）SQL映射文件 <em>UserMapper.xml</em></p>
<blockquote>
<p>加载时机：Mapper映射文件随会话工厂对象 SqlSessionFactory 时被加载。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span> &gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 根据id查询对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE id = #&#123;value&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 当user表中仅有部分字段名称与User类的属性名对应时</span></span><br><span class="line"><span class="comment">		如user_id和user_name字段不对应</span></span><br><span class="line"><span class="comment">		需要使用resultMap标签</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;resultMap type="user" id="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		&lt;id property="id" column="user_id"/&gt;</span></span><br><span class="line"><span class="comment">		&lt;result property="username" column="user_name"/&gt;</span></span><br><span class="line"><span class="comment">	&lt;/resultMap&gt;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&lt;select id="findUserById" parameterType="integer" resultMap="UserResult"&gt;</span></span><br><span class="line"><span class="comment">		SELECT * FROM user WHERE user_id = #&#123;value&#125;</span></span><br><span class="line"><span class="comment">	&lt;/select&gt; --&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 模糊查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserListByUsername"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用"#&#123;&#125;"替代"$&#123;&#125;"可以有效避免SQL注入 --&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE username LIKE "%" #&#123;value&#125; "%"</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 插入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span> &gt;</span></span><br><span class="line">		INSERT INTO user (username,password,gender,province,city) </span><br><span class="line">		VALUE (#&#123;username&#125;,#&#123;password&#125;,#&#123;gender&#125;,#&#123;province&#125;,#&#123;city&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 演示自定义的查询包装类 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByUserQueryInfo"</span> <span class="attr">parameterType</span>=<span class="string">"userQueryInfo"</span> <span class="attr">resultType</span>=<span class="string">"userInstance"</span>&gt;</span></span><br><span class="line">		SELECT * FROM user WHERE user.username = #&#123;userInstance.username&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:</p>
<ol>
<li>使用<strong>“#{}”</strong>替代”${}”可以有效<strong>避免SQL注入攻击</strong>；</li>
<li>当表中部分字段名与 Java类成员变量名不匹配时，需要使用<strong>resultMap</strong>完成列名转换。</li>
</ol>
</blockquote>
<h4 id="3-获取sqlSession会话对象的三种途径："><a href="#3-获取sqlSession会话对象的三种途径：" class="headerlink" title="3. 获取sqlSession会话对象的三种途径："></a>3. 获取sqlSession会话对象的三种途径：</h4><h5 id="3-1-XML配置文件中set属性注入"><a href="#3-1-XML配置文件中set属性注入" class="headerlink" title="3.1 XML配置文件中set属性注入"></a>3.1 XML配置文件中set属性注入</h5><p>spring配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.merlin.ssm.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserDaoImpl 需继承 <strong>SqlSessionDaoSupport 类</strong>，方能通过get方法获取sqlSession。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession(); <span class="comment">// 调用父类（SqlSessionDaoSupport）的getSqlSession()方法</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-注解方式"><a href="#3-2-注解方式" class="headerlink" title="3.2 注解方式"></a>3.2 注解方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span> <span class="comment">// 注入sqlSessionFactory对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-手动获取"><a href="#3-3-手动获取" class="headerlink" title="3.3 手动获取"></a>3.3 手动获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装配，获取SqlSessionFactory对象</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">// 调用SqlSessionFactory类的openSession()方法</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p><strong><em>SqlSessionDaoSupport原理</em></strong></p>
<p>抽象类SqlSessionDaoSupport中有成员变量SqlSession，并配置了get方法。通过setSqlSessionFactory方法可以获得sqlSession实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.externalSqlSession) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sqlSession = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Mapper输出映射类型"><a href="#4-Mapper输出映射类型" class="headerlink" title="4. Mapper输出映射类型"></a>4. Mapper输出映射类型</h4><h5 id="4-1-resultType"><a href="#4-1-resultType" class="headerlink" title="4.1 resultType"></a>4.1 resultType</h5><p>（1）支持基本数据类型、基本数据包装类、自定义包装类（如 JavaBean）；</p>
<p>（2）输出时创建自定义包装类的前提是：<strong>表字段名与包装类属性名完全一致</strong>；</p>
<p>（3）当（2）不满足时，还可以输出为<strong>HashMap</strong>结构、</p>
<h5 id="4-2-resultMap"><a href="#4-2-resultMap" class="headerlink" title="4.2 resultMap"></a>4.2 resultMap</h5><p>当表字段名与包装类属性名不完全一致时</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id="userResultMap"唯一地标识resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"cn.com.mybatis.po.User"</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- id标签：与主键相对应 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"_id"</span> <span class="attr">properties</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- result：普通列 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"_username"</span> <span class="attr">properties</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByResultMap"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">	select id _id,username _username from user where id = #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意resultMap中的<strong>association</strong>、<strong>collection</strong>标签，在涉及 Java包装类属性含有其它包装类或 List集合时会用到。</p>
</blockquote>
<h4 id="5-延迟加载"><a href="#5-延迟加载" class="headerlink" title="5. 延迟加载"></a>5. 延迟加载</h4><p>（1）功能：对于有关联的表，先查询单表，有需要时才查询关联表，以节约资源</p>
<p>（2）设置：</p>
<ul>
<li><p>lazyLoadingEnabled:true 开启延迟加载</p>
</li>
<li><p>aggressiveLazyLoading:false 开启消极加载（即按需加载）</p>
</li>
</ul>
<h4 id="6-动态代理"><a href="#6-动态代理" class="headerlink" title="6. 动态代理"></a>6. 动态代理</h4><blockquote>
<p>不编写DAO层操作数据库代码，在符合一定规范的前提下，由Mapper代理自动完成数据交互。</p>
</blockquote>
<p>示例：</p>
<p>（1）编写名称与Mapper配置文件相同的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">findCustomerById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写CustomerMapper.xml文件</p>
<blockquote>
<p>namespace 设为 接口的全包名：cn.com.mybatis.mapper.CustomerMapper</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.com.mybatis.mapper.CustomerMapper"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findCustomerById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"customer"</span>&gt;</span></span><br><span class="line">		select * from customer where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用SqlSession类的getMapper()方法，获取代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    CustomerMapper customerMapper = sqlSession.getMapper(CustomerMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    Customer customer = customerMapper.findCustomerById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-缓存（HashMap结构）"><a href="#7-缓存（HashMap结构）" class="headerlink" title="7. 缓存（HashMap结构）"></a>7. 缓存（<strong>HashMap</strong>结构）</h4><h5 id="7-1-一级缓存"><a href="#7-1-一级缓存" class="headerlink" title="7.1 一级缓存"></a>7.1 一级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/2.jpg" alt></p>
<blockquote>
<p>一级缓存基于SqlSession会话对象实例，sqlSession级别独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/3.jpg" alt></p>
<blockquote>
<p>查询时，sqlSession首先查询一级缓存，若无，再查询数据库，并将结果存储至一级缓存</p>
</blockquote>
<h5 id="7-2-二级缓存"><a href="#7-2-二级缓存" class="headerlink" title="7.2 二级缓存"></a>7.2 二级缓存</h5><p><img src="/2019/08/22/Mybatis框架学习笔记/4.jpg" alt></p>
<blockquote>
<p>二级缓存基于Mapper实例，namespace一致则共享，否则独立</p>
</blockquote>
<p><img src="/2019/08/22/Mybatis框架学习笔记/5.jpg" alt></p>
<blockquote>
<p>不同的SqlSession实例，执行同一个Mapper文件中的SQL语句，共享二级缓存</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>[1] 《Spring MVC+Mybatis开发从入门到项目实战》朱要光 著</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
</search>

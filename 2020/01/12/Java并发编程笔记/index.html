<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Times New Roman:300,300italic,400,400italic,700,700italic|Arial:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|Arial:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4">



  <link rel="mask-icon" href="/images/favicon.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Concurrency,">










<meta name="description" content="学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。">
<meta name="keywords" content="Concurrency">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程学习笔记">
<meta property="og:url" content="http://yoursite.com/2020/01/12/Java并发编程笔记/index.html">
<meta property="og:site_name" content="Merlin小站">
<meta property="og:description" content="学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7.png">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/Java%E4%B8%AD%E7%9A%84%E9%94%81.png">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5CJava%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/5.jpg">
<meta property="og:updated_time" content="2020-02-26T05:04:51.132Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程学习笔记">
<meta name="twitter:description" content="学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。">
<meta name="twitter:image" content="http://yoursite.com/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/12/Java并发编程笔记/">





  <title>Java并发编程学习笔记 | Merlin小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41cf4fd30b7bc1fc3244bc0f109375f2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Merlin小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一只菜鸟的学习天地</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于我
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索文章
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="站内检索" spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/Java并发编程笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Merlin Hu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Merlin小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java并发编程学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-12T00:00:00+08:00">
                2020-01-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-02-26T13:04:51+08:00">
                2020-02-26
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
				
				
                 <span class="post-meta-item-text">评论</span>
				
                <a href="/2020/01/12/Java并发编程笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/12/Java并发编程笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/01/12/Java并发编程笔记/" class="leancloud_visitors" data-flag-title="Java并发编程学习笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">全文共</span>
                
                <span title="全文共">
                  7,510 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读本文约耗时</span>
                
                <span title="阅读本文约耗时">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>学习、理解多线程与Java并发。笔记主要基于《Java并发编程实战》一书，并结合部分优秀的文章。</p>
<a id="more"></a>

<p>多线程</p>
<ul>
<li><p>优点：多线程程序提高了资源利用效率；</p>
</li>
<li><p>并发安全性问题：多个线程共享进程的部分资源，对于这些共享变量的访问操作可能出现并发异常；</p>
<blockquote>
<p>解决途径：Java提供的同步机制</p>
</blockquote>
</li>
<li><p>活跃性问题：线程陷入死循环，影响后序代码的执行；</p>
</li>
<li><p>性能消耗问题。</p>
</li>
</ul>
<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>重要概念：</p>
<ul>
<li>状态访问操作：任何可能影响对象外部可见行为的操作；</li>
<li>共享：多个线程可同时访问；</li>
<li>可变：变量值可变。</li>
</ul>
<h4 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h4><h5 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h5><p>（1）简单描述线程安全</p>
<blockquote>
<p>当多个线程访问某个类时，该类始终表现出正确的行为，则该类是线程安全的。</p>
</blockquote>
<p>（2）无状态对象是线程安全的</p>
<blockquote>
<p>无状态对象：不包含任何域和对其它类中域的引用，在操作过程中不保存数据，是不变的类，线程安全。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessClass</span></span>&#123;</span><br><span class="line">	<span class="comment">// 不含域，即无成员变量（实例变量和类变量）及局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a; <span class="comment">// Instance Variable(non-static variable)，实例变量，不含</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">// Class Variable(static variable)，类变量，不含</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">10</span>; <span class="comment">// Local Variable，局部变量，不含</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态的对象示例 -- Servlet</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行过程中，仅由线程独享的栈中保存临时数据，因而是线程安全的</span></span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(res, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-竞态条件（Race-Condition）"><a href="#1-2-竞态条件（Race-Condition）" class="headerlink" title="1.2 竞态条件（Race Condition）"></a>1.2 竞态条件（Race Condition）</h5><p>（1）什么是竞态条件？</p>
<p>并发编程中，由于不恰当的执行时序而出现不正确的结果。</p>
<blockquote>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</blockquote>
<p>（2）常见的竞态条件类型</p>
<ol>
<li>先检查后执行（Check-Then-Act）：通过一个可能失效的观测结果来决定下一步的动作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span></span>&#123;</span><br><span class="line">    Private ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyInitRace <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于示例 <strong>延迟初始化</strong> 类，两个线程交替执行过程中，可能均观测到 <code>instance==null</code>，于是分别实例化新的<code>ExpensiveObject</code> 对象，造成 <code>getInstance()</code> 方法返回不同的实例，这是异常情况。</p>
<ol start="2">
<li>读取 - 修改 - 写入：非原子性的操作造成并发异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 访问计数器，线程每访问一次，加1</span></span><br><span class="line">    ...</span><br><span class="line">    count++; <span class="comment">// count++是非原子性的操作，它包括：读取旧值、修改值、写入新值 这三个操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程交替执行时，<code>count++</code> 操作是 <strong>非原子性</strong> 的，最终两个线程分别执行完 <code>count++</code> 操作后得到的 <code>count</code> 是相同的，显然这出现了并发异常。</p>
<p>（3）对于竞态条件，如何保证并发安全性？</p>
<p><img src="/2020/01/12/Java并发编程笔记/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.png" alt></p>
<h4 id="2-多线程的安全性"><a href="#2-多线程的安全性" class="headerlink" title="2. 多线程的安全性"></a>2. 多线程的安全性</h4><blockquote>
<p>安全的多线程并发应保证原子性、可见性和有序性</p>
</blockquote>
<h5 id="2-1-原子性、可见性和有序性"><a href="#2-1-原子性、可见性和有序性" class="headerlink" title="2.1 原子性、可见性和有序性"></a>2.1 原子性、可见性和有序性</h5><p>（1）原子性：对于单个或者多个操作，要么全部执行且不会被中断，要么都不执行。</p>
<blockquote>
<p>Atomic包、synchronized关键字、Lock接口</p>
</blockquote>
<p>（2）可见性：对于共享的可变变量，当一个线程修改了它，其它线程能立即看到变化。</p>
<blockquote>
<p>关键字 synchronized、volatile 和 final，Lock接口</p>
</blockquote>
<p>（3）有序性: </p>
<blockquote>
<p>happens-before原则</p>
</blockquote>
<ul>
<li>程序的执行顺序与代码顺序相同；</li>
<li>JVM在实际执行时会发生 <em>指令重排序</em> ；</li>
<li>重排序对单线程程序无影响，对多线程程序可能会造成并发异常！</li>
</ul>
<h5 id="2-2-如何保证可见性？"><a href="#2-2-如何保证可见性？" class="headerlink" title="2.2 如何保证可见性？"></a>2.2 如何保证可见性？</h5><p><img src="/2020/01/12/Java并发编程笔记/%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt></p>
<h4 id="3-Java-的同步机制"><a href="#3-Java-的同步机制" class="headerlink" title="3. Java 的同步机制"></a>3. Java 的同步机制</h4><blockquote>
<p>同步以保证线程安全。Java提供关键字<strong>synchronized（内置锁）</strong> 和 <strong>Lock接口</strong> 这两种机制实现同步。关键字<strong>volatile</strong> 仅保证可见性，不保证原子性。</p>
</blockquote>
<h5 id="3-1-多线程并发异常演示"><a href="#3-1-多线程并发异常演示" class="headerlink" title="3.1 多线程并发异常演示"></a>3.1 多线程并发异常演示</h5><p>（1）Bank类模拟银行账户存取操作，其中未对相应的方法进行同步，使其面临并发异常的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟多线程并发操作银行账户，Bank类实现了取钱和存钱操作。</span></span><br><span class="line"><span class="comment"> * 注意：在实际应用中，涉及金融数字时不应采用任何基本数据类型，而应使用BigDecimal类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）两个线程分别对同一个Bank实例进行反复地存、取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestBank类，演示在无同步前提下，多个线程并发地对Bank类实例</span></span><br><span class="line"><span class="comment"> * 进行操作是否会出现并发异常。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 存钱线程</span></span><br><span class="line">		Thread addThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.addMoney(<span class="number">300</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 取钱线程</span></span><br><span class="line">		Thread subThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					bank.subMoney(<span class="number">500</span>);</span><br><span class="line">					System.out.println(<span class="string">"***************************************"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		addThread.start();</span><br><span class="line">		subThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.RuntimeException: 当前账户余额不足</span><br><span class="line">	at javasynchronization.Bank.subMoney(Bank.java:20)</span><br><span class="line">	at javasynchronization.UnsafeThread$2.run(UnsafeThread.java:39)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1500 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结合第2行和第4行可知，并发出现异常：存入300元后余额应为1300元；在1300元的基础上支取500元恰好剩余800元。</p>
<p>第12行显示，支取线程因异常而中断，此后为单线程（存钱）操作，不存在并发风险。</p>
</blockquote>
<h5 id="3-2-synchronized-修饰的同步方法【内置锁】"><a href="#3-2-synchronized-修饰的同步方法【内置锁】" class="headerlink" title="3.2 synchronized 修饰的同步方法【内置锁】"></a>3.2 synchronized 修饰的同步方法【内置锁】</h5><blockquote>
<p>关键字 synchronized，Java 所有对象都有一个内置锁，重量级锁。</p>
</blockquote>
<p>（1）SynchronizedBank类，通过<strong>synchronized</strong>实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronizedBank类，模拟银行账户的存取操作，是线程安全的类。</span></span><br><span class="line"><span class="comment"> * 关键字synchronized对subMoney和addMoney方法进行修饰，即利用</span></span><br><span class="line"><span class="comment"> * Java内置锁对上述方法进行加锁，以实现复合操作的原子性，保证线程</span></span><br><span class="line"><span class="comment"> * 安全。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果（测试代码类似于3.1部分）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当前账户初始金额为 1000 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1300 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1100 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 900 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-3-synchronized-同步代码块"><a href="#3-3-synchronized-同步代码块" class="headerlink" title="3.3 synchronized 同步代码块"></a>3.3 synchronized 同步代码块</h5><blockquote>
<p>与 synchronized 修饰的<strong>同步方法</strong>相比，<strong>同步代码块</strong>可<strong>仅对涉及共享变量的操作语句进行加锁</strong>。</p>
</blockquote>
<p>（1）同步代码块示例（由于打印语句需要读取共享变量，故仍要纳入同步代码块中，造成误认为同步方法与同步代码块加锁区域是相同的！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynBloBank类，通过同步代码块避免并发风险。其与SynchronizedBank类中</span></span><br><span class="line"><span class="comment"> * synchronized关键字修饰的同步方法类似，只是同步代码块的同步范围更小（对</span></span><br><span class="line"><span class="comment"> * 影响并发安全性的语句进行同步）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynBloBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SynBloBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 同步代码块，锁对象是"this"，即调用此方法者</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当前账户初始金额为 900 元</span><br><span class="line">Thread-1 支取 500 元，余额为 400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 700 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 200 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 500 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 300 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步代码块：对有并发风险的操作语句进行加锁；</p>
<p>同步方法：对含有并发风险操作的方法进行加锁。</p>
</blockquote>
<h5 id="3-4-ReentrantLock-【显示锁】"><a href="#3-4-ReentrantLock-【显示锁】" class="headerlink" title="3.4 ReentrantLock 【显示锁】"></a>3.4 ReentrantLock 【显示锁】</h5><blockquote>
<p>ReentrantLock类实现Lock接口</p>
</blockquote>
<p>（1）ReentrantLock加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockBank类，线程安全类。</span></span><br><span class="line"><span class="comment"> * Lock接口定义了锁的操作（包括lock和unlock）。ReentrantLock类实现Lock接口，</span></span><br><span class="line"><span class="comment"> * 默认采用非公平的锁策略。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 账户余额</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 锁对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LockBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			count -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count += money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当前账户初始金额为 8888 元</span><br><span class="line">Thread-1 支取 500 元，余额为 8388 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8688 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8188 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8488 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 8788 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 8288 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<h5 id="3-5-关键字-volatile-【不行！】"><a href="#3-5-关键字-volatile-【不行！】" class="headerlink" title="3.5 关键字 volatile 【不行！】"></a>3.5 关键字 volatile 【不行！】</h5><blockquote>
<p>volatile 关键字可以<strong>实现可见性</strong>，但<strong>无法保证原子性</strong>。</p>
</blockquote>
<p>（1）volatile 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VolatileBank类，关键字volatile修饰成员变量count，保证</span></span><br><span class="line"><span class="comment"> * 可见性，但不能保证原子性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-02-18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Merlin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBank</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VolatileBank</span><span class="params">(<span class="keyword">int</span> initMoney)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = initMoney;</span><br><span class="line">		System.out.println(<span class="string">"当前账户初始金额为 "</span>+initMoney+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; money) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"当前账户余额不足"</span>); <span class="comment">// 当前账户余额不足时，抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		count -= money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 支取 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		count += money;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">" 存入 "</span>+money+<span class="string">" 元，余额为 "</span>+count+<span class="string">" 元"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）随机试验结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当前账户初始金额为 1500 元</span><br><span class="line">Thread-0 存入 300 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1800 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1600 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-1 支取 500 元，余额为 1400 元</span><br><span class="line">***************************************</span><br><span class="line">Thread-0 存入 300 元，余额为 1400 元</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随机测试结果表明：并发过程出现异常，即 <em>关键字 volatile 无法保证原子性！</em></p>
</blockquote>
<h4 id="4-Java-中的锁"><a href="#4-Java-中的锁" class="headerlink" title="4. Java 中的锁"></a>4. Java 中的锁</h4><p><img src="/2020/01/12/Java并发编程笔记/Java%E4%B8%AD%E7%9A%84%E9%94%81.png" alt></p>
<h5 id="4-1-synchronized及锁升级过程"><a href="#4-1-synchronized及锁升级过程" class="headerlink" title="4.1 synchronized及锁升级过程"></a>4.1 synchronized及锁升级过程</h5><blockquote>
<p>JDK 1.5之后，synchronized锁被划分为四种状态：无锁 - 偏向锁 - 轻量级锁 - 重量级锁。</p>
</blockquote>
<p>（1）Java普通对象的内存布局</p>
<p>（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> &amp; <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt></p>
<p>（2）锁升级过程</p>
<p>Java锁升级过程（图源：<a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a> ）</p>
<p><img src="/2020/01/12/Java并发编程笔记/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%5CJava%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ol>
<li><p>无锁</p>
<ul>
<li>偏向锁标志位：0</li>
<li>锁标志位：01</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li>设定 -XX:BiasedLockingStartupDelay = 0，由默认轻量级锁改为偏向锁。</li>
<li>偏向锁标志位：1</li>
<li>锁标志位：01</li>
<li><strong>记录当前线程ID</strong></li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li><p>锁标志位：00</p>
</li>
<li><p>当<strong>第二个线程</strong>参与竞争偏向锁时，对象根据对象头markdown中记录的<strong>线程ID</strong>发现是新线程，<strong>立即撤销偏向锁，升级为轻量级锁</strong>。</p>
</li>
<li><p>线程生成<strong>LockRecord</strong>保存在线程栈中。每个线程通过<strong>CAS（自旋）</strong>操作，试图将对象头中的<strong>指向栈中锁记录的指针</strong>记录为自己的LockRecord。成功则获取锁。</p>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>锁标志位：10</li>
<li>锁竞争加剧（如线程自旋次数或自旋的线程数超过阈值），由轻量级锁升级为重量级锁。</li>
<li>重量级锁开始切换用户态/内核态，开销较大。</li>
</ul>
</li>
</ol>
<h5 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h5><p>（暂无）</p>
<h5 id="4-3-ReentrantReadWriteLock"><a href="#4-3-ReentrantReadWriteLock" class="headerlink" title="4.3 ReentrantReadWriteLock"></a>4.3 ReentrantReadWriteLock</h5><p>（暂无）</p>
<h3 id="二、Java类库中的并发基础构建模块"><a href="#二、Java类库中的并发基础构建模块" class="headerlink" title="二、Java类库中的并发基础构建模块"></a>二、Java类库中的并发基础构建模块</h3><h4 id="1-同步容器类"><a href="#1-同步容器类" class="headerlink" title="1. 同步容器类"></a>1. 同步容器类</h4><ul>
<li>Vector</li>
<li>Hashtable</li>
</ul>
<p>同步容器类通过“封装状态，同步所有公有方法”使得每次只有一个线程可以访问容器的状态，以此实现线程安全。</p>
<h5 id="1-1-为什么要为同步容器类额外地进行客户端加锁？"><a href="#1-1-为什么要为同步容器类额外地进行客户端加锁？" class="headerlink" title="1.1 为什么要为同步容器类额外地进行客户端加锁？"></a>1.1 为什么要为同步容器类额外地进行客户端加锁？</h5><blockquote>
<p>客户端加锁：对于使用某个对象的客户端代码，通过对象本身用于保护其状态的锁来保护这段客户端代码。</p>
</blockquote>
<p><em>对于复合操作，同步容器类可能会出现并发异常，但这种异常并非是同步容器类被破坏导致的</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步容器类Vector，对其进行复合操作时可能会出现异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    vector.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程 <code>Thread_A</code> 和 <code>Thread_B</code> 并发地对 <code>Vector</code> 实例进行复合操作时，<strong>无法破坏 vector 对象</strong>，但从下图可以看出，对调用者 <code>Thread_A</code> 来说，出现异常。</p>
<p><img src="/2020/01/12/Java并发编程笔记/3.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行客户端加锁，以保证对同步容器类实例的复合操作是线程安全的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象vector的锁来进行客户端加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.siez()-<span class="number">1</span>;</span><br><span class="line">   		<span class="keyword">return</span> vector.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector vector)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = vector.size()-<span class="number">1</span>;</span><br><span class="line">    	vector.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-对容器进行迭代操作是有并发风险的"><a href="#1-2-对容器进行迭代操作是有并发风险的" class="headerlink" title="1.2 对容器进行迭代操作是有并发风险的"></a>1.2 对容器进行迭代操作是有并发风险的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在迭代操作中，其它线程可能并发地修改容器，导致当前线程迭代出现异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">    	doSomething(vector.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-如何降低加锁带来的性能影响？"><a href="#1-3-如何降低加锁带来的性能影响？" class="headerlink" title="1.3 如何降低加锁带来的性能影响？"></a>1.3 如何降低加锁带来的性能影响？</h5><blockquote>
<p>克隆容器，在<strong>线程封闭</strong>的副本上进行加锁、复合操作。</p>
</blockquote>
<h4 id="2-并发容器类"><a href="#2-并发容器类" class="headerlink" title="2. 并发容器类"></a>2. 并发容器类</h4><h5 id="2-1-并发容器类与同步容器类的比较"><a href="#2-1-并发容器类与同步容器类的比较" class="headerlink" title="2.1 并发容器类与同步容器类的比较"></a>2.1 并发容器类与同步容器类的比较</h5><p>（1）同步容器类在执行每一个操作时均持有锁，虽保证了线程安全，但降低了并发性。</p>
<p>（2）多个线程竞争同步容器类的锁时，将严重降低系统吞吐量。</p>
<p>（3）并发容器类较同步容器类有更好地并发性能。</p>
<h5 id="2-2-以ConcurrentHashMap为例"><a href="#2-2-以ConcurrentHashMap为例" class="headerlink" title="2.2 以ConcurrentHashMap为例"></a>2.2 以ConcurrentHashMap为例</h5><p>（1）加锁策略 —— <strong>分段锁（Lock Striping）</strong>，细粒度的锁</p>
<ul>
<li>Hashtable（同步容器类）：执行每个操作时均持有锁，提供独占式访问；</li>
<li>SynchronizedMap（同步且基于散列的Map，Collections类中定义的内部类）：独占式访问</li>
<li>ConcurrentHashMap：不是将每个方法在同一个锁上同步，因此<strong>不提供独占式访问</strong>；多个线程可并发访问容器。</li>
</ul>
<p>（2）分段锁策略的特性</p>
<ul>
<li>多个读取线程可并发地访问容器；</li>
<li>多个写入线程可并发地修改容器；</li>
<li>读取线程和并发线程可并发地操作容器。</li>
</ul>
<p>（3）ConcurrentHashMap的优势</p>
<ul>
<li>并发环境下提高系统吞吐量；</li>
<li>迭代器不会抛出ConcurrentModificationException。</li>
</ul>
<h5 id="2-3-ConcurrentHashMap结构及分段锁"><a href="#2-3-ConcurrentHashMap结构及分段锁" class="headerlink" title="2.3 ConcurrentHashMap结构及分段锁"></a>2.3 ConcurrentHashMap结构及分段锁</h5><p><img src="/2020/01/12/Java并发编程笔记/4.jpg" alt></p>
<p>如图所示，ConcurrentHashMap被分为多个片段（Segment），同时一个片段被分为多个HashEntry。</p>
<ul>
<li>Segment继承 <code>ReentrantLock</code> ，扮演锁的角色；</li>
<li>HashEntry用于存储键值对数据（注意：ConcurrentHashMap中key和value均不得为null）；</li>
<li>修改HashEntry数组的数据时，线程必须<strong>先获得对应的Segment锁</strong>。</li>
</ul>
<h4 id="3-同步工具类"><a href="#3-同步工具类" class="headerlink" title="3. 同步工具类"></a>3. 同步工具类</h4><blockquote>
<p>同步工具类是指能根据其自身的状态来<strong>协调线程的控制流</strong>的对象。</p>
</blockquote>
<p>示例：阻塞队列（BlockingQueue）、信号量（Semaphore）、栅栏（Barrier）、闭锁（Latch）</p>
<h5 id="3-1-信号量"><a href="#3-1-信号量" class="headerlink" title="3.1 信号量"></a>3.1 信号量</h5><p>信号量通过管理一组虚拟的许可来控制操作，其具体实现如下：</p>
<ul>
<li>控制同时访问数</li>
<li>实现资源池</li>
<li>对容器施加边界</li>
</ul>
<h5 id="3-2-闭锁"><a href="#3-2-闭锁" class="headerlink" title="3.2 闭锁"></a>3.2 闭锁</h5><p>闭锁是指可以<strong>延迟线程的进度</strong>直到其到达终止状态，其特性如下：</p>
<ul>
<li><p>一次性对象，<strong>不能被重置</strong>；</p>
</li>
<li><p>闭锁到达终止状态前，不允许任何线程通过；</p>
</li>
<li><p>闭锁到达终止状态后，允许线程通过；</p>
</li>
<li><p>用以确保某些活动直到其它活动都完成后再开始，例如待所需资源全部加载后才开始执行初始化。</p>
</li>
</ul>
<h5 id="3-3-栅栏"><a href="#3-3-栅栏" class="headerlink" title="3.3 栅栏"></a>3.3 栅栏</h5><p>栅栏能<strong>阻塞一组线程</strong>直到某个事件发生</p>
<ul>
<li>栅栏要求线程同时到达栅栏位置，方能继续执行；</li>
<li>非一次性；</li>
<li>闭锁用于<em>等待事件</em>，栅栏用于<em>等待线程</em>。</li>
</ul>
<h3 id="三、任务执行策略"><a href="#三、任务执行策略" class="headerlink" title="三、任务执行策略"></a>三、任务执行策略</h3><h4 id="1-串行与并行执行任务"><a href="#1-串行与并行执行任务" class="headerlink" title="1. 串行与并行执行任务"></a>1. 串行与并行执行任务</h4><h5 id="1-1-串行执行任务"><a href="#1-1-串行执行任务" class="headerlink" title="1.1 串行执行任务"></a>1.1 串行执行任务</h5><p><em>显然，服务器单线程串行执行任务，低吞吐量 &amp; 低响应速度</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket connection = socket.accept(); <span class="comment">// 接收请求</span></span><br><span class="line">            handleRequest(connection); <span class="comment">// 处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，服务器只有一个主线程来监听80端口、接收并处理请求。简言之，每次只能有一个请求被处理，后续请求必须等待前序请求完成后才能被服务器接收、处理。</p>
<h5 id="1-2-并行执行任务"><a href="#1-2-并行执行任务" class="headerlink" title="1.2 并行执行任务"></a>1.2 并行执行任务</h5><p><em>主线程监听端口、接收并分发请求，同时创建新线程来处理请求</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadWebServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); <span class="comment">// 主线程接收请求</span></span><br><span class="line">            Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection); <span class="comment">// 主线程创建新线程处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(command).start(); <span class="comment">// 启动新线程，处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性：</p>
<ul>
<li><strong>在不超过服务器处理能力的前提下</strong>，提高了服务器吞吐量和响应速度；</li>
<li>主线程监听端口、接收并分发请求，创建新线程；</li>
<li>处理请求的线程<strong>并发地处理请求</strong>。</li>
</ul>
<h5 id="1-3-主线程频繁新建线程的风险"><a href="#1-3-主线程频繁新建线程的风险" class="headerlink" title="1.3 主线程频繁新建线程的风险"></a>1.3 主线程频繁新建线程的风险</h5><ul>
<li>创建和销毁线程的开销非常高；</li>
<li>大量线程带来的资源消耗会降低性能；</li>
<li>线程数量超过限制会造成系统异常。</li>
</ul>
<h4 id="2-Executor框架-——-异步任务执行框架"><a href="#2-Executor框架-——-异步任务执行框架" class="headerlink" title="2. Executor框架 —— 异步任务执行框架"></a>2. Executor框架 —— 异步任务执行框架</h4><blockquote>
<p>异步任务执行：将<strong>任务的提交过程</strong>和<strong>执行过程</strong>解耦合</p>
</blockquote>
<h5 id="2-1-为何使用Executor框架？"><a href="#2-1-为何使用Executor框架？" class="headerlink" title="2.1 为何使用Executor框架？"></a>2.1 为何使用Executor框架？</h5><p>前述两种<em>任务执行策略</em>（单线程串行执行任务、新建线程并行执行任务）均存在一定的不足。在异步任务执行框架中将任务的提交和执行解耦，其中通过<strong>线程池</strong>实现对线程的高效管理。</p>
<h5 id="2-2-Executor框架的基础-——-生产者-消费者模式"><a href="#2-2-Executor框架的基础-——-生产者-消费者模式" class="headerlink" title="2.2 Executor框架的基础 —— 生产者-消费者模式"></a>2.2 Executor框架的基础 —— 生产者-消费者模式</h5><ul>
<li>生产者：提交任务的操作</li>
<li>消费者：执行任务的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorWebServer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">50</span>; <span class="comment">// 线程池长度</span></span><br><span class="line">    <span class="comment">// newFixedThreadPool方法将返回一个固定长度的线程池，其长度不再变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec</span><br><span class="line">        = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); <span class="comment">// 主线程监听80端口</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Connection connection = socket.accept();</span><br><span class="line">         	Runnable command = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(command); <span class="comment">// 线程池负责管理线程以执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>通过实现 Executor接口，可制定更丰富的执行策略</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Executor框架结构"><a href="#2-3-Executor框架结构" class="headerlink" title="2.3 Executor框架结构"></a>2.3 Executor框架结构</h5><p><img src="/2020/01/12/Java并发编程笔记/5.jpg" alt></p>
<p><em>Executor框架包括以下三个部分：</em></p>
<ol>
<li><p><strong>任务</strong>：被执行的任务需要实现Runnable接口或Callable接口；</p>
</li>
<li><p><strong>执行</strong>：线程执行任务，包括Executor接口和最重要的<strong>ThreadPoolExecutor</strong>类；</p>
</li>
<li><p><strong>异步计算</strong>：包括Future接口及实现Future接口的FutureTask类。</p>
</li>
</ol>
<h5 id="2-4-Executor框架的执行过程"><a href="#2-4-Executor框架的执行过程" class="headerlink" title="2.4 Executor框架的执行过程"></a>2.4 Executor框架的执行过程</h5><p>（1）创建任务对象</p>
<p>创建实现Runnable接口或Callable接口的任务对象。</p>
<p><em>实现 Runnable接口，重写 run 方法：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"实现Runnable接口，重写run方法，无返回值"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>实现 Callable 接口，重写 call 方法：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"实现Callable接口，重写Call方法，有返回值"</span>;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Runnable接口与Callable接口的区别：</strong></p>
<ul>
<li>Runnable接口无返回值；</li>
<li>Callable接口有返回值，需要声明抛出异常。</li>
</ul>
<p><em>通过工厂类 Executors 的 Callable(Runnable task) 方法可将 Runnable 对象包装成 Callable 对象</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Object&gt; task = Executors.callable(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<p>（2）执行任务</p>
<blockquote>
<p>通过实现java.util.concurrent.ExecutorService接口的对象来执行任务</p>
</blockquote>
<ol>
<li>将Runnable对象交给ExecutorService执行，调用<strong>execute</strong>方法，无返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Runnable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象，<strong>但调用Future对象的get方法，返回值为null</strong>。【源码分析见 2.5】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;Object&gt; future = (Future&lt;Object&gt;) es.submit(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(future.get()==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"future.get()返回null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将Callable对象交给ExecutorService执行，调用<strong>submit</strong>方法，返回Future对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">				<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure>

<p>（3）关闭线程池</p>
<ol>
<li>对于执行ExecutorService的execute方法，调用shutdown方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">es.execute(<span class="keyword">new</span> RunnableTask());</span><br><span class="line"></span><br><span class="line">es.shutdown(); <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于执行ExecutorService的submit方法，主线程可执行FutureTask.get()方法等待任务执行完毕，也可通过FutureTask.cancel()方法取消任务的执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(future.get());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解"><a href="#2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解" class="headerlink" title="2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解"></a>2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解</h5><p> <strong>AbstractExecutorService</strong>类实现了ExecutorService接口并实现了<strong>submit()</strong> 方法，ThreadPoolExecutor类从AbstractExecutorService类继承了submit方法。</p>
<p><em>基于 JDK 1.8的源码，分析如下：</em></p>
<p>AbstractExecutorService类实现了ExecutorService接口，实现submit()方法。将Runnable对象交给 ExecutorService去处理且调用<code>submit(Runnable task)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask); <span class="comment">// 调用ThreadPoolExecutor类的execute方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部通过调用<code>newTaskFor(Runnable runnable, T value)</code>方法返回一个<code>FutureTask</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造<code>FutureTask</code>对象时，通过调用<code>Executors.callable(runnable, result)</code>方法<strong>将Runnable对象包装成Callable对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于提交的 Callable 对象，AbstractExecutorService 类同样是调用 newTaskFor 方法 返回一个 FutureTask 对象：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-线程池-——-高效地管理线程的生命周期"><a href="#3-线程池-——-高效地管理线程的生命周期" class="headerlink" title="3. 线程池 —— 高效地管理线程的生命周期"></a>3. 线程池 —— 高效地管理线程的生命周期</h4><p><em>重要参数：</em></p>
<ul>
<li><p>corePoolSize：线程池的目标大小，即无任何任务执行时线程池的大小，且仅当工作队列已满才会产生大于此值的线程数量。</p>
</li>
<li><p>maximumPoolSize：线程池最大同时活动线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。线程空闲时间大于存活时间，被标记为“可回收”；活动线程数大于corePoolSize时，回收标记为“可回收”的空闲线程。</p>
</li>
</ul>
<p><strong><em>两个重要的问题：</em></strong></p>
<ol>
<li><p>为什么要使用线程池，而不是直接手动创建线程？</p>
<ul>
<li><p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。</p>
</li>
<li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>为什么要通过ThreadPoolExecutor创建线程池，而不是通过工厂类Executors？<ul>
<li>使开发者更加明确线程池的运行规则，避免资源耗尽的风险。</li>
<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integet.MAX_VALUE，可能会堆积大量的请求。</li>
<li>CachedThreadPool 和 ScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程。</li>
<li>上述四种方式其本质还是调用ThreadPoolExecutor。</li>
</ul>
</li>
</ol>
<h5 id="3-1-通过工厂类Executors的静态工厂方法"><a href="#3-1-通过工厂类Executors的静态工厂方法" class="headerlink" title="3.1 通过工厂类Executors的静态工厂方法"></a>3.1 通过工厂类Executors的静态工厂方法</h5><p>通过调用工厂类Executors中的静态工厂方法，可产生如下类型的线程池：</p>
<ul>
<li>newFixedThreadPool  固定长度</li>
<li>newCachedThreadPool 可缓存</li>
<li>newSingleThreadExecutor 单线程</li>
<li>newScheduledThreadPool 延时/定时执行任务，固定长度</li>
</ul>
<p>（1）newFixedThreadPool</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为指定值nThread，keepAliveTime设为0。</p>
</li>
<li><p>固定长度的线程池。因corePoolSize为nThread，故每提交一个任务就创建一个线程，直到总数为nThreads。</p>
</li>
<li><p>keepAliveTime为0，线程不会超时。</p>
</li>
<li><p>线程执行过程中异常中断，会新建线程以补充。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）newCachedThreadPool</p>
<ul>
<li><p>corePoolSize设为0，maximumPoolSize设为Integer.MAX_VALUE，keepAliveTime设为60秒。</p>
</li>
<li><p>无可用线程时新建线程，有可用线程时则复用该线程。</p>
</li>
<li><p>因maximumPoolSize设为Integer.MAX_VALUE，即线程数最大值为2147483647。</p>
</li>
<li><p>线程存活时间为60秒，避免大量空闲线程对资源的消耗。</p>
</li>
<li><p>同步任务队列SynchronousQueue<runnable>。</runnable></p>
</li>
<li><p>此线程池适用于大量短暂的异步任务。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）newSingleThreadExecutor</p>
<ul>
<li><p>corePoolSize和maximumPoolSize均设为1，keepAliveTime设为0。</p>
</li>
<li><p>首次提交任务时创建单个线程，且仅维持一个线程。</p>
</li>
<li><p>当线程在关闭前异常终止，程序新建一个线程以执行后续任务。</p>
</li>
<li><p>确保任务串行执行。</p>
</li>
<li><p>无边界的任务队列LinkedBlockingQueue<runnable>。</runnable></p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法返回的是FinalizableDelegatedExecutorService对象，其内部保存一个ThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用Executors类的静态方法newSingleThreadExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类FinalizableDelegatedExecutorService，其继承自Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors的静态内部类DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e; <span class="comment">// 内部保存一个ExecutorService对象</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）newScheduledThreadPool</p>
<ul>
<li><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>可延时执行阻塞任务的队列。</p>
</li>
</ul>
<p>Executors类中有两个静态方法用于生成该线程池对象：</p>
<blockquote>
<p>两种方法的差异在于：前者使用<strong>默认的ThreadFactory对象</strong>，后者使用指定的ThreadFactory对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法指定线程池基本大小、返回ScheduledThreadPoolExecutor对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ScheduledThreadPoolExecutor类，其调用父类ThreadPoolExecutor的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-ThreadPoolExecutor"><a href="#3-2-ThreadPoolExecutor" class="headerlink" title="3.2 ThreadPoolExecutor"></a>3.2 ThreadPoolExecutor</h5><p>（暂无）</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] 《Java并发编程实战》Goetz B. 著，童云兰译</p>
<p>[2] <a href="https://www.infoq.cn/article/ConcurrentHashMap/" target="_blank" rel="noopener">https://www.infoq.cn/article/ConcurrentHashMap/</a></p>
<p>[3] <a href="http://www.bubuko.com/infodetail-1518587.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1518587.html</a></p>
<p>[4] <a href="https://blog.csdn.net/tongdanping/article/details/79604637" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79604637</a></p>
<p>[5] <a href="https://www.cnblogs.com/xifengxiaoma/p/11477136.html" target="_blank" rel="noopener">https://www.cnblogs.com/xifengxiaoma/p/11477136.html</a></p>
<p>[6] <a href="https://www.cnblogs.com/jiansen/p/7351872.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiansen/p/7351872.html</a></p>
<p>[7] <a href="https://blog.csdn.net/csdnnews/article/details/104471154/" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/104471154/</a></p>
<p>[8] <a href="https://www.cnblogs.com/panning/p/10990502.html" target="_blank" rel="noopener">https://www.cnblogs.com/panning/p/10990502.html</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                               </p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>请我喝肥宅快乐水吧!</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Merlin Hu 微信">
        <p>微信</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Merlin Hu 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Merlin Hu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2020/01/12/Java并发编程笔记/" title="Java并发编程学习笔记">http://yoursite.com/2020/01/12/Java并发编程笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
			  <a href="/2020/01/13/五大常用算法之回溯算法/" rel="prev" title="五大常用算法之回溯算法">
				<i class="fa fa-chevron-left"></i> 五大常用算法之回溯算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
			  <a href="/2020/01/02/五大常用算法之动态规划/" rel="next" title="五大常用算法之动态规划">
				五大常用算法之动态规划 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Merlin Hu">
            
              <p class="site-author-name" itemprop="name">Merlin Hu</p>
              <p class="site-description motion-element" itemprop="description">累了，想一想，再出发！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MerlinHu0112" target="_blank" title="GayHub">
                      
                        <i class="fa fa-fw fa-github"></i>GayHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hainuhujun@163.com" target="_blank" title="E-mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基础知识"><span class="nav-text">一、基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-安全性问题"><span class="nav-text">1. 安全性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-线程安全"><span class="nav-text">1.1 线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-竞态条件（Race-Condition）"><span class="nav-text">1.2 竞态条件（Race Condition）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-多线程的安全性"><span class="nav-text">2. 多线程的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-原子性、可见性和有序性"><span class="nav-text">2.1 原子性、可见性和有序性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-如何保证可见性？"><span class="nav-text">2.2 如何保证可见性？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Java-的同步机制"><span class="nav-text">3. Java 的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-多线程并发异常演示"><span class="nav-text">3.1 多线程并发异常演示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-synchronized-修饰的同步方法【内置锁】"><span class="nav-text">3.2 synchronized 修饰的同步方法【内置锁】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-synchronized-同步代码块"><span class="nav-text">3.3 synchronized 同步代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-ReentrantLock-【显示锁】"><span class="nav-text">3.4 ReentrantLock 【显示锁】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-关键字-volatile-【不行！】"><span class="nav-text">3.5 关键字 volatile 【不行！】</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java-中的锁"><span class="nav-text">4. Java 中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-synchronized及锁升级过程"><span class="nav-text">4.1 synchronized及锁升级过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-ReentrantLock"><span class="nav-text">4.2 ReentrantLock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-ReentrantReadWriteLock"><span class="nav-text">4.3 ReentrantReadWriteLock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Java类库中的并发基础构建模块"><span class="nav-text">二、Java类库中的并发基础构建模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步容器类"><span class="nav-text">1. 同步容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-为什么要为同步容器类额外地进行客户端加锁？"><span class="nav-text">1.1 为什么要为同步容器类额外地进行客户端加锁？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-对容器进行迭代操作是有并发风险的"><span class="nav-text">1.2 对容器进行迭代操作是有并发风险的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-如何降低加锁带来的性能影响？"><span class="nav-text">1.3 如何降低加锁带来的性能影响？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-并发容器类"><span class="nav-text">2. 并发容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-并发容器类与同步容器类的比较"><span class="nav-text">2.1 并发容器类与同步容器类的比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-以ConcurrentHashMap为例"><span class="nav-text">2.2 以ConcurrentHashMap为例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-ConcurrentHashMap结构及分段锁"><span class="nav-text">2.3 ConcurrentHashMap结构及分段锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-同步工具类"><span class="nav-text">3. 同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-信号量"><span class="nav-text">3.1 信号量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-闭锁"><span class="nav-text">3.2 闭锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-栅栏"><span class="nav-text">3.3 栅栏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、任务执行策略"><span class="nav-text">三、任务执行策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-串行与并行执行任务"><span class="nav-text">1. 串行与并行执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-串行执行任务"><span class="nav-text">1.1 串行执行任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-并行执行任务"><span class="nav-text">1.2 并行执行任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-主线程频繁新建线程的风险"><span class="nav-text">1.3 主线程频繁新建线程的风险</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Executor框架-——-异步任务执行框架"><span class="nav-text">2. Executor框架 —— 异步任务执行框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-为何使用Executor框架？"><span class="nav-text">2.1 为何使用Executor框架？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-Executor框架的基础-——-生产者-消费者模式"><span class="nav-text">2.2 Executor框架的基础 —— 生产者-消费者模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-Executor框架结构"><span class="nav-text">2.3 Executor框架结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-Executor框架的执行过程"><span class="nav-text">2.4 Executor框架的执行过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-对Runnbale对象直接调用ExecutorService的submit方法的理解"><span class="nav-text">2.5 对Runnbale对象直接调用ExecutorService的submit方法的理解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-线程池-——-高效地管理线程的生命周期"><span class="nav-text">3. 线程池 —— 高效地管理线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-通过工厂类Executors的静态工厂方法"><span class="nav-text">3.1 通过工厂类Executors的静态工厂方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-ThreadPoolExecutor"><span class="nav-text">3.2 ThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料："><span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Merlin Hu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">全站共计</span>
    
    <span title="全站共计">24.3k 字</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      您是第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位访客，感谢！
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>
  
  
  
  
  <script src="/js/src/Valine.min.js"></script>
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'uzQCxlvfc9orljLUwSjYLfts-gzGzoHsz',
        appKey: 'P0kfT4nVA2h1JpNP7dI9AUFC',
        placeholder: '感谢您提出宝贵的意见',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'5' || 10,
    });
	
	var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
	
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'true') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("uzQCxlvfc9orljLUwSjYLfts-gzGzoHsz", "P0kfT4nVA2h1JpNP7dI9AUFC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制代码').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制代码')
        }, 300)
      }).append(e)
    })
  </script>

</body>
</html>
